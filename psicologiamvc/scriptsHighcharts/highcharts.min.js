!function (a, b) {
    "object" === typeof module && module.exports ? (b["default"] = b, module.exports = a.document ? b(a) : b) : "function" === typeof define && define.amd ? define("highcharts/highcharts", function () {
        return b(a);
    }) : (a.Highcharts && a.Highcharts.error(16, !0), a.Highcharts = b(a));
}("undefined" !== typeof window ? window : this, function (a) {
    function b(b, c, d, e) {
        b.hasOwnProperty(c) || (b[c] = e.apply(null, d), "function" === typeof CustomEvent && a.dispatchEvent(new CustomEvent("HighchartsModuleLoaded", {
            detail: {
                path: c,
                module: b[c]
            }
        })));
    }
    var c = {};
    b(c, "Core/Globals.js", [], function () {
        var b;
        !function (b) {
            b.SVG_NS = "http://www.w3.org/2000/svg";
            b.product = "Highcharts";
            b.version = "10.0.0";
            b.win = "undefined" !== typeof a ? a : {};
            b.doc = b.win.document;
            b.svg = b.doc && b.doc.createElementNS && !!b.doc.createElementNS(b.SVG_NS, "svg").createSVGRect;
            b.userAgent = b.win.navigator && b.win.navigator.userAgent || "";
            b.isChrome = -1 !== b.userAgent.indexOf("Chrome");
            b.isFirefox = -1 !== b.userAgent.indexOf("Firefox");
            b.isMS = /(edge|msie|trident)/i.test(b.userAgent) && !b.win.opera;
            b.isSafari = !b.isChrome && -1 !== b.userAgent.indexOf("Safari");
            b.isTouchDevice = /(Mobile|Android|Windows Phone)/.test(b.userAgent);
            b.isWebKit = -1 !== b.userAgent.indexOf("AppleWebKit");
            b.deg2rad = 2 * Math.PI / 360;
            b.hasBidiBug = b.isFirefox && 4 > parseInt(b.userAgent.split("Firefox/")[1], 10);
            b.hasTouch = !!b.win.TouchEvent;
            b.marginNames = ["plotTop", "marginRight", "marginBottom", "plotLeft"];
            b.noop = function () { };
            b.supportsPassiveEvents = function () {
                var a = !1;
                if (!b.isMS) {
                    var c = Object.defineProperty({}, "passive", {
                        get: function () {
                            a = !0;
                        }
                    });
                    b.win.addEventListener && b.win.removeEventListener && (b.win.addEventListener("testPassive", b.noop, c),
                        b.win.removeEventListener("testPassive", b.noop, c));
                }
                return a;
            }();
            b.charts = [];
            b.dateFormats = {};
            b.seriesTypes = {};
            b.symbolSizes = {};
            b.chartCount = 0;
        }(b || (b = {}));
        return b;
    });
    b(c, "Core/Utilities.js", [c["Core/Globals.js"]], function (a) {
        function b(c, d, e, f) {
            var g = d ? "Highcharts error" : "Highcharts warning";
            32 === c && (c = g + ": Deprecated member");
            var h = j(c), i = h ? g + " #" + c + ": www.highcharts.com/errors/" + c + "/" : c.toString();
            if ("undefined" !== typeof f) {
                var k = "";
                h && (i += "?");
                r(f, function (a, b) {
                    k += "\n - " + b + ": " + a;
                    h && (i += encodeURI(b) + "=" + encodeURI(a));
                });
                i += k;
            }
            t(a, "displayError", {
                chart: e,
                code: c,
                message: i,
                params: f
            }, function () {
                if (d) throw Error(i);
                w.console && -1 === b.messages.indexOf(i) && console.warn(i);
            });
            b.messages.push(i);
        }
        function c(a, b) {
            var d = {};
            r(a, function (e, f) {
                if (g(a[f], !0) && !a.nodeType && b[f]) e = c(a[f], b[f]), Object.keys(e).length && (d[f] = e); else if (g(a[f]) || a[f] !== b[f] || f in a && !(f in b)) d[f] = a[f];
            });
            return d;
        }
        function d(a, b) {
            return parseInt(a, b || 10);
        }
        function e(a) {
            return "string" === typeof a;
        }
        function f(a) {
            a = Object.prototype.toString.call(a);
            return "[object Array]" === a || "[object Array Iterator]" === a;
        }
        function g(a, b) {
            return !!a && "object" === typeof a && (!b || !f(a));
        }
        function h(a) {
            return g(a) && "number" === typeof a.nodeType;
        }
        function i(a) {
            var b = a && a.constructor;
            return !(!g(a, !0) || h(a) || !b || !b.name || "Object" === b.name);
        }
        function j(a) {
            return "number" === typeof a && !isNaN(a) && 1 / 0 > a && -1 / 0 < a;
        }
        function k(a) {
            return "undefined" !== typeof a && null !== a;
        }
        function l(a, b, c) {
            var d = e(b) && !k(c), f, g = function (b, c) {
                k(b) ? a.setAttribute(c, b) : d ? (f = a.getAttribute(c)) || "class" !== c || (f = a.getAttribute(c + "Name")) : a.removeAttribute(c);
            };
            e(b) ? g(c, b) : r(b, g);
            return f;
        }
        function m(a, b) {
            var c;
            a || (a = {});
            for (c in b) a[c] = b[c];
            return a;
        }
        function n() {
            for (var a = arguments, b = a.length, c = 0; c < b; c++) {
                var d = a[c];
                if ("undefined" !== typeof d && null !== d) return d;
            }
        }
        function o(b, c) {
            a.isMS && !a.svg && c && k(c.opacity) && (c.filter = "alpha(opacity=" + 100 * c.opacity + ")");
            m(b.style, c);
        }
        function p(a, b) {
            return 1e14 < a ? a : parseFloat(a.toPrecision(b || 14));
        }
        function q(c, e, f) {
            var g = a.getStyle || q;
            if ("width" === e) return e = Math.min(c.offsetWidth, c.scrollWidth), f = c.getBoundingClientRect && c.getBoundingClientRect().width,
                f < e && f >= e - 1 && (e = Math.floor(f)), Math.max(0, e - (g(c, "padding-left", !0) || 0) - (g(c, "padding-right", !0) || 0));
            if ("height" === e) return Math.max(0, Math.min(c.offsetHeight, c.scrollHeight) - (g(c, "padding-top", !0) || 0) - (g(c, "padding-bottom", !0) || 0));
            w.getComputedStyle || b(27, !0);
            if (c = w.getComputedStyle(c, void 0)) {
                var h = c.getPropertyValue(e);
                n(f, "opacity" !== e) && (h = d(h));
            }
            return h;
        }
        function r(a, b, c) {
            for (var d in a) Object.hasOwnProperty.call(a, d) && b.call(c || a[d], a[d], d, a);
        }
        function s(b, c, d) {
            function e(c, d) {
                var e = b.removeEventListener || a.removeEventListenerPolyfill;
                e && e.call(b, c, d, !1);
            }
            function f(a) {
                var d;
                if (b.nodeName) {
                    if (c) {
                        var f = {};
                        f[c] = !0;
                    } else f = a;
                    r(f, function (b, c) {
                        if (a[c]) for (d = a[c].length; d--;) e(c, a[c][d].fn);
                    });
                }
            }
            var g = "function" === typeof b && b.prototype || b;
            if (Object.hasOwnProperty.call(g, "hcEvents")) {
                var h = g.hcEvents;
                c ? (g = h[c] || [], d ? (h[c] = g.filter(function (a) {
                    return d !== a.fn;
                }), e(c, d)) : (f(h), h[c] = [])) : (f(h), delete g.hcEvents);
            }
        }
        function t(b, c, d, e) {
            d = d || {};
            if (v.createEvent && (b.dispatchEvent || b.fireEvent && b !== a)) {
                var f = v.createEvent("Events");
                f.initEvent(c, !0, !0);
                d = m(f, d);
                b.dispatchEvent ? b.dispatchEvent(d) : b.fireEvent(c, d);
            } else if (b.hcEvents) {
                d.target || m(d, {
                    preventDefault: function () {
                        d.defaultPrevented = !0;
                    },
                    target: b,
                    type: c
                });
                f = [];
                for (var g = b, h = !1; g.hcEvents;) Object.hasOwnProperty.call(g, "hcEvents") && g.hcEvents[c] && (f.length && (h = !0),
                    f.unshift.apply(f, g.hcEvents[c])), g = Object.getPrototypeOf(g);
                h && f.sort(function (a, b) {
                    return a.order - b.order;
                });
                f.forEach(function (a) {
                    !1 === a.fn.call(b, d) && d.preventDefault();
                });
            }
            e && !d.defaultPrevented && e.call(b, d);
        }
        var u = a.charts, v = a.doc, w = a.win;
        (b || (b = {})).messages = [];
        Math.easeInOutSine = function (a) {
            return -.5 * (Math.cos(Math.PI * a) - 1);
        };
        var x = Array.prototype.find ? function (a, b) {
            return a.find(b);
        } : function (a, b) {
            var c, d = a.length;
            for (c = 0; c < d; c++) if (b(a[c], c)) return a[c];
        };
        r({
            map: "map",
            each: "forEach",
            grep: "filter",
            reduce: "reduce",
            some: "some"
        }, function (c, d) {
            a[d] = function (a) {
                var e;
                b(32, !1, void 0, (e = {}, e["Highcharts." + d] = "use Array." + c, e));
                return Array.prototype[c].apply(a, [].slice.call(arguments, 1));
            };
        });
        var y, z = function () {
            var a = Math.random().toString(36).substring(2, 9) + "-", b = 0;
            return function () {
                return "highcharts-" + (y ? "" : a) + b++;
            };
        }();
        w.jQuery && (w.jQuery.fn.highcharts = function () {
            var b = [].slice.call(arguments);
            if (this[0]) return b[0] ? (new (a[e(b[0]) ? b.shift() : "Chart"])(this[0], b[0], b[1]),
                this) : u[l(this[0], "data-highcharts-chart")];
        });
        x = {
            addEvent: function (b, c, d, e) {
                void 0 === e && (e = {});
                var f = "function" === typeof b && b.prototype || b;
                Object.hasOwnProperty.call(f, "hcEvents") || (f.hcEvents = {});
                f = f.hcEvents;
                a.Point && b instanceof a.Point && b.series && b.series.chart && (b.series.chart.runTrackerClick = !0);
                var g = b.addEventListener || a.addEventListenerPolyfill;
                g && g.call(b, c, d, a.supportsPassiveEvents ? {
                    passive: void 0 === e.passive ? -1 !== c.indexOf("touch") : e.passive,
                    capture: !1
                } : !1);
                f[c] || (f[c] = []);
                f[c].push({
                    fn: d,
                    order: "number" === typeof e.order ? e.order : 1 / 0
                });
                f[c].sort(function (a, b) {
                    return a.order - b.order;
                });
                return function () {
                    s(b, c, d);
                };
            },
            arrayMax: function (a) {
                for (var b = a.length, c = a[0]; b--;) a[b] > c && (c = a[b]);
                return c;
            },
            arrayMin: function (a) {
                for (var b = a.length, c = a[0]; b--;) a[b] < c && (c = a[b]);
                return c;
            },
            attr: l,
            clamp: function (a, b, c) {
                return a > b ? a < c ? a : c : b;
            },
            cleanRecursively: c,
            clearTimeout: function (a) {
                k(a) && clearTimeout(a);
            },
            correctFloat: p,
            createElement: function (a, b, c, d, e) {
                a = v.createElement(a);
                b && m(a, b);
                e && o(a, {
                    padding: "0",
                    border: "none",
                    margin: "0"
                });
                c && o(a, c);
                d && d.appendChild(a);
                return a;
            },
            css: o,
            defined: k,
            destroyObjectProperties: function (a, b) {
                r(a, function (c, d) {
                    c && c !== b && c.destroy && c.destroy();
                    delete a[d];
                });
            },
            discardElement: function (a) {
                a && a.parentElement && a.parentElement.removeChild(a);
            },
            erase: function (a, b) {
                for (var c = a.length; c--;) if (a[c] === b) {
                    a.splice(c, 1);
                    break;
                }
            },
            error: b,
            extend: m,
            extendClass: function (a, b) {
                var c = function () { };
                c.prototype = new a();
                m(c.prototype, b);
                return c;
            },
            find: x,
            fireEvent: t,
            getMagnitude: function (a) {
                return Math.pow(10, Math.floor(Math.log(a) / Math.LN10));
            },
            getNestedProperty: function (a, b) {
                for (a = a.split("."); a.length && k(b);) {
                    var c = a.shift();
                    if ("undefined" === typeof c || "__proto__" === c) return;
                    b = b[c];
                    if (!k(b) || "function" === typeof b || "number" === typeof b.nodeType || b === w) return;
                }
                return b;
            },
            getStyle: q,
            inArray: function (a, c, d) {
                b(32, !1, void 0, {
                    "Highcharts.inArray": "use Array.indexOf"
                });
                return c.indexOf(a, d);
            },
            isArray: f,
            isClass: i,
            isDOMElement: h,
            isFunction: function (a) {
                return "function" === typeof a;
            },
            isNumber: j,
            isObject: g,
            isString: e,
            keys: function (a) {
                b(32, !1, void 0, {
                    "Highcharts.keys": "use Object.keys"
                });
                return Object.keys(a);
            },
            merge: function () {
                var a, b = arguments, c = {}, d = function (a, b) {
                    "object" !== typeof a && (a = {});
                    r(b, function (c, e) {
                        "__proto__" !== e && "constructor" !== e && (!g(c, !0) || i(c) || h(c) ? a[e] = b[e] : a[e] = d(a[e] || {}, c));
                    });
                    return a;
                };
                !0 === b[0] && (c = b[1], b = Array.prototype.slice.call(b, 2));
                var e = b.length;
                for (a = 0; a < e; a++) c = d(c, b[a]);
                return c;
            },
            normalizeTickInterval: function (a, b, c, d, e) {
                var f = a;
                c = n(c, 1);
                var g = a / c;
                b || (b = e ? [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] : [1, 2, 2.5, 5, 10],
                    !1 === d && (1 === c ? b = b.filter(function (a) {
                        return 0 === a % 1;
                    }) : .1 >= c && (b = [1 / c])));
                for (d = 0; d < b.length && !(f = b[d], e && f * c >= a || !e && g <= (b[d] + (b[d + 1] || b[d])) / 2); d++);
                return f = p(f * c, -Math.round(Math.log(.001) / Math.LN10));
            },
            objectEach: r,
            offset: function (a) {
                var b = v.documentElement;
                a = a.parentElement || a.parentNode ? a.getBoundingClientRect() : {
                    top: 0,
                    left: 0,
                    width: 0,
                    height: 0
                };
                return {
                    top: a.top + (w.pageYOffset || b.scrollTop) - (b.clientTop || 0),
                    left: a.left + (w.pageXOffset || b.scrollLeft) - (b.clientLeft || 0),
                    width: a.width,
                    height: a.height
                };
            },
            pad: function (a, b, c) {
                return Array((b || 2) + 1 - String(a).replace("-", "").length).join(c || "0") + a;
            },
            pick: n,
            pInt: d,
            relativeLength: function (a, b, c) {
                return /%$/.test(a) ? b * parseFloat(a) / 100 + (c || 0) : parseFloat(a);
            },
            removeEvent: s,
            splat: function (a) {
                return f(a) ? a : [a];
            },
            stableSort: function (a, b) {
                var c = a.length, d, e;
                for (e = 0; e < c; e++) a[e].safeI = e;
                a.sort(function (a, c) {
                    d = b(a, c);
                    return 0 === d ? a.safeI - c.safeI : d;
                });
                for (e = 0; e < c; e++) delete a[e].safeI;
            },
            syncTimeout: function (a, b, c) {
                if (0 < b) return setTimeout(a, b, c);
                a.call(0, c);
                return -1;
            },
            timeUnits: {
                millisecond: 1,
                second: 1e3,
                minute: 6e4,
                hour: 36e5,
                day: 864e5,
                week: 6048e5,
                month: 24192e5,
                year: 314496e5
            },
            uniqueKey: z,
            useSerialIds: function (a) {
                return y = n(a, y);
            },
            wrap: function (a, b, c) {
                var d = a[b];
                a[b] = function () {
                    var a = Array.prototype.slice.call(arguments), b = arguments, e = this;
                    e.proceed = function () {
                        d.apply(e, arguments.length ? arguments : b);
                    };
                    a.unshift(d);
                    a = c.apply(this, a);
                    e.proceed = null;
                    return a;
                };
            }
        };
        return x;
    });
    b(c, "Core/Chart/ChartDefaults.js", [], function () {
        return {
            alignThresholds: !1,
            panning: {
                enabled: !1,
                type: "x"
            },
            styledMode: !1,
            borderRadius: 0,
            colorCount: 10,
            defaultSeriesType: "line",
            ignoreHiddenSeries: !0,
            spacing: [10, 10, 15, 10],
            resetZoomButton: {
                theme: {
                    zIndex: 6
                },
                position: {
                    align: "right",
                    x: -10,
                    y: 10
                }
            },
            zoomBySingleTouch: !1,
            width: null,
            height: null,
            borderColor: "#335cad",
            backgroundColor: "#ffffff",
            plotBorderColor: "#cccccc"
        };
    });
    b(c, "Core/Color/Color.js", [c["Core/Globals.js"], c["Core/Utilities.js"]], function (a, b) {
        var c = b.isNumber, d = b.merge, e = b.pInt;
        b = function () {
            function b(c) {
                this.rgba = [0 / 0, 0 / 0, 0 / 0, 0 / 0];
                this.input = c;
                var d = a.Color;
                if (d && d !== b) return new d(c);
                if (!(this instanceof b)) return new b(c);
                this.init(c);
            }
            b.parse = function (a) {
                return a ? new b(a) : b.None;
            };
            b.prototype.init = function (a) {
                var c;
                if ("object" === typeof a && "undefined" !== typeof a.stops) this.stops = a.stops.map(function (a) {
                    return new b(a[1]);
                }); else if ("string" === typeof a) {
                    this.input = a = b.names[a.toLowerCase()] || a;
                    if ("#" === a.charAt(0)) {
                        var d = a.length;
                        var e = parseInt(a.substr(1), 16);
                        7 === d ? c = [(16711680 & e) >> 16, (65280 & e) >> 8, 255 & e, 1] : 4 === d && (c = [(3840 & e) >> 4 | (3840 & e) >> 8, (240 & e) >> 4 | 240 & e, (15 & e) << 4 | 15 & e, 1]);
                    }
                    if (!c) for (e = b.parsers.length; e-- && !c;) {
                        var f = b.parsers[e];
                        (d = f.regex.exec(a)) && (c = f.parse(d));
                    }
                }
                c && (this.rgba = c);
            };
            b.prototype.get = function (a) {
                var b = this.input, e = this.rgba;
                if ("object" === typeof b && "undefined" !== typeof this.stops) {
                    var f = d(b);
                    f.stops = [].slice.call(f.stops);
                    this.stops.forEach(function (b, c) {
                        f.stops[c] = [f.stops[c][0], b.get(a)];
                    });
                    return f;
                }
                return e && c(e[0]) ? "rgb" === a || !a && 1 === e[3] ? "rgb(" + e[0] + "," + e[1] + "," + e[2] + ")" : "a" === a ? "" + e[3] : "rgba(" + e.join(",") + ")" : b;
            };
            b.prototype.brighten = function (a) {
                var b = this.rgba;
                if (this.stops) this.stops.forEach(function (b) {
                    b.brighten(a);
                }); else if (c(a) && 0 !== a) for (var d = 0; 3 > d; d++) b[d] += e(255 * a), 0 > b[d] && (b[d] = 0),
                    255 < b[d] && (b[d] = 255);
                return this;
            };
            b.prototype.setOpacity = function (a) {
                this.rgba[3] = a;
                return this;
            };
            b.prototype.tweenTo = function (a, b) {
                var d = this.rgba, e = a.rgba;
                if (!c(d[0]) || !c(e[0])) return a.input || "none";
                a = 1 !== e[3] || 1 !== d[3];
                return (a ? "rgba(" : "rgb(") + Math.round(e[0] + (d[0] - e[0]) * (1 - b)) + "," + Math.round(e[1] + (d[1] - e[1]) * (1 - b)) + "," + Math.round(e[2] + (d[2] - e[2]) * (1 - b)) + (a ? "," + (e[3] + (d[3] - e[3]) * (1 - b)) : "") + ")";
            };
            b.names = {
                white: "#ffffff",
                black: "#000000"
            };
            b.parsers = [{
                regex: /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/,
                parse: function (a) {
                    return [e(a[1]), e(a[2]), e(a[3]), parseFloat(a[4], 10)];
                }
            }, {
                regex: /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/,
                parse: function (a) {
                    return [e(a[1]), e(a[2]), e(a[3]), 1];
                }
            }];
            b.None = new b("");
            return b;
        }();
        return b;
    });
    b(c, "Core/Color/Palettes.js", [], function () {
        return {
            colors: "#7cb5ec #434348 #90ed7d #f7a35c #8085e9 #f15c80 #e4d354 #2b908f #f45b5b #91e8e1".split(" ")
        };
    });
    b(c, "Core/Time.js", [c["Core/Globals.js"], c["Core/Utilities.js"]], function (a, b) {
        var c = a.win, d = b.defined, e = b.error, f = b.extend, g = b.isObject, h = b.merge, i = b.objectEach, j = b.pad, k = b.pick, l = b.splat, m = b.timeUnits, n = a.isSafari && c.Intl && c.Intl.DateTimeFormat.prototype.formatRange, o = a.isSafari && c.Intl && !c.Intl.DateTimeFormat.prototype.formatRange;
        b = function () {
            function b(a) {
                this.options = {};
                this.variableTimezone = this.useUTC = !1;
                this.Date = c.Date;
                this.getTimezoneOffset = this.timezoneOffsetFunction();
                this.update(a);
            }
            b.prototype.get = function (a, b) {
                if (this.variableTimezone || this.timezoneOffset) {
                    var c = b.getTime(), d = c - this.getTimezoneOffset(b);
                    b.setTime(d);
                    a = b["getUTC" + a]();
                    b.setTime(c);
                    return a;
                }
                return this.useUTC ? b["getUTC" + a]() : b["get" + a]();
            };
            b.prototype.set = function (a, b, c) {
                if (this.variableTimezone || this.timezoneOffset) {
                    if ("Milliseconds" === a || "Seconds" === a || "Minutes" === a && 0 === this.getTimezoneOffset(b) % 36e5) return b["setUTC" + a](c);
                    var d = this.getTimezoneOffset(b);
                    d = b.getTime() - d;
                    b.setTime(d);
                    b["setUTC" + a](c);
                    a = this.getTimezoneOffset(b);
                    d = b.getTime() + a;
                    return b.setTime(d);
                }
                return this.useUTC || n && "FullYear" === a ? b["setUTC" + a](c) : b["set" + a](c);
            };
            b.prototype.update = function (a) {
                var b = k(a && a.useUTC, !0);
                this.options = a = h(!0, this.options || {}, a);
                this.Date = a.Date || c.Date || Date;
                this.timezoneOffset = (this.useUTC = b) && a.timezoneOffset;
                this.getTimezoneOffset = this.timezoneOffsetFunction();
                this.variableTimezone = b && !(!a.getTimezoneOffset && !a.timezone);
            };
            b.prototype.makeTime = function (a, b, c, d, e, f) {
                if (this.useUTC) {
                    var g = this.Date.UTC.apply(0, arguments);
                    var h = this.getTimezoneOffset(g);
                    g += h;
                    var i = this.getTimezoneOffset(g);
                    h !== i ? g += i - h : h - 36e5 !== this.getTimezoneOffset(g - 36e5) || o || (g -= 36e5);
                } else g = new this.Date(a, b, k(c, 1), k(d, 0), k(e, 0), k(f, 0)).getTime();
                return g;
            };
            b.prototype.timezoneOffsetFunction = function () {
                var a = this, b = this.options, d = b.getTimezoneOffset, f = b.moment || c.moment;
                if (!this.useUTC) return function (a) {
                    return 6e4 * new Date(a.toString()).getTimezoneOffset();
                };
                if (b.timezone) {
                    if (f) return function (a) {
                        return 6e4 * -f.tz(a, b.timezone).utcOffset();
                    };
                    e(25);
                }
                return this.useUTC && d ? function (a) {
                    return 6e4 * d(a.valueOf());
                } : function () {
                    return 6e4 * (a.timezoneOffset || 0);
                };
            };
            b.prototype.dateFormat = function (b, c, e) {
                if (!d(c) || isNaN(c)) return a.defaultOptions.lang && a.defaultOptions.lang.invalidDate || "";
                b = k(b, "%Y-%m-%d %H:%M:%S");
                var g = this, h = new this.Date(c), l = this.get("Hours", h), m = this.get("Day", h), n = this.get("Date", h), o = this.get("Month", h), p = this.get("FullYear", h), q = a.defaultOptions.lang, r = q && q.weekdays, s = q && q.shortWeekdays;
                h = f({
                    a: s ? s[m] : r[m].substr(0, 3),
                    A: r[m],
                    d: j(n),
                    e: j(n, 2, " "),
                    w: m,
                    b: q.shortMonths[o],
                    B: q.months[o],
                    m: j(o + 1),
                    o: o + 1,
                    y: p.toString().substr(2, 2),
                    Y: p,
                    H: j(l),
                    k: l,
                    I: j(l % 12 || 12),
                    l: l % 12 || 12,
                    M: j(this.get("Minutes", h)),
                    p: 12 > l ? "AM" : "PM",
                    P: 12 > l ? "am" : "pm",
                    S: j(h.getSeconds()),
                    L: j(Math.floor(c % 1e3), 3)
                }, a.dateFormats);
                i(h, function (a, d) {
                    for (; -1 !== b.indexOf("%" + d);) b = b.replace("%" + d, "function" === typeof a ? a.call(g, c) : a);
                });
                return e ? b.substr(0, 1).toUpperCase() + b.substr(1) : b;
            };
            b.prototype.resolveDTLFormat = function (a) {
                return g(a, !0) ? a : (a = l(a), {
                    main: a[0],
                    from: a[1],
                    to: a[2]
                });
            };
            b.prototype.getTimeTicks = function (a, b, c, e) {
                var g = this, h = [], i = {}, j = new g.Date(b), l = a.unitRange, n = a.count || 1, o;
                e = k(e, 1);
                if (d(b)) {
                    g.set("Milliseconds", j, l >= m.second ? 0 : n * Math.floor(g.get("Milliseconds", j) / n));
                    l >= m.second && g.set("Seconds", j, l >= m.minute ? 0 : n * Math.floor(g.get("Seconds", j) / n));
                    l >= m.minute && g.set("Minutes", j, l >= m.hour ? 0 : n * Math.floor(g.get("Minutes", j) / n));
                    l >= m.hour && g.set("Hours", j, l >= m.day ? 0 : n * Math.floor(g.get("Hours", j) / n));
                    l >= m.day && g.set("Date", j, l >= m.month ? 1 : Math.max(1, n * Math.floor(g.get("Date", j) / n)));
                    if (l >= m.month) {
                        g.set("Month", j, l >= m.year ? 0 : n * Math.floor(g.get("Month", j) / n));
                        var p = g.get("FullYear", j);
                    }
                    l >= m.year && g.set("FullYear", j, p - p % n);
                    l === m.week && (p = g.get("Day", j), g.set("Date", j, g.get("Date", j) - p + e + (p < e ? -7 : 0)));
                    p = g.get("FullYear", j);
                    e = g.get("Month", j);
                    var q = g.get("Date", j), r = g.get("Hours", j);
                    b = j.getTime();
                    !g.variableTimezone && g.useUTC || !d(c) || (o = c - b > 4 * m.month || g.getTimezoneOffset(b) !== g.getTimezoneOffset(c));
                    b = j.getTime();
                    for (j = 1; b < c;) h.push(b), b = l === m.year ? g.makeTime(p + j * n, 0) : l === m.month ? g.makeTime(p, e + j * n) : !o || l !== m.day && l !== m.week ? o && l === m.hour && 1 < n ? g.makeTime(p, e, q, r + j * n) : b + l * n : g.makeTime(p, e, q + j * n * (l === m.day ? 1 : 7)),
                        j++;
                    h.push(b);
                    l <= m.hour && 1e4 > h.length && h.forEach(function (a) {
                        0 === a % 18e5 && "000000000" === g.dateFormat("%H%M%S%L", a) && (i[a] = "day");
                    });
                }
                h.info = f(a, {
                    higherRanks: i,
                    totalRange: l * n
                });
                return h;
            };
            b.prototype.getDateFormat = function (a, b, c, d) {
                var e = this.dateFormat("%m-%d %H:%M:%S.%L", b), f = {
                    millisecond: 15,
                    second: 12,
                    minute: 9,
                    hour: 6,
                    day: 3
                }, g = "millisecond";
                for (h in m) {
                    if (a === m.week && +this.dateFormat("%w", b) === c && "00:00:00.000" === e.substr(6)) {
                        var h = "week";
                        break;
                    }
                    if (m[h] > a) {
                        h = g;
                        break;
                    }
                    if (f[h] && e.substr(f[h]) !== "01-01 00:00:00.000".substr(f[h])) break;
                    "week" !== h && (g = h);
                }
                if (h) var i = this.resolveDTLFormat(d[h]).main;
                return i;
            };
            return b;
        }();
        return b;
    });
    b(c, "Core/DefaultOptions.js", [c["Core/Chart/ChartDefaults.js"], c["Core/Color/Color.js"], c["Core/Globals.js"], c["Core/Color/Palettes.js"], c["Core/Time.js"], c["Core/Utilities.js"]], function (a, b, c, d, e, f) {
        b = b.parse;
        var g = f.merge, h = {
            colors: d.colors,
            symbols: ["circle", "diamond", "square", "triangle", "triangle-down"],
            lang: {
                loading: "Loading...",
                months: "January February March April May June July August September October November December".split(" "),
                shortMonths: "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "),
                weekdays: "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),
                decimalPoint: ".",
                numericSymbols: "kMGTPE".split(""),
                resetZoom: "Reset zoom",
                resetZoomTitle: "Reset zoom level 1:1",
                thousandsSep: " "
            },
            global: {},
            time: {
                Date: void 0,
                getTimezoneOffset: void 0,
                timezone: void 0,
                timezoneOffset: 0,
                useUTC: !0
            },
            chart: a,
            title: {
                text: "Chart title",
                align: "center",
                margin: 15,
                widthAdjust: -44
            },
            subtitle: {
                text: "",
                align: "center",
                widthAdjust: -44
            },
            caption: {
                margin: 15,
                text: "",
                align: "left",
                verticalAlign: "bottom"
            },
            plotOptions: {},
            labels: {
                style: {
                    position: "absolute",
                    color: "#333333"
                }
            },
            legend: {
                enabled: !0,
                align: "center",
                alignColumns: !0,
                className: "highcharts-no-tooltip",
                layout: "horizontal",
                labelFormatter: function () {
                    return this.name;
                },
                borderColor: "#999999",
                borderRadius: 0,
                navigation: {
                    activeColor: "#003399",
                    inactiveColor: "#cccccc"
                },
                itemStyle: {
                    color: "#333333",
                    cursor: "pointer",
                    fontSize: "12px",
                    fontWeight: "bold",
                    textOverflow: "ellipsis"
                },
                itemHoverStyle: {
                    color: "#000000"
                },
                itemHiddenStyle: {
                    color: "#cccccc"
                },
                shadow: !1,
                itemCheckboxStyle: {
                    position: "absolute",
                    width: "13px",
                    height: "13px"
                },
                squareSymbol: !0,
                symbolPadding: 5,
                verticalAlign: "bottom",
                x: 0,
                y: 0,
                title: {
                    style: {
                        fontWeight: "bold"
                    }
                }
            },
            loading: {
                labelStyle: {
                    fontWeight: "bold",
                    position: "relative",
                    top: "45%"
                },
                style: {
                    position: "absolute",
                    backgroundColor: "#ffffff",
                    opacity: .5,
                    textAlign: "center"
                }
            },
            tooltip: {
                enabled: !0,
                animation: c.svg,
                borderRadius: 3,
                dateTimeLabelFormats: {
                    millisecond: "%A, %b %e, %H:%M:%S.%L",
                    second: "%A, %b %e, %H:%M:%S",
                    minute: "%A, %b %e, %H:%M",
                    hour: "%A, %b %e, %H:%M",
                    day: "%A, %b %e, %Y",
                    week: "Week from %A, %b %e, %Y",
                    month: "%B %Y",
                    year: "%Y"
                },
                footerFormat: "",
                headerShape: "callout",
                hideDelay: 500,
                padding: 8,
                shape: "callout",
                shared: !1,
                snap: c.isTouchDevice ? 25 : 10,
                headerFormat: '<span style="font-size: 10px">{point.key}</span><br/>',
                pointFormat: '<span style="color:{point.color}">●</span> {series.name}: <b>{point.y}</b><br/>',
                backgroundColor: b("#f7f7f7").setOpacity(.85).get(),
                borderWidth: 1,
                shadow: !0,
                stickOnContact: !1,
                style: {
                    color: "#333333",
                    cursor: "default",
                    fontSize: "12px",
                    whiteSpace: "nowrap"
                },
                useHTML: !1
            },
            credits: {
                enabled: !0,
                href: "https://www.highcharts.com?credits",
                position: {
                    align: "right",
                    x: -10,
                    verticalAlign: "bottom",
                    y: -5
                },
                style: {
                    cursor: "pointer",
                    color: "#999999",
                    fontSize: "9px"
                },
                text: "Highcharts.com"
            }
        };
        h.chart.styledMode = !1;
        var i = new e(g(h.global, h.time));
        a = {
            defaultOptions: h,
            defaultTime: i,
            getOptions: function () {
                return h;
            },
            setOptions: function (a) {
                g(!0, h, a);
                if (a.time || a.global) c.time ? c.time.update(g(h.global, h.time, a.global, a.time)) : c.time = i;
                return h;
            }
        };
        return a;
    });
    b(c, "Core/Animation/Fx.js", [c["Core/Color/Color.js"], c["Core/Globals.js"], c["Core/Utilities.js"]], function (a, b, c) {
        var d = a.parse, e = b.win, f = c.isNumber, g = c.objectEach;
        return function () {
            function a(a, b, c) {
                this.pos = 0 / 0;
                this.options = b;
                this.elem = a;
                this.prop = c;
            }
            a.prototype.dSetter = function () {
                var a = this.paths, b = a && a[0];
                a = a && a[1];
                var c = this.now || 0, d = [];
                if (1 !== c && b && a) if (b.length === a.length && 1 > c) for (var e = 0; e < a.length; e++) {
                    for (var g = b[e], h = a[e], i = [], j = 0; j < h.length; j++) {
                        var k = g[j], l = h[j];
                        f(k) && f(l) && ("A" !== h[0] || 4 !== j && 5 !== j) ? i[j] = k + c * (l - k) : i[j] = l;
                    }
                    d.push(i);
                } else d = a; else d = this.toD || [];
                this.elem.attr("d", d, void 0, !0);
            };
            a.prototype.update = function () {
                var a = this.elem, b = this.prop, c = this.now, d = this.options.step;
                if (this[b + "Setter"]) this[b + "Setter"](); else a.attr ? a.element && a.attr(b, c, null, !0) : a.style[b] = c + this.unit;
                d && d.call(a, c, this);
            };
            a.prototype.run = function (b, c, d) {
                var f = this, g = f.options, h = function (a) {
                    return h.stopped ? !1 : f.step(a);
                }, i = e.requestAnimationFrame || function (a) {
                    setTimeout(a, 13);
                }, j = function () {
                    for (var b = 0; b < a.timers.length; b++) a.timers[b]() || a.timers.splice(b--, 1);
                    a.timers.length && i(j);
                };
                b !== c || this.elem["forceAnimate:" + this.prop] ? (this.startTime = +new Date(),
                    this.start = b, this.end = c, this.unit = d, this.now = this.start, this.pos = 0,
                    h.elem = this.elem, h.prop = this.prop, h() && 1 === a.timers.push(h) && i(j)) : (delete g.curAnim[this.prop],
                        g.complete && 0 === Object.keys(g.curAnim).length && g.complete.call(this.elem));
            };
            a.prototype.step = function (a) {
                var b = +new Date(), c = this.options, d = this.elem, e = c.complete, f = c.duration, h = c.curAnim;
                if (d.attr && !d.element) a = !1; else if (a || b >= f + this.startTime) {
                    this.now = this.end;
                    this.pos = 1;
                    this.update();
                    var i = h[this.prop] = !0;
                    g(h, function (a) {
                        !0 !== a && (i = !1);
                    });
                    i && e && e.call(d);
                    a = !1;
                } else this.pos = c.easing((b - this.startTime) / f), this.now = this.start + (this.end - this.start) * this.pos,
                    this.update(), a = !0;
                return a;
            };
            a.prototype.initPath = function (a, b, c) {
                function d(a, b) {
                    for (; a.length < m;) {
                        var c = a[0], d = b[m - a.length];
                        d && "M" === c[0] && (a[0] = "C" === d[0] ? ["C", c[1], c[2], c[1], c[2], c[1], c[2]] : ["L", c[1], c[2]]);
                        a.unshift(c);
                        i && (c = a.pop(), a.push(a[a.length - 1], c));
                    }
                }
                function e(a, b) {
                    for (; a.length < m;) if (b = a[Math.floor(a.length / j) - 1].slice(), "C" === b[0] && (b[1] = b[5],
                        b[2] = b[6]), i) {
                        var c = a[Math.floor(a.length / j)].slice();
                        a.splice(a.length / 2, 0, b, c);
                    } else a.push(b);
                }
                var g = a.startX, h = a.endX;
                c = c.slice();
                var i = a.isArea, j = i ? 2 : 1;
                b = b && b.slice();
                if (!b) return [c, c];
                if (g && h && h.length) {
                    for (a = 0; a < g.length; a++) if (g[a] === h[0]) {
                        var k = a;
                        break;
                    } else if (g[0] === h[h.length - g.length + a]) {
                        k = a;
                        var l = !0;
                        break;
                    } else if (g[g.length - 1] === h[h.length - g.length + a]) {
                        k = g.length - a;
                        break;
                    }
                    "undefined" === typeof k && (b = []);
                }
                if (b.length && f(k)) {
                    var m = c.length + k * j;
                    l ? (d(b, c), e(c, b)) : (d(c, b), e(b, c));
                }
                return [b, c];
            };
            a.prototype.fillSetter = function () {
                a.prototype.strokeSetter.apply(this, arguments);
            };
            a.prototype.strokeSetter = function () {
                this.elem.attr(this.prop, d(this.start).tweenTo(d(this.end), this.pos), void 0, !0);
            };
            a.timers = [];
            return a;
        }();
    });
    b(c, "Core/Animation/AnimationUtilities.js", [c["Core/Animation/Fx.js"], c["Core/Utilities.js"]], function (a, b) {
        function c(a) {
            return i(a) ? j({
                duration: 500,
                defer: 0
            }, a) : {
                duration: a ? 500 : 0,
                defer: 0
            };
        }
        function d(b, c) {
            for (var d = a.timers.length; d--;) a.timers[d].elem !== b || c && c !== a.timers[d].prop || (a.timers[d].stopped = !0);
        }
        var e = b.defined, f = b.getStyle, g = b.isArray, h = b.isNumber, i = b.isObject, j = b.merge, k = b.objectEach, l = b.pick;
        return {
            animate: function (b, c, e) {
                var l, m = "", n, o;
                if (!i(e)) {
                    var p = arguments;
                    e = {
                        duration: p[2],
                        easing: p[3],
                        complete: p[4]
                    };
                }
                h(e.duration) || (e.duration = 400);
                e.easing = "function" === typeof e.easing ? e.easing : Math[e.easing] || Math.easeInOutSine;
                e.curAnim = j(c);
                k(c, function (h, i) {
                    d(b, i);
                    o = new a(b, e, i);
                    n = void 0;
                    "d" === i && g(c.d) ? (o.paths = o.initPath(b, b.pathArray, c.d), o.toD = c.d, l = 0,
                        n = 1) : b.attr ? l = b.attr(i) : (l = parseFloat(f(b, i)) || 0, "opacity" !== i && (m = "px"));
                    n || (n = h);
                    "string" === typeof n && n.match("px") && (n = n.replace(/px/g, ""));
                    o.run(l, n, m);
                });
            },
            animObject: c,
            getDeferredAnimation: function (a, b, d) {
                var f = c(b), g = 0, h = 0;
                (d ? [d] : a.series).forEach(function (a) {
                    a = c(a.options.animation);
                    g = b && e(b.defer) ? f.defer : Math.max(g, a.duration + a.defer);
                    h = Math.min(f.duration, a.duration);
                });
                a.renderer.forExport && (g = 0);
                return {
                    defer: Math.max(0, g - h),
                    duration: Math.min(g, h)
                };
            },
            setAnimation: function (a, b) {
                b.renderer.globalAnimation = l(a, b.options.chart.animation, !0);
            },
            stop: d
        };
    });
    b(c, "Core/Renderer/HTML/AST.js", [c["Core/Globals.js"], c["Core/Utilities.js"]], function (a, b) {
        var c = a.SVG_NS, d = b.attr, e = b.createElement, f = b.css, g = b.error, h = b.isFunction, i = b.isString, j = b.objectEach, k = b.splat, l = (b = a.win.trustedTypes) && h(b.createPolicy) && b.createPolicy("highcharts", {
            createHTML: function (a) {
                return a;
            }
        }), m = l ? l.createHTML("") : "";
        try {
            var n = !!new DOMParser().parseFromString(m, "text/html");
        } catch (o) {
            n = !1;
        }
        h = function () {
            function b(a) {
                this.nodes = "string" === typeof a ? this.parseMarkup(a) : a;
            }
            b.filterUserAttributes = function (a) {
                j(a, function (c, d) {
                    var e = !0;
                    -1 === b.allowedAttributes.indexOf(d) && (e = !1);
                    -1 !== ["background", "dynsrc", "href", "lowsrc", "src"].indexOf(d) && (e = i(c) && b.allowedReferences.some(function (a) {
                        return 0 === c.indexOf(a);
                    }));
                    e || (g("Highcharts warning: Invalid attribute '" + d + "' in config"), delete a[d]);
                });
                return a;
            };
            b.parseStyle = function (a) {
                return a.split(";").reduce(function (a, b) {
                    b = b.split(":").map(function (a) {
                        return a.trim();
                    });
                    var c = b[0].replace(/-([a-z])/g, function (a) {
                        return a[1].toUpperCase();
                    });
                    b[1] && (a[c] = b[1]);
                    return a;
                }, {});
            };
            b.setElementHTML = function (a, c) {
                a.innerHTML = b.emptyHTML;
                c && new b(c).addToDOM(a);
            };
            b.prototype.addToDOM = function (e) {
                function h(e, i) {
                    var l;
                    k(e).forEach(function (e) {
                        var k = e.tagName, m = e.textContent ? a.doc.createTextNode(e.textContent) : void 0, n = b.bypassHTMLFiltering;
                        if (k) if ("#text" === k) var o = m; else if (-1 !== b.allowedTags.indexOf(k) || n) {
                            k = a.doc.createElementNS("svg" === k ? c : i.namespaceURI || c, k);
                            var p = e.attributes || {};
                            j(e, function (a, b) {
                                "tagName" !== b && "attributes" !== b && "children" !== b && "style" !== b && "textContent" !== b && (p[b] = a);
                            });
                            d(k, n ? p : b.filterUserAttributes(p));
                            e.style && f(k, e.style);
                            m && k.appendChild(m);
                            h(e.children || [], k);
                            o = k;
                        } else g("Highcharts warning: Invalid tagName " + k + " in config");
                        o && i.appendChild(o);
                        l = o;
                    });
                    return l;
                }
                return h(this.nodes, e);
            };
            b.prototype.parseMarkup = function (a) {
                var c = [];
                a = a.trim().replace(/ style="/g, ' data-style="');
                if (n) a = new DOMParser().parseFromString(l ? l.createHTML(a) : a, "text/html"); else {
                    var d = e("div");
                    d.innerHTML = a;
                    a = {
                        body: d
                    };
                }
                var f = function (a, c) {
                    var d = a.nodeName.toLowerCase(), e = {
                        tagName: d
                    };
                    "#text" === d && (e.textContent = a.textContent || "");
                    if (d = a.attributes) {
                        var g = {};
                        [].forEach.call(d, function (a) {
                            "data-style" === a.name ? e.style = b.parseStyle(a.value) : g[a.name] = a.value;
                        });
                        e.attributes = g;
                    }
                    if (a.childNodes.length) {
                        var h = [];
                        [].forEach.call(a.childNodes, function (a) {
                            f(a, h);
                        });
                        h.length && (e.children = h);
                    }
                    c.push(e);
                };
                [].forEach.call(a.body.childNodes, function (a) {
                    return f(a, c);
                });
                return c;
            };
            b.allowedAttributes = "aria-controls aria-describedby aria-expanded aria-haspopup aria-hidden aria-label aria-labelledby aria-live aria-pressed aria-readonly aria-roledescription aria-selected class clip-path color colspan cx cy d dx dy disabled fill height href id in markerHeight markerWidth offset opacity orient padding paddingLeft paddingRight patternUnits r refX refY role scope slope src startOffset stdDeviation stroke stroke-linecap stroke-width style tableValues result rowspan summary target tabindex text-align textAnchor textLength title type valign width x x1 x2 y y1 y2 zIndex".split(" ");
            b.allowedReferences = "https:// http:// mailto: / ../ ./ #".split(" ");
            b.allowedTags = "a abbr b br button caption circle clipPath code dd defs div dl dt em feComponentTransfer feFuncA feFuncB feFuncG feFuncR feGaussianBlur feOffset feMerge feMergeNode filter h1 h2 h3 h4 h5 h6 hr i img li linearGradient marker ol p path pattern pre rect small span stop strong style sub sup svg table text thead tbody tspan td th tr u ul #text".split(" ");
            b.emptyHTML = m;
            b.bypassHTMLFiltering = !1;
            return b;
        }();
        return h;
    });
    b(c, "Core/FormatUtilities.js", [c["Core/DefaultOptions.js"], c["Core/Utilities.js"]], function (a, b) {
        function c(a, b, c, e) {
            a = +a || 0;
            b = +b;
            var f = d.lang, j = (a.toString().split(".")[1] || "").split("e")[0].length, k = a.toString().split("e"), l = b;
            if (-1 === b) b = Math.min(j, 20); else if (!g(b)) b = 2; else if (b && k[1] && 0 > k[1]) {
                var m = b + +k[1];
                0 <= m ? (k[0] = (+k[0]).toExponential(m).split("e")[0], b = m) : (k[0] = k[0].split(".")[0] || 0,
                    a = 20 > b ? (k[0] * Math.pow(10, k[1])).toFixed(b) : 0, k[1] = 0);
            }
            m = (Math.abs(k[1] ? k[0] : a) + Math.pow(10, -Math.max(b, j) - 1)).toFixed(b);
            j = String(i(m));
            var n = 3 < j.length ? j.length % 3 : 0;
            c = h(c, f.decimalPoint);
            e = h(e, f.thousandsSep);
            a = (0 > a ? "-" : "") + (n ? j.substr(0, n) + e : "");
            a = 0 > +k[1] && !l ? "0" : a + j.substr(n).replace(/(\d{3})(?=\d)/g, "$1" + e);
            b && (a += c + m.slice(-b));
            k[1] && 0 !== +a && (a += "e" + k[1]);
            return a;
        }
        var d = a.defaultOptions, e = a.defaultTime, f = b.getNestedProperty, g = b.isNumber, h = b.pick, i = b.pInt;
        return {
            dateFormat: function (a, b, c) {
                return e.dateFormat(a, b, c);
            },
            format: function (a, b, g) {
                var h = "{", i = !1, j = /f$/, k = /\.([0-9])/, l = d.lang, m = g && g.time || e;
                g = g && g.numberFormatter || c;
                for (var n = []; a;) {
                    var o = a.indexOf(h);
                    if (-1 === o) break;
                    var p = a.slice(0, o);
                    if (i) {
                        p = p.split(":");
                        h = f(p.shift() || "", b);
                        if (p.length && "number" === typeof h) if (p = p.join(":"), j.test(p)) {
                            var q = parseInt((p.match(k) || ["", "-1"])[1], 10);
                            null !== h && (h = g(h, q, l.decimalPoint, -1 < p.indexOf(",") ? l.thousandsSep : ""));
                        } else h = m.dateFormat(p, h);
                        n.push(h);
                    } else n.push(p);
                    a = a.slice(o + 1);
                    h = (i = !i) ? "}" : "{";
                }
                n.push(a);
                return n.join("");
            },
            numberFormat: c
        };
    });
    b(c, "Core/Renderer/RendererUtilities.js", [c["Core/Utilities.js"]], function (a) {
        var b = a.clamp, c = a.pick, d = a.stableSort, e;
        !function (a) {
            function e(a, f, g) {
                var h = a, i = h.reducedLen || f, j = function (a, b) {
                    return (b.rank || 0) - (a.rank || 0);
                }, k = function (a, b) {
                    return a.target - b.target;
                }, l, m = !0, n = [], o = 0;
                for (l = a.length; l--;) o += a[l].size;
                if (o > i) {
                    d(a, j);
                    for (o = l = 0; o <= i;) o += a[l].size, l++;
                    n = a.splice(l - 1, a.length);
                }
                d(a, k);
                for (a = a.map(function (a) {
                    return {
                        size: a.size,
                        targets: [a.target],
                        align: c(a.align, .5)
                    };
                }); m;) {
                    for (l = a.length; l--;) i = a[l], j = (Math.min.apply(0, i.targets) + Math.max.apply(0, i.targets)) / 2,
                        i.pos = b(j - i.size * i.align, 0, f - i.size);
                    l = a.length;
                    for (m = !1; l--;) 0 < l && a[l - 1].pos + a[l - 1].size > a[l].pos && (a[l - 1].size += a[l].size,
                        a[l - 1].targets = a[l - 1].targets.concat(a[l].targets), a[l - 1].align = .5, a[l - 1].pos + a[l - 1].size > f && (a[l - 1].pos = f - a[l - 1].size),
                        a.splice(l, 1), m = !0);
                }
                h.push.apply(h, n);
                l = 0;
                a.some(function (a) {
                    var b = 0;
                    return (a.targets || []).some(function () {
                        h[l].pos = a.pos + b;
                        if ("undefined" !== typeof g && Math.abs(h[l].pos - h[l].target) > g) return h.slice(0, l + 1).forEach(function (a) {
                            return delete a.pos;
                        }), h.reducedLen = (h.reducedLen || f) - .1 * f, h.reducedLen > .1 * f && e(h, f, g),
                            !0;
                        b += h[l].size;
                        l++;
                        return !1;
                    });
                });
                d(h, k);
                return h;
            }
            a.distribute = e;
        }(e || (e = {}));
        return e;
    });
    b(c, "Core/Renderer/SVG/SVGElement.js", [c["Core/Animation/AnimationUtilities.js"], c["Core/Renderer/HTML/AST.js"], c["Core/Color/Color.js"], c["Core/Globals.js"], c["Core/Utilities.js"]], function (a, b, c, d, e) {
        var f = a.animate, g = a.animObject, h = a.stop, i = d.deg2rad, j = d.doc, k = d.noop, l = d.svg, m = d.SVG_NS, n = d.win, o = e.addEvent, p = e.attr, q = e.createElement, r = e.css, s = e.defined, t = e.erase, u = e.extend, v = e.fireEvent, w = e.isArray, x = e.isFunction, y = e.isNumber, z = e.isString, A = e.merge, B = e.objectEach, C = e.pick, D = e.pInt, E = e.syncTimeout, F = e.uniqueKey;
        a = function () {
            function a() {
                this.element = void 0;
                this.onEvents = {};
                this.opacity = 1;
                this.renderer = void 0;
                this.SVG_NS = m;
                this.symbolCustomAttribs = "x y width height r start end innerR anchorX anchorY rounded".split(" ");
            }
            a.prototype._defaultGetter = function (a) {
                a = C(this[a + "Value"], this[a], this.element ? this.element.getAttribute(a) : null, 0);
                /^[\-0-9\.]+$/.test(a) && (a = parseFloat(a));
                return a;
            };
            a.prototype._defaultSetter = function (a, b, c) {
                c.setAttribute(b, a);
            };
            a.prototype.add = function (a) {
                var b = this.renderer, c = this.element;
                a && (this.parentGroup = a);
                this.parentInverted = a && a.inverted;
                "undefined" !== typeof this.textStr && "text" === this.element.nodeName && b.buildText(this);
                this.added = !0;
                if (!a || a.handleZ || this.zIndex) var d = this.zIndexSetter();
                d || (a ? a.element : b.box).appendChild(c);
                if (this.onAdd) this.onAdd();
                return this;
            };
            a.prototype.addClass = function (a, b) {
                var c = b ? "" : this.attr("class") || "";
                a = (a || "").split(/ /g).reduce(function (a, b) {
                    -1 === c.indexOf(b) && a.push(b);
                    return a;
                }, c ? [c] : []).join(" ");
                a !== c && this.attr("class", a);
                return this;
            };
            a.prototype.afterSetters = function () {
                this.doTransform && (this.updateTransform(), this.doTransform = !1);
            };
            a.prototype.align = function (a, b, c) {
                var d = {}, e = this.renderer, f = e.alignedObjects, g, h, i;
                if (a) {
                    if (this.alignOptions = a, this.alignByTranslate = b, !c || z(c)) this.alignTo = g = c || "renderer",
                        t(f, this), f.push(this), c = void 0;
                } else a = this.alignOptions, b = this.alignByTranslate, g = this.alignTo;
                c = C(c, e[g], "scrollablePlotBox" === g ? e.plotBox : void 0, e);
                g = a.align;
                var j = a.verticalAlign;
                e = (c.x || 0) + (a.x || 0);
                f = (c.y || 0) + (a.y || 0);
                "right" === g ? h = 1 : "center" === g && (h = 2);
                h && (e += (c.width - (a.width || 0)) / h);
                d[b ? "translateX" : "x"] = Math.round(e);
                "bottom" === j ? i = 1 : "middle" === j && (i = 2);
                i && (f += (c.height - (a.height || 0)) / i);
                d[b ? "translateY" : "y"] = Math.round(f);
                this[this.placed ? "animate" : "attr"](d);
                this.placed = !0;
                this.alignAttr = d;
                return this;
            };
            a.prototype.alignSetter = function (a) {
                var b = {
                    left: "start",
                    center: "middle",
                    right: "end"
                };
                b[a] && (this.alignValue = a, this.element.setAttribute("text-anchor", b[a]));
            };
            a.prototype.animate = function (a, b, c) {
                var d = this, e = g(C(b, this.renderer.globalAnimation, !0));
                b = e.defer;
                C(j.hidden, j.msHidden, j.webkitHidden, !1) && (e.duration = 0);
                0 !== e.duration ? (c && (e.complete = c), E(function () {
                    d.element && f(d, a, e);
                }, b)) : (this.attr(a, void 0, c || e.complete), B(a, function (a, b) {
                    e.step && e.step.call(this, a, {
                        prop: b,
                        pos: 1,
                        elem: this
                    });
                }, this));
                return this;
            };
            a.prototype.applyTextOutline = function (a) {
                var b = this.element;
                -1 !== a.indexOf("contrast") && (a = a.replace(/contrast/g, this.renderer.getContrast(b.style.fill)));
                var c = a.split(" ");
                a = c[c.length - 1];
                if ((c = c[0]) && "none" !== c && d.svg) {
                    this.fakeTS = !0;
                    this.ySetter = this.xSetter;
                    c = c.replace(/(^[\d\.]+)(.*?)$/g, function (a, b, c) {
                        return 2 * Number(b) + c;
                    });
                    this.removeTextOutline();
                    var e = j.createElementNS(m, "tspan");
                    p(e, {
                        "class": "highcharts-text-outline",
                        fill: a,
                        stroke: a,
                        "stroke-width": c,
                        "stroke-linejoin": "round"
                    });
                    [].forEach.call(b.childNodes, function (a) {
                        var b = a.cloneNode(!0);
                        b.removeAttribute && ["fill", "stroke", "stroke-width", "stroke"].forEach(function (a) {
                            return b.removeAttribute(a);
                        });
                        e.appendChild(b);
                    });
                    var f = j.createElementNS(m, "tspan");
                    f.textContent = "​";
                    ["x", "y"].forEach(function (a) {
                        var c = b.getAttribute(a);
                        c && f.setAttribute(a, c);
                    });
                    e.appendChild(f);
                    b.insertBefore(e, b.firstChild);
                }
            };
            a.prototype.attr = function (a, b, c, d) {
                var e = this.element, f = this.symbolCustomAttribs, g, i = this, j, k;
                if ("string" === typeof a && "undefined" !== typeof b) {
                    var l = a;
                    a = {};
                    a[l] = b;
                }
                "string" === typeof a ? i = (this[a + "Getter"] || this._defaultGetter).call(this, a, e) : (B(a, function (b, c) {
                    j = !1;
                    d || h(this, c);
                    this.symbolName && -1 !== f.indexOf(c) && (g || (this.symbolAttr(a), g = !0), j = !0);
                    !this.rotation || "x" !== c && "y" !== c || (this.doTransform = !0);
                    j || (k = this[c + "Setter"] || this._defaultSetter, k.call(this, b, c, e), !this.styledMode && this.shadows && /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(c) && this.updateShadows(c, b, k));
                }, this), this.afterSetters());
                c && c.call(this);
                return i;
            };
            a.prototype.clip = function (a) {
                return this.attr("clip-path", a ? "url(" + this.renderer.url + "#" + a.id + ")" : "none");
            };
            a.prototype.crisp = function (a, b) {
                b = b || a.strokeWidth || 0;
                var c = Math.round(b) % 2 / 2;
                a.x = Math.floor(a.x || this.x || 0) + c;
                a.y = Math.floor(a.y || this.y || 0) + c;
                a.width = Math.floor((a.width || this.width || 0) - 2 * c);
                a.height = Math.floor((a.height || this.height || 0) - 2 * c);
                s(a.strokeWidth) && (a.strokeWidth = b);
                return a;
            };
            a.prototype.complexColor = function (a, b, d) {
                var e = this.renderer, f, g, h, i, j, k, l, m, n, o, p = [], q;
                v(this.renderer, "complexColor", {
                    args: arguments
                }, function () {
                    a.radialGradient ? g = "radialGradient" : a.linearGradient && (g = "linearGradient");
                    if (g) {
                        h = a[g];
                        j = e.gradients;
                        k = a.stops;
                        n = d.radialReference;
                        w(h) && (a[g] = h = {
                            x1: h[0],
                            y1: h[1],
                            x2: h[2],
                            y2: h[3],
                            gradientUnits: "userSpaceOnUse"
                        });
                        "radialGradient" === g && n && !s(h.gradientUnits) && (i = h, h = A(h, e.getRadialAttr(n, i), {
                            gradientUnits: "userSpaceOnUse"
                        }));
                        B(h, function (a, b) {
                            "id" !== b && p.push(b, a);
                        });
                        B(k, function (a) {
                            p.push(a);
                        });
                        p = p.join(",");
                        if (j[p]) o = j[p].attr("id"); else {
                            h.id = o = F();
                            var r = j[p] = e.createElement(g).attr(h).add(e.defs);
                            r.radAttr = i;
                            r.stops = [];
                            k.forEach(function (a) {
                                0 === a[1].indexOf("rgba") ? (f = c.parse(a[1]), l = f.get("rgb"), m = f.get("a")) : (l = a[1],
                                    m = 1);
                                a = e.createElement("stop").attr({
                                    offset: a[0],
                                    "stop-color": l,
                                    "stop-opacity": m
                                }).add(r);
                                r.stops.push(a);
                            });
                        }
                        q = "url(" + e.url + "#" + o + ")";
                        d.setAttribute(b, q);
                        d.gradient = p;
                        a.toString = function () {
                            return q;
                        };
                    }
                });
            };
            a.prototype.css = function (a) {
                var b = this.styles, c = {}, d = this.element, e = !b;
                a.color && (a.fill = a.color);
                b && B(a, function (a, d) {
                    b && b[d] !== a && (c[d] = a, e = !0);
                });
                if (e) {
                    b && (a = u(b, c));
                    if (null === a.width || "auto" === a.width) delete this.textWidth; else if ("text" === d.nodeName.toLowerCase() && a.width) var f = this.textWidth = D(a.width);
                    this.styles = a;
                    f && !l && this.renderer.forExport && delete a.width;
                    var g = A(a);
                    d.namespaceURI === this.SVG_NS && ["textOutline", "textOverflow", "width"].forEach(function (a) {
                        return g && delete g[a];
                    });
                    r(d, g);
                    this.added && ("text" === this.element.nodeName && this.renderer.buildText(this),
                        a.textOutline && this.applyTextOutline(a.textOutline));
                }
                return this;
            };
            a.prototype.dashstyleSetter = function (a) {
                var b = this["stroke-width"];
                "inherit" === b && (b = 1);
                if (a = a && a.toLowerCase()) {
                    var c = a.replace("shortdashdotdot", "3,1,1,1,1,1,").replace("shortdashdot", "3,1,1,1").replace("shortdot", "1,1,").replace("shortdash", "3,1,").replace("longdash", "8,3,").replace(/dot/g, "1,3,").replace("dash", "4,3,").replace(/,$/, "").split(",");
                    for (a = c.length; a--;) c[a] = "" + D(c[a]) * C(b, 0 / 0);
                    a = c.join(",").replace(/NaN/g, "none");
                    this.element.setAttribute("stroke-dasharray", a);
                }
            };
            a.prototype.destroy = function () {
                var a = this, b = a.element || {}, c = a.renderer, d = b.ownerSVGElement, e = c.isSVG && "SPAN" === b.nodeName && a.parentGroup || void 0;
                b.onclick = b.onmouseout = b.onmouseover = b.onmousemove = b.point = null;
                h(a);
                if (a.clipPath && d) {
                    var f = a.clipPath;
                    [].forEach.call(d.querySelectorAll("[clip-path],[CLIP-PATH]"), function (a) {
                        -1 < a.getAttribute("clip-path").indexOf(f.element.id) && a.removeAttribute("clip-path");
                    });
                    a.clipPath = f.destroy();
                }
                if (a.stops) {
                    for (d = 0; d < a.stops.length; d++) a.stops[d].destroy();
                    a.stops.length = 0;
                    a.stops = void 0;
                }
                a.safeRemoveChild(b);
                for (c.styledMode || a.destroyShadows(); e && e.div && 0 === e.div.childNodes.length;) b = e.parentGroup,
                    a.safeRemoveChild(e.div), delete e.div, e = b;
                a.alignTo && t(c.alignedObjects, a);
                B(a, function (b, c) {
                    a[c] && a[c].parentGroup === a && a[c].destroy && a[c].destroy();
                    delete a[c];
                });
            };
            a.prototype.destroyShadows = function () {
                (this.shadows || []).forEach(function (a) {
                    this.safeRemoveChild(a);
                }, this);
                this.shadows = void 0;
            };
            a.prototype.destroyTextPath = function (a, b) {
                var c = a.getElementsByTagName("text")[0];
                if (c) {
                    if (c.removeAttribute("dx"), c.removeAttribute("dy"), b.element.setAttribute("id", ""),
                        this.textPathWrapper && c.getElementsByTagName("textPath").length) {
                        for (a = this.textPathWrapper.element.childNodes; a.length;) c.appendChild(a[0]);
                        c.removeChild(this.textPathWrapper.element);
                    }
                } else if (a.getAttribute("dx") || a.getAttribute("dy")) a.removeAttribute("dx"),
                    a.removeAttribute("dy");
                this.textPathWrapper && (this.textPathWrapper = this.textPathWrapper.destroy());
            };
            a.prototype.dSetter = function (a, b, c) {
                w(a) && ("string" === typeof a[0] && (a = this.renderer.pathToSegments(a)), this.pathArray = a,
                    a = a.reduce(function (a, b, c) {
                        return b && b.join ? (c ? a + " " : "") + b.join(" ") : (b || "").toString();
                    }, ""));
                /(NaN| {2}|^$)/.test(a) && (a = "M 0 0");
                this[b] !== a && (c.setAttribute(b, a), this[b] = a);
            };
            a.prototype.fadeOut = function (a) {
                var b = this;
                b.animate({
                    opacity: 0
                }, {
                    duration: C(a, 150),
                    complete: function () {
                        b.attr({
                            y: -9999
                        }).hide();
                    }
                });
            };
            a.prototype.fillSetter = function (a, b, c) {
                "string" === typeof a ? c.setAttribute(b, a) : a && this.complexColor(a, b, c);
            };
            a.prototype.getBBox = function (b, c) {
                var d = this.renderer, e = this.element, f = this.styles, g = this.textStr, h = d.cache, j = d.cacheKeys, k = e.namespaceURI === this.SVG_NS;
                c = C(c, this.rotation, 0);
                var l = d.styledMode ? e && a.prototype.getStyle.call(e, "font-size") : f && f.fontSize, m;
                if (s(g)) {
                    var n = g.toString();
                    -1 === n.indexOf("<") && (n = n.replace(/[0-9]/g, "0"));
                    n += ["", c, l, this.textWidth, f && f.textOverflow, f && f.fontWeight].join();
                }
                n && !b && (m = h[n]);
                if (!m) {
                    if (k || d.forExport) {
                        try {
                            var o = this.fakeTS && function (a) {
                                var b = e.querySelector(".highcharts-text-outline");
                                b && r(b, {
                                    display: a
                                });
                            };
                            x(o) && o("none");
                            m = e.getBBox ? u({}, e.getBBox()) : {
                                width: e.offsetWidth,
                                height: e.offsetHeight
                            };
                            x(o) && o("");
                        } catch (p) { }
                        if (!m || 0 > m.width) m = {
                            width: 0,
                            height: 0
                        };
                    } else m = this.htmlGetBBox();
                    d.isSVG && (b = m.width, d = m.height, k && (m.height = d = {
                        "11px,17": 14,
                        "13px,20": 16
                    }[(l || "") + "," + Math.round(d)] || d), c && (k = c * i, m.width = Math.abs(d * Math.sin(k)) + Math.abs(b * Math.cos(k)),
                        m.height = Math.abs(d * Math.cos(k)) + Math.abs(b * Math.sin(k))));
                    if (n && ("" === g || 0 < m.height)) {
                        for (; 250 < j.length;) delete h[j.shift()];
                        h[n] || j.push(n);
                        h[n] = m;
                    }
                }
                return m;
            };
            a.prototype.getStyle = function (a) {
                return n.getComputedStyle(this.element || this, "").getPropertyValue(a);
            };
            a.prototype.hasClass = function (a) {
                return -1 !== ("" + this.attr("class")).split(" ").indexOf(a);
            };
            a.prototype.hide = function (a) {
                a ? this.attr({
                    y: -9999
                }) : this.attr({
                    visibility: "hidden"
                });
                return this;
            };
            a.prototype.htmlGetBBox = function () {
                return {
                    height: 0,
                    width: 0,
                    x: 0,
                    y: 0
                };
            };
            a.prototype.init = function (a, b) {
                this.element = "span" === b ? q(b) : j.createElementNS(this.SVG_NS, b);
                this.renderer = a;
                v(this, "afterInit");
            };
            a.prototype.invert = function (a) {
                this.inverted = a;
                this.updateTransform();
                return this;
            };
            a.prototype.on = function (a, b) {
                var c = this.onEvents;
                if (c[a]) c[a]();
                c[a] = o(this.element, a, b);
                return this;
            };
            a.prototype.opacitySetter = function (a, b, c) {
                this.opacity = a = Number(Number(a).toFixed(3));
                c.setAttribute(b, a);
            };
            a.prototype.removeClass = function (a) {
                return this.attr("class", ("" + this.attr("class")).replace(z(a) ? new RegExp("(^| )" + a + "( |$)") : a, " ").replace(/ +/g, " ").trim());
            };
            a.prototype.removeTextOutline = function () {
                var a = this.element.querySelector("tspan.highcharts-text-outline");
                a && this.safeRemoveChild(a);
            };
            a.prototype.safeRemoveChild = function (a) {
                var b = a.parentNode;
                b && b.removeChild(a);
            };
            a.prototype.setRadialReference = function (a) {
                var b = this.element.gradient && this.renderer.gradients[this.element.gradient];
                this.element.radialReference = a;
                b && b.radAttr && b.animate(this.renderer.getRadialAttr(a, b.radAttr));
                return this;
            };
            a.prototype.setTextPath = function (a, c) {
                var d = this.element, e = this.text ? this.text.element : d, f = {
                    textAnchor: "text-anchor"
                }, g = !1, h = this.textPathWrapper, i = !h;
                c = A(!0, {
                    enabled: !0,
                    attributes: {
                        dy: -5,
                        startOffset: "50%",
                        textAnchor: "middle"
                    }
                }, c);
                var j = b.filterUserAttributes(c.attributes);
                if (a && c && c.enabled) {
                    h && null === h.element.parentNode ? (i = !0, h = h.destroy()) : h && this.removeTextOutline.call(h.parentGroup);
                    this.options && this.options.padding && (j.dx = -this.options.padding);
                    h || (this.textPathWrapper = h = this.renderer.createElement("textPath"), g = !0);
                    var l = h.element;
                    (c = a.element.getAttribute("id")) || a.element.setAttribute("id", c = F());
                    if (i) for (e.setAttribute("y", 0), y(j.dx) && e.setAttribute("x", -j.dx), a = [].slice.call(e.childNodes),
                        i = 0; i < a.length; i++) {
                        var m = a[i];
                        m.nodeType !== n.Node.TEXT_NODE && "tspan" !== m.nodeName || l.appendChild(m);
                    }
                    g && h && h.add({
                        element: e
                    });
                    l.setAttributeNS("http://www.w3.org/1999/xlink", "href", this.renderer.url + "#" + c);
                    s(j.dy) && (l.parentNode.setAttribute("dy", j.dy), delete j.dy);
                    s(j.dx) && (l.parentNode.setAttribute("dx", j.dx), delete j.dx);
                    B(j, function (a, b) {
                        l.setAttribute(f[b] || b, a);
                    });
                    d.removeAttribute("transform");
                    this.removeTextOutline.call(h);
                    this.text && !this.renderer.styledMode && this.attr({
                        fill: "none",
                        "stroke-width": 0
                    });
                    this.applyTextOutline = this.updateTransform = k;
                } else h && (delete this.updateTransform, delete this.applyTextOutline, this.destroyTextPath(d, a),
                    this.updateTransform(), this.options && this.options.rotation && this.applyTextOutline(this.options.style.textOutline));
                return this;
            };
            a.prototype.shadow = function (a, b, c) {
                var d = [], e = this.element, f = this.oldShadowOptions, g = {
                    color: "#000000",
                    offsetX: this.parentInverted ? -1 : 1,
                    offsetY: this.parentInverted ? -1 : 1,
                    opacity: .15,
                    width: 3
                }, h = !1, i;
                !0 === a ? i = g : "object" === typeof a && (i = u(g, a));
                i && (i && f && B(i, function (a, b) {
                    a !== f[b] && (h = !0);
                }), h && this.destroyShadows(), this.oldShadowOptions = i);
                if (!i) this.destroyShadows(); else if (!this.shadows) {
                    var j = i.opacity / i.width;
                    var k = this.parentInverted ? "translate(" + i.offsetY + ", " + i.offsetX + ")" : "translate(" + i.offsetX + ", " + i.offsetY + ")";
                    for (g = 1; g <= i.width; g++) {
                        var l = e.cloneNode(!1);
                        var m = 2 * i.width + 1 - 2 * g;
                        p(l, {
                            stroke: a.color || "#000000",
                            "stroke-opacity": j * g,
                            "stroke-width": m,
                            transform: k,
                            fill: "none"
                        });
                        l.setAttribute("class", (l.getAttribute("class") || "") + " highcharts-shadow");
                        c && (p(l, "height", Math.max(p(l, "height") - m, 0)), l.cutHeight = m);
                        b ? b.element.appendChild(l) : e.parentNode && e.parentNode.insertBefore(l, e);
                        d.push(l);
                    }
                    this.shadows = d;
                }
                return this;
            };
            a.prototype.show = function (a) {
                return this.attr({
                    visibility: a ? "inherit" : "visible"
                });
            };
            a.prototype.strokeSetter = function (b, c, d) {
                this[c] = b;
                this.stroke && this["stroke-width"] ? (a.prototype.fillSetter.call(this, this.stroke, "stroke", d),
                    d.setAttribute("stroke-width", this["stroke-width"]), this.hasStroke = !0) : "stroke-width" === c && 0 === b && this.hasStroke ? (d.removeAttribute("stroke"),
                        this.hasStroke = !1) : this.renderer.styledMode && this["stroke-width"] && (d.setAttribute("stroke-width", this["stroke-width"]),
                            this.hasStroke = !0);
            };
            a.prototype.strokeWidth = function () {
                if (!this.renderer.styledMode) return this["stroke-width"] || 0;
                var a = this.getStyle("stroke-width"), b = 0;
                if (a.indexOf("px") === a.length - 2) b = D(a); else if ("" !== a) {
                    var c = j.createElementNS(m, "rect");
                    p(c, {
                        width: a,
                        "stroke-width": 0
                    });
                    this.element.parentNode.appendChild(c);
                    b = c.getBBox().width;
                    c.parentNode.removeChild(c);
                }
                return b;
            };
            a.prototype.symbolAttr = function (a) {
                var b = this;
                "x y r start end width height innerR anchorX anchorY clockwise".split(" ").forEach(function (c) {
                    b[c] = C(a[c], b[c]);
                });
                b.attr({
                    d: b.renderer.symbols[b.symbolName](b.x, b.y, b.width, b.height, b)
                });
            };
            a.prototype.textSetter = function (a) {
                a !== this.textStr && (delete this.textPxLength, this.textStr = a, this.added && this.renderer.buildText(this));
            };
            a.prototype.titleSetter = function (a) {
                var b = this.element, c = b.getElementsByTagName("title")[0] || j.createElementNS(this.SVG_NS, "title");
                b.insertBefore ? b.insertBefore(c, b.firstChild) : b.appendChild(c);
                c.textContent = String(C(a, "")).replace(/<[^>]*>/g, "").replace(/&lt;/g, "<").replace(/&gt;/g, ">");
            };
            a.prototype.toFront = function () {
                var a = this.element;
                a.parentNode.appendChild(a);
                return this;
            };
            a.prototype.translate = function (a, b) {
                return this.attr({
                    translateX: a,
                    translateY: b
                });
            };
            a.prototype.updateShadows = function (a, b, c) {
                var d = this.shadows;
                if (d) for (var e = d.length; e--;) c.call(d[e], "height" === a ? Math.max(b - (d[e].cutHeight || 0), 0) : "d" === a ? this.d : b, a, d[e]);
            };
            a.prototype.updateTransform = function () {
                var a = this.scaleX, b = this.scaleY, c = this.inverted, d = this.rotation, e = this.matrix, f = this.element, g = this.translateX || 0, h = this.translateY || 0;
                c && (g += this.width, h += this.height);
                g = ["translate(" + g + "," + h + ")"];
                s(e) && g.push("matrix(" + e.join(",") + ")");
                c ? g.push("rotate(90) scale(-1,1)") : d && g.push("rotate(" + d + " " + C(this.rotationOriginX, f.getAttribute("x"), 0) + " " + C(this.rotationOriginY, f.getAttribute("y") || 0) + ")");
                (s(a) || s(b)) && g.push("scale(" + C(a, 1) + " " + C(b, 1) + ")");
                g.length && f.setAttribute("transform", g.join(" "));
            };
            a.prototype.visibilitySetter = function (a, b, c) {
                "inherit" === a ? c.removeAttribute(b) : this[b] !== a && c.setAttribute(b, a);
                this[b] = a;
            };
            a.prototype.xGetter = function (a) {
                "circle" === this.element.nodeName && ("x" === a ? a = "cx" : "y" === a && (a = "cy"));
                return this._defaultGetter(a);
            };
            a.prototype.zIndexSetter = function (a, b) {
                var c = this.renderer, d = this.parentGroup, e = (d || c).element || c.box, f = this.element;
                c = e === c.box;
                var g = !1;
                var h = this.added;
                var i;
                s(a) ? (f.setAttribute("data-z-index", a), a = +a, this[b] === a && (h = !1)) : s(this[b]) && f.removeAttribute("data-z-index");
                this[b] = a;
                if (h) {
                    (a = this.zIndex) && d && (d.handleZ = !0);
                    b = e.childNodes;
                    for (i = b.length - 1; 0 <= i && !g; i--) {
                        d = b[i];
                        h = d.getAttribute("data-z-index");
                        var j = !s(h);
                        if (d !== f) if (0 > a && j && !c && !i) e.insertBefore(f, b[i]), g = !0; else if (D(h) <= a || j && (!s(a) || 0 <= a)) e.insertBefore(f, b[i + 1] || null),
                            g = !0;
                    }
                    g || (e.insertBefore(f, b[c ? 3 : 0] || null), g = !0);
                }
                return g;
            };
            return a;
        }();
        a.prototype["stroke-widthSetter"] = a.prototype.strokeSetter;
        a.prototype.yGetter = a.prototype.xGetter;
        a.prototype.matrixSetter = a.prototype.rotationOriginXSetter = a.prototype.rotationOriginYSetter = a.prototype.rotationSetter = a.prototype.scaleXSetter = a.prototype.scaleYSetter = a.prototype.translateXSetter = a.prototype.translateYSetter = a.prototype.verticalAlignSetter = function (a, b) {
            this[b] = a;
            this.doTransform = !0;
        };
        return a;
    });
    b(c, "Core/Renderer/RendererRegistry.js", [c["Core/Globals.js"]], function (a) {
        var b;
        !function (b) {
            b.rendererTypes = {};
            var c;
            b.getRendererType = function (a) {
                void 0 === a && (a = c);
                return b.rendererTypes[a] || b.rendererTypes[c];
            };
            b.registerRendererType = function (d, e, f) {
                b.rendererTypes[d] = e;
                if (!c || f) c = d, a.Renderer = e;
            };
        }(b || (b = {}));
        return b;
    });
    b(c, "Core/Renderer/SVG/SVGLabel.js", [c["Core/Renderer/SVG/SVGElement.js"], c["Core/Utilities.js"]], function (a, b) {
        var c = this && this.__extends || function () {
            var a = function (b, c) {
                a = Object.setPrototypeOf || {
                    __proto__: []
                } instanceof Array && function (a, b) {
                    a.__proto__ = b;
                } || function (a, b) {
                    for (var c in b) b.hasOwnProperty(c) && (a[c] = b[c]);
                };
                return a(b, c);
            };
            return function (b, c) {
                function d() {
                    this.constructor = b;
                }
                a(b, c);
                b.prototype = null === c ? Object.create(c) : (d.prototype = c.prototype, new d());
            };
        }(), d = b.defined, e = b.extend, f = b.isNumber, g = b.merge, h = b.pick, i = b.removeEvent;
        return function (b) {
            function j(a, c, d, e, f, g, h, i, k, l) {
                var m = b.call(this) || this;
                m.paddingLeftSetter = m.paddingSetter;
                m.paddingRightSetter = m.paddingSetter;
                m.init(a, "g");
                m.textStr = c;
                m.x = d;
                m.y = e;
                m.anchorX = g;
                m.anchorY = h;
                m.baseline = k;
                m.className = l;
                m.addClass("button" === l ? "highcharts-no-tooltip" : "highcharts-label");
                l && m.addClass("highcharts-" + l);
                m.text = a.text(void 0, 0, 0, i).attr({
                    zIndex: 1
                });
                var n;
                "string" === typeof f && ((n = /^url\((.*?)\)$/.test(f)) || m.renderer.symbols[f]) && (m.symbolKey = f);
                m.bBox = j.emptyBBox;
                m.padding = 3;
                m.baselineOffset = 0;
                m.needsBox = a.styledMode || n;
                m.deferredAttr = {};
                m.alignFactor = 0;
                return m;
            }
            c(j, b);
            j.prototype.alignSetter = function (a) {
                a = {
                    left: 0,
                    center: .5,
                    right: 1
                }[a];
                a !== this.alignFactor && (this.alignFactor = a, this.bBox && f(this.xSetting) && this.attr({
                    x: this.xSetting
                }));
            };
            j.prototype.anchorXSetter = function (a, b) {
                this.anchorX = a;
                this.boxAttr(b, Math.round(a) - this.getCrispAdjust() - this.xSetting);
            };
            j.prototype.anchorYSetter = function (a, b) {
                this.anchorY = a;
                this.boxAttr(b, a - this.ySetting);
            };
            j.prototype.boxAttr = function (a, b) {
                this.box ? this.box.attr(a, b) : this.deferredAttr[a] = b;
            };
            j.prototype.css = function (b) {
                if (b) {
                    var c = {};
                    b = g(b);
                    j.textProps.forEach(function (a) {
                        "undefined" !== typeof b[a] && (c[a] = b[a], delete b[a]);
                    });
                    this.text.css(c);
                    var d = "width" in c;
                    "fontSize" in c || "fontWeight" in c ? this.updateTextPadding() : d && this.updateBoxSize();
                }
                return a.prototype.css.call(this, b);
            };
            j.prototype.destroy = function () {
                i(this.element, "mouseenter");
                i(this.element, "mouseleave");
                this.text && this.text.destroy();
                this.box && (this.box = this.box.destroy());
                a.prototype.destroy.call(this);
            };
            j.prototype.fillSetter = function (a, b) {
                a && (this.needsBox = !0);
                this.fill = a;
                this.boxAttr(b, a);
            };
            j.prototype.getBBox = function () {
                this.textStr && 0 === this.bBox.width && 0 === this.bBox.height && this.updateBoxSize();
                var a = this.padding, b = h(this.paddingLeft, a);
                return {
                    width: this.width,
                    height: this.height,
                    x: this.bBox.x - b,
                    y: this.bBox.y - a
                };
            };
            j.prototype.getCrispAdjust = function () {
                return this.renderer.styledMode && this.box ? this.box.strokeWidth() % 2 / 2 : (this["stroke-width"] ? parseInt(this["stroke-width"], 10) : 0) % 2 / 2;
            };
            j.prototype.heightSetter = function (a) {
                this.heightSetting = a;
            };
            j.prototype.onAdd = function () {
                var a = this.textStr;
                this.text.add(this);
                this.attr({
                    text: d(a) ? a : "",
                    x: this.x,
                    y: this.y
                });
                this.box && d(this.anchorX) && this.attr({
                    anchorX: this.anchorX,
                    anchorY: this.anchorY
                });
            };
            j.prototype.paddingSetter = function (a, b) {
                f(a) ? a !== this[b] && (this[b] = a, this.updateTextPadding()) : this[b] = void 0;
            };
            j.prototype.rSetter = function (a, b) {
                this.boxAttr(b, a);
            };
            j.prototype.shadow = function (a) {
                a && !this.renderer.styledMode && (this.updateBoxSize(), this.box && this.box.shadow(a));
                return this;
            };
            j.prototype.strokeSetter = function (a, b) {
                this.stroke = a;
                this.boxAttr(b, a);
            };
            j.prototype["stroke-widthSetter"] = function (a, b) {
                a && (this.needsBox = !0);
                this["stroke-width"] = a;
                this.boxAttr(b, a);
            };
            j.prototype["text-alignSetter"] = function (a) {
                this.textAlign = a;
            };
            j.prototype.textSetter = function (a) {
                "undefined" !== typeof a && this.text.attr({
                    text: a
                });
                this.updateTextPadding();
            };
            j.prototype.updateBoxSize = function () {
                var a = this.text.element.style, b = {}, c = this.padding, g = this.bBox = f(this.widthSetting) && f(this.heightSetting) && !this.textAlign || !d(this.text.textStr) ? j.emptyBBox : this.text.getBBox();
                this.width = this.getPaddedWidth();
                this.height = (this.heightSetting || g.height || 0) + 2 * c;
                a = this.renderer.fontMetrics(a && a.fontSize, this.text);
                this.baselineOffset = c + Math.min((this.text.firstLineMetrics || a).b, g.height || 1 / 0);
                this.heightSetting && (this.baselineOffset += (this.heightSetting - a.h) / 2);
                this.needsBox && (this.box || (c = this.box = this.symbolKey ? this.renderer.symbol(this.symbolKey) : this.renderer.rect(),
                    c.addClass(("button" === this.className ? "" : "highcharts-label-box") + (this.className ? " highcharts-" + this.className + "-box" : "")),
                    c.add(this)), c = this.getCrispAdjust(), b.x = c, b.y = (this.baseline ? -this.baselineOffset : 0) + c,
                    b.width = Math.round(this.width), b.height = Math.round(this.height), this.box.attr(e(b, this.deferredAttr)),
                    this.deferredAttr = {});
            };
            j.prototype.updateTextPadding = function () {
                var a = this.text;
                this.updateBoxSize();
                var b = this.baseline ? 0 : this.baselineOffset, c = h(this.paddingLeft, this.padding);
                d(this.widthSetting) && this.bBox && ("center" === this.textAlign || "right" === this.textAlign) && (c += {
                    center: .5,
                    right: 1
                }[this.textAlign] * (this.widthSetting - this.bBox.width));
                if (c !== a.x || b !== a.y) a.attr("x", c), a.hasBoxWidthChanged && (this.bBox = a.getBBox(!0)),
                    "undefined" !== typeof b && a.attr("y", b);
                a.x = c;
                a.y = b;
            };
            j.prototype.widthSetter = function (a) {
                this.widthSetting = f(a) ? a : void 0;
            };
            j.prototype.getPaddedWidth = function () {
                var a = this.padding, b = h(this.paddingLeft, a);
                a = h(this.paddingRight, a);
                return (this.widthSetting || this.bBox.width || 0) + b + a;
            };
            j.prototype.xSetter = function (a) {
                this.x = a;
                this.alignFactor && (a -= this.alignFactor * this.getPaddedWidth(), this["forceAnimate:x"] = !0);
                this.xSetting = Math.round(a);
                this.attr("translateX", this.xSetting);
            };
            j.prototype.ySetter = function (a) {
                this.ySetting = this.y = Math.round(a);
                this.attr("translateY", this.ySetting);
            };
            j.emptyBBox = {
                width: 0,
                height: 0,
                x: 0,
                y: 0
            };
            j.textProps = "color direction fontFamily fontSize fontStyle fontWeight lineHeight textAlign textDecoration textOutline textOverflow width".split(" ");
            return j;
        }(a);
    });
    b(c, "Core/Renderer/SVG/Symbols.js", [c["Core/Utilities.js"]], function (a) {
        function b(a, b, c, d, f) {
            var h = [];
            if (f) {
                var i = f.start || 0, j = g(f.r, c);
                c = g(f.r, d || c);
                var k = (f.end || 0) - .001;
                d = f.innerR;
                var l = g(f.open, .001 > Math.abs((f.end || 0) - i - 2 * Math.PI)), m = Math.cos(i), n = Math.sin(i), o = Math.cos(k), p = Math.sin(k);
                i = g(f.longArc, .001 > k - i - Math.PI ? 0 : 1);
                h.push(["M", a + j * m, b + c * n], ["A", j, c, 0, i, g(f.clockwise, 1), a + j * o, b + c * p]);
                e(d) && h.push(l ? ["M", a + d * o, b + d * p] : ["L", a + d * o, b + d * p], ["A", d, d, 0, i, e(f.clockwise) ? 1 - f.clockwise : 0, a + d * m, b + d * n]);
                l || h.push(["Z"]);
            }
            return h;
        }
        function c(a, b, c, e, f) {
            return f && f.r ? d(a, b, c, e, f) : [["M", a, b], ["L", a + c, b], ["L", a + c, b + e], ["L", a, b + e], ["Z"]];
        }
        function d(a, b, c, d, e) {
            e = e && e.r || 0;
            return [["M", a + e, b], ["L", a + c - e, b], ["C", a + c, b, a + c, b, a + c, b + e], ["L", a + c, b + d - e], ["C", a + c, b + d, a + c, b + d, a + c - e, b + d], ["L", a + e, b + d], ["C", a, b + d, a, b + d, a, b + d - e], ["L", a, b + e], ["C", a, b, a, b, a + e, b]];
        }
        var e = a.defined, f = a.isNumber, g = a.pick;
        return {
            arc: b,
            callout: function (a, b, c, e, g) {
                var h = Math.min(g && g.r || 0, c, e), i = h + 6, j = g && g.anchorX;
                g = g && g.anchorY || 0;
                var k = d(a, b, c, e, {
                    r: h
                });
                if (!f(j)) return k;
                a + j >= c ? g > b + i && g < b + e - i ? k.splice(3, 1, ["L", a + c, g - 6], ["L", a + c + 6, g], ["L", a + c, g + 6], ["L", a + c, b + e - h]) : k.splice(3, 1, ["L", a + c, e / 2], ["L", j, g], ["L", a + c, e / 2], ["L", a + c, b + e - h]) : 0 >= a + j ? g > b + i && g < b + e - i ? k.splice(7, 1, ["L", a, g + 6], ["L", a - 6, g], ["L", a, g - 6], ["L", a, b + h]) : k.splice(7, 1, ["L", a, e / 2], ["L", j, g], ["L", a, e / 2], ["L", a, b + h]) : g && g > e && j > a + i && j < a + c - i ? k.splice(5, 1, ["L", j + 6, b + e], ["L", j, b + e + 6], ["L", j - 6, b + e], ["L", a + h, b + e]) : g && 0 > g && j > a + i && j < a + c - i && k.splice(1, 1, ["L", j - 6, b], ["L", j, b - 6], ["L", j + 6, b], ["L", c - h, b]);
                return k;
            },
            circle: function (a, c, d, e) {
                return b(a + d / 2, c + e / 2, d / 2, e / 2, {
                    start: .5 * Math.PI,
                    end: 2.5 * Math.PI,
                    open: !1
                });
            },
            diamond: function (a, b, c, d) {
                return [["M", a + c / 2, b], ["L", a + c, b + d / 2], ["L", a + c / 2, b + d], ["L", a, b + d / 2], ["Z"]];
            },
            rect: c,
            roundedRect: d,
            square: c,
            triangle: function (a, b, c, d) {
                return [["M", a + c / 2, b], ["L", a + c, b + d], ["L", a, b + d], ["Z"]];
            },
            "triangle-down": function (a, b, c, d) {
                return [["M", a, b], ["L", a + c, b], ["L", a + c / 2, b + d], ["Z"]];
            }
        };
    });
    b(c, "Core/Renderer/SVG/TextBuilder.js", [c["Core/Renderer/HTML/AST.js"], c["Core/Globals.js"], c["Core/Utilities.js"]], function (a, b, c) {
        var d = b.doc, e = b.SVG_NS, f = b.win, g = c.attr, h = c.extend, i = c.isString, j = c.objectEach, k = c.pick;
        return function () {
            function b(a) {
                var b = a.styles;
                this.renderer = a.renderer;
                this.svgElement = a;
                this.width = a.textWidth;
                this.textLineHeight = b && b.lineHeight;
                this.textOutline = b && b.textOutline;
                this.ellipsis = !(!b || "ellipsis" !== b.textOverflow);
                this.noWrap = !(!b || "nowrap" !== b.whiteSpace);
                this.fontSize = b && b.fontSize;
            }
            b.prototype.buildSVG = function () {
                var b = this.svgElement, c = b.element, e = b.renderer, f = k(b.textStr, "").toString(), g = -1 !== f.indexOf("<"), h = c.childNodes;
                e = this.width && !b.added && e.box;
                var j = /<br.*?>/g, l = [f, this.ellipsis, this.noWrap, this.textLineHeight, this.textOutline, this.fontSize, this.width].join();
                if (l !== b.textCache) {
                    b.textCache = l;
                    delete b.actualWidth;
                    for (l = h.length; l--;) c.removeChild(h[l]);
                    g || this.ellipsis || this.width || -1 !== f.indexOf(" ") && (!this.noWrap || j.test(f)) ? "" !== f && (e && e.appendChild(c),
                        f = new a(f), this.modifyTree(f.nodes), f.addToDOM(b.element), this.modifyDOM(),
                        this.ellipsis && -1 !== (c.textContent || "").indexOf("…") && b.attr("title", this.unescapeEntities(b.textStr || "", ["&lt;", "&gt;"])),
                        e && e.removeChild(c)) : c.appendChild(d.createTextNode(this.unescapeEntities(f)));
                    i(this.textOutline) && b.applyTextOutline && b.applyTextOutline(this.textOutline);
                }
            };
            b.prototype.modifyDOM = function () {
                var a = this, b = this.svgElement, c = g(b.element, "x");
                b.firstLineMetrics = void 0;
                for (var h; h = b.element.firstChild;) if (/^[\s\u200B]*$/.test(h.textContent || " ")) b.element.removeChild(h); else break;
                [].forEach.call(b.element.querySelectorAll("tspan.highcharts-br"), function (d, e) {
                    d.nextSibling && d.previousSibling && (0 === e && 1 === d.previousSibling.nodeType && (b.firstLineMetrics = b.renderer.fontMetrics(void 0, d.previousSibling)),
                        g(d, {
                            dy: a.getLineHeight(d.nextSibling),
                            x: c
                        }));
                });
                var i = this.width || 0;
                if (i) {
                    var j = function (f, h) {
                        var j = f.textContent || "", k = j.replace(/([^\^])-/g, "$1- ").split(" "), l = !a.noWrap && (1 < k.length || 1 < b.element.childNodes.length), m = a.getLineHeight(h), n = 0, o = b.actualWidth;
                        if (a.ellipsis) j && a.truncate(f, j, void 0, 0, Math.max(0, i - parseInt(a.fontSize || 12, 10)), function (a, b) {
                            return a.substring(0, b) + "…";
                        }); else if (l) {
                            j = [];
                            for (l = []; h.firstChild && h.firstChild !== f;) l.push(h.firstChild), h.removeChild(h.firstChild);
                            for (; k.length;) k.length && !a.noWrap && 0 < n && (j.push(f.textContent || ""),
                                f.textContent = k.join(" ").replace(/- /g, "-")), a.truncate(f, void 0, k, 0 === n ? o || 0 : 0, i, function (a, b) {
                                    return k.slice(0, b).join(" ").replace(/- /g, "-");
                                }), o = b.actualWidth, n++;
                            l.forEach(function (a) {
                                h.insertBefore(a, f);
                            });
                            j.forEach(function (a) {
                                h.insertBefore(d.createTextNode(a), f);
                                a = d.createElementNS(e, "tspan");
                                a.textContent = "​";
                                g(a, {
                                    dy: m,
                                    x: c
                                });
                                h.insertBefore(a, f);
                            });
                        }
                    }, k = function (a) {
                        [].slice.call(a.childNodes).forEach(function (c) {
                            c.nodeType === f.Node.TEXT_NODE ? j(c, a) : (-1 !== c.className.baseVal.indexOf("highcharts-br") && (b.actualWidth = 0),
                                k(c));
                        });
                    };
                    k(b.element);
                }
            };
            b.prototype.getLineHeight = function (a) {
                var b;
                a = a.nodeType === f.Node.TEXT_NODE ? a.parentElement : a;
                this.renderer.styledMode || (b = a && /(px|em)$/.test(a.style.fontSize) ? a.style.fontSize : this.fontSize || this.renderer.style.fontSize || 12);
                return this.textLineHeight ? parseInt(this.textLineHeight.toString(), 10) : this.renderer.fontMetrics(b, a || this.svgElement.element).h;
            };
            b.prototype.modifyTree = function (a) {
                var b = this, c = function (d, e) {
                    var f = d.attributes;
                    f = void 0 === f ? {} : f;
                    var g = d.children, i = d.style;
                    i = void 0 === i ? {} : i;
                    var j = d.tagName, k = b.renderer.styledMode;
                    if ("b" === j || "strong" === j) k ? f["class"] = "highcharts-strong" : i.fontWeight = "bold"; else if ("i" === j || "em" === j) k ? f["class"] = "highcharts-emphasized" : i.fontStyle = "italic";
                    i && i.color && (i.fill = i.color);
                    "br" === j ? (f["class"] = "highcharts-br", d.textContent = "​", (e = a[e + 1]) && e.textContent && (e.textContent = e.textContent.replace(/^ +/gm, ""))) : "a" === j && g && g.some(function (a) {
                        return "#text" === a.tagName;
                    }) && (d.children = [{
                        children: g,
                        tagName: "tspan"
                    }]);
                    "#text" !== j && "a" !== j && (d.tagName = "tspan");
                    h(d, {
                        attributes: f,
                        style: i
                    });
                    g && g.filter(function (a) {
                        return "#text" !== a.tagName;
                    }).forEach(c);
                };
                a.forEach(c);
            };
            b.prototype.truncate = function (a, b, c, d, e, f) {
                var g = this.svgElement, h = g.renderer, i = g.rotation, j = [], k = c ? 1 : 0, l = (b || c || "").length, m = l, n, o = function (e, i) {
                    i = i || e;
                    var k = a.parentNode;
                    if (k && "undefined" === typeof j[i]) if (k.getSubStringLength) try {
                        j[i] = d + k.getSubStringLength(0, c ? i + 1 : i);
                    } catch (l) { } else h.getSpanWidth && (a.textContent = f(b || c, e), j[i] = d + h.getSpanWidth(g, a));
                    return j[i];
                };
                g.rotation = 0;
                var p = o(a.textContent.length);
                if (d + p > e) {
                    for (; k <= l;) m = Math.ceil((k + l) / 2), c && (n = f(c, m)), p = o(m, n && n.length - 1),
                        k === l ? k = l + 1 : p > e ? l = m - 1 : k = m;
                    0 === l ? a.textContent = "" : b && l === b.length - 1 || (a.textContent = n || f(b || c, m));
                }
                c && c.splice(0, m);
                g.actualWidth = p;
                g.rotation = i;
            };
            b.prototype.unescapeEntities = function (a, b) {
                j(this.renderer.escapes, function (c, d) {
                    b && -1 !== b.indexOf(c) || (a = a.toString().replace(new RegExp(c, "g"), d));
                });
                return a;
            };
            return b;
        }();
    });
    b(c, "Core/Renderer/SVG/SVGRenderer.js", [c["Core/Renderer/HTML/AST.js"], c["Core/Color/Color.js"], c["Core/Globals.js"], c["Core/Renderer/RendererRegistry.js"], c["Core/Renderer/SVG/SVGElement.js"], c["Core/Renderer/SVG/SVGLabel.js"], c["Core/Renderer/SVG/Symbols.js"], c["Core/Renderer/SVG/TextBuilder.js"], c["Core/Utilities.js"]], function (a, b, c, d, e, f, g, h, i) {
        var j = c.charts, k = c.deg2rad, l = c.doc, m = c.isFirefox, n = c.isMS, o = c.isWebKit, p = c.noop, q = c.SVG_NS, r = c.symbolSizes, s = c.win, t = i.addEvent, u = i.attr, v = i.createElement, w = i.css, x = i.defined, y = i.destroyObjectProperties, z = i.extend, A = i.isArray, B = i.isNumber, C = i.isObject, D = i.isString, E = i.merge, F = i.pick, G = i.pInt, H = i.uniqueKey, I;
        c = function () {
            function c(a, b, c, d, e, f, g) {
                this.width = this.url = this.style = this.isSVG = this.imgCount = this.height = this.gradients = this.globalAnimation = this.defs = this.chartIndex = this.cacheKeys = this.cache = this.boxWrapper = this.box = this.alignedObjects = void 0;
                this.init(a, b, c, d, e, f, g);
            }
            c.prototype.init = function (a, b, c, d, e, f, g) {
                var h = this.createElement("svg").attr({
                    version: "1.1",
                    "class": "highcharts-root"
                }), i = h.element;
                g || h.css(this.getStyle(d));
                a.appendChild(i);
                u(a, "dir", "ltr");
                -1 === a.innerHTML.indexOf("xmlns") && u(i, "xmlns", this.SVG_NS);
                this.isSVG = !0;
                this.box = i;
                this.boxWrapper = h;
                this.alignedObjects = [];
                this.url = this.getReferenceURL();
                this.createElement("desc").add().element.appendChild(l.createTextNode("Created with Highcharts 10.0.0"));
                this.defs = this.createElement("defs").add();
                this.allowHTML = f;
                this.forExport = e;
                this.styledMode = g;
                this.gradients = {};
                this.cache = {};
                this.cacheKeys = [];
                this.imgCount = 0;
                this.setSize(b, c, !1);
                var j;
                m && a.getBoundingClientRect && (b = function () {
                    w(a, {
                        left: 0,
                        top: 0
                    });
                    j = a.getBoundingClientRect();
                    w(a, {
                        left: Math.ceil(j.left) - j.left + "px",
                        top: Math.ceil(j.top) - j.top + "px"
                    });
                }, b(), this.unSubPixelFix = t(s, "resize", b));
            };
            c.prototype.definition = function (b) {
                return new a([b]).addToDOM(this.defs.element);
            };
            c.prototype.getReferenceURL = function () {
                if ((m || o) && l.getElementsByTagName("base").length) {
                    if (!x(I)) {
                        var b = H();
                        b = new a([{
                            tagName: "svg",
                            attributes: {
                                width: 8,
                                height: 8
                            },
                            children: [{
                                tagName: "defs",
                                children: [{
                                    tagName: "clipPath",
                                    attributes: {
                                        id: b
                                    },
                                    children: [{
                                        tagName: "rect",
                                        attributes: {
                                            width: 4,
                                            height: 4
                                        }
                                    }]
                                }]
                            }, {
                                tagName: "rect",
                                attributes: {
                                    id: "hitme",
                                    width: 8,
                                    height: 8,
                                    "clip-path": "url(#" + b + ")",
                                    fill: "rgba(0,0,0,0.001)"
                                }
                            }]
                        }]).addToDOM(l.body);
                        w(b, {
                            position: "fixed",
                            top: 0,
                            left: 0,
                            zIndex: 9e5
                        });
                        var c = l.elementFromPoint(6, 6);
                        I = "hitme" === (c && c.id);
                        l.body.removeChild(b);
                    }
                    if (I) return s.location.href.split("#")[0].replace(/<[^>]*>/g, "").replace(/([\('\)])/g, "\\$1").replace(/ /g, "%20");
                }
                return "";
            };
            c.prototype.getStyle = function (a) {
                return this.style = z({
                    fontFamily: '"Lucida Grande", "Lucida Sans Unicode", Arial, Helvetica, sans-serif',
                    fontSize: "12px"
                }, a);
            };
            c.prototype.setStyle = function (a) {
                this.boxWrapper.css(this.getStyle(a));
            };
            c.prototype.isHidden = function () {
                return !this.boxWrapper.getBBox().width;
            };
            c.prototype.destroy = function () {
                var a = this.defs;
                this.box = null;
                this.boxWrapper = this.boxWrapper.destroy();
                y(this.gradients || {});
                this.gradients = null;
                a && (this.defs = a.destroy());
                this.unSubPixelFix && this.unSubPixelFix();
                return this.alignedObjects = null;
            };
            c.prototype.createElement = function (a) {
                var b = new this.Element();
                b.init(this, a);
                return b;
            };
            c.prototype.getRadialAttr = function (a, b) {
                return {
                    cx: a[0] - a[2] / 2 + (b.cx || 0) * a[2],
                    cy: a[1] - a[2] / 2 + (b.cy || 0) * a[2],
                    r: (b.r || 0) * a[2]
                };
            };
            c.prototype.buildText = function (a) {
                new h(a).buildSVG();
            };
            c.prototype.getContrast = function (a) {
                a = b.parse(a).rgba;
                a[0] *= 1;
                a[1] *= 1.2;
                a[2] *= .5;
                return 459 < a[0] + a[1] + a[2] ? "#000000" : "#FFFFFF";
            };
            c.prototype.button = function (b, c, d, e, f, g, h, i, j, k) {
                var l = this.label(b, c, d, j, void 0, void 0, k, void 0, "button"), m = this.styledMode, o = 0, p = f ? E(f) : {}, q = E({
                    color: "#333333",
                    cursor: "pointer",
                    fontWeight: "normal"
                }, p.style);
                delete p.style;
                p = a.filterUserAttributes(p);
                l.attr(E({
                    padding: 8,
                    r: 2
                }, p));
                if (!m) {
                    p = E({
                        fill: "#f7f7f7",
                        stroke: "#cccccc",
                        "stroke-width": 1
                    }, p);
                    g = E(p, {
                        fill: "#e6e6e6"
                    }, a.filterUserAttributes(g || {}));
                    var r = g.style;
                    delete g.style;
                    h = E(p, {
                        fill: "#e6ebf5",
                        style: {
                            color: "#000000",
                            fontWeight: "bold"
                        }
                    }, a.filterUserAttributes(h || {}));
                    var s = h.style;
                    delete h.style;
                    i = E(p, {
                        style: {
                            color: "#cccccc"
                        }
                    }, a.filterUserAttributes(i || {}));
                    var u = i.style;
                    delete i.style;
                }
                t(l.element, n ? "mouseover" : "mouseenter", function () {
                    3 !== o && l.setState(1);
                });
                t(l.element, n ? "mouseout" : "mouseleave", function () {
                    3 !== o && l.setState(o);
                });
                l.setState = function (a) {
                    1 !== a && (l.state = o = a);
                    l.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass("highcharts-button-" + ["normal", "hover", "pressed", "disabled"][a || 0]);
                    m || (l.attr([p, g, h, i][a || 0]), a = [q, r, s, u][a || 0], C(a) && l.css(a));
                };
                m || l.attr(p).css(z({
                    cursor: "default"
                }, q));
                return l.on("touchstart", function (a) {
                    return a.stopPropagation();
                }).on("click", function (a) {
                    3 !== o && e.call(l, a);
                });
            };
            c.prototype.crispLine = function (a, b, c) {
                void 0 === c && (c = "round");
                var d = a[0], e = a[1];
                x(d[1]) && d[1] === e[1] && (d[1] = e[1] = Math[c](d[1]) - b % 2 / 2);
                x(d[2]) && d[2] === e[2] && (d[2] = e[2] = Math[c](d[2]) + b % 2 / 2);
                return a;
            };
            c.prototype.path = function (a) {
                var b = this.styledMode ? {} : {
                    fill: "none"
                };
                A(a) ? b.d = a : C(a) && z(b, a);
                return this.createElement("path").attr(b);
            };
            c.prototype.circle = function (a, b, c) {
                a = C(a) ? a : "undefined" === typeof a ? {} : {
                    x: a,
                    y: b,
                    r: c
                };
                b = this.createElement("circle");
                b.xSetter = b.ySetter = function (a, b, c) {
                    c.setAttribute("c" + b, a);
                };
                return b.attr(a);
            };
            c.prototype.arc = function (a, b, c, d, e, f) {
                C(a) ? (d = a, b = d.y, c = d.r, a = d.x) : d = {
                    innerR: d,
                    start: e,
                    end: f
                };
                a = this.symbol("arc", a, b, c, c, d);
                a.r = c;
                return a;
            };
            c.prototype.rect = function (a, b, c, d, e, f) {
                e = C(a) ? a.r : e;
                var g = this.createElement("rect");
                a = C(a) ? a : "undefined" === typeof a ? {} : {
                    x: a,
                    y: b,
                    width: Math.max(c, 0),
                    height: Math.max(d, 0)
                };
                this.styledMode || ("undefined" !== typeof f && (a["stroke-width"] = f, a = g.crisp(a)),
                    a.fill = "none");
                e && (a.r = e);
                g.rSetter = function (a, b, c) {
                    g.r = a;
                    u(c, {
                        rx: a,
                        ry: a
                    });
                };
                g.rGetter = function () {
                    return g.r || 0;
                };
                return g.attr(a);
            };
            c.prototype.setSize = function (a, b, c) {
                this.width = a;
                this.height = b;
                this.boxWrapper.animate({
                    width: a,
                    height: b
                }, {
                    step: function () {
                        this.attr({
                            viewBox: "0 0 " + this.attr("width") + " " + this.attr("height")
                        });
                    },
                    duration: F(c, !0) ? void 0 : 0
                });
                this.alignElements();
            };
            c.prototype.g = function (a) {
                var b = this.createElement("g");
                return a ? b.attr({
                    "class": "highcharts-" + a
                }) : b;
            };
            c.prototype.image = function (a, b, c, d, e, f) {
                var g = {
                    preserveAspectRatio: "none"
                }, h = function (a, b) {
                    a.setAttributeNS ? a.setAttributeNS("http://www.w3.org/1999/xlink", "href", b) : a.setAttribute("hc-svg-href", b);
                };
                B(b) && (g.x = b);
                B(c) && (g.y = c);
                B(d) && (g.width = d);
                B(e) && (g.height = e);
                var i = this.createElement("image").attr(g);
                b = function (b) {
                    h(i.element, a);
                    f.call(i, b);
                };
                f ? (h(i.element, "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="),
                    c = new s.Image(), t(c, "load", b), c.src = a, c.complete && b({})) : h(i.element, a);
                return i;
            };
            c.prototype.symbol = function (a, b, c, d, e, f) {
                var g = this, h = /^url\((.*?)\)$/, i = h.test(a), k = !i && (this.symbols[a] ? a : "circle"), m = k && this.symbols[k], n;
                if (m) {
                    "number" === typeof b && (n = m.call(this.symbols, Math.round(b || 0), Math.round(c || 0), d || 0, e || 0, f));
                    var o = this.path(n);
                    g.styledMode || o.attr("fill", "none");
                    z(o, {
                        symbolName: k || void 0,
                        x: b,
                        y: c,
                        width: d,
                        height: e
                    });
                    f && z(o, f);
                } else if (i) {
                    var p = a.match(h)[1];
                    var q = o = this.image(p);
                    q.imgwidth = F(r[p] && r[p].width, f && f.width);
                    q.imgheight = F(r[p] && r[p].height, f && f.height);
                    var s = function (a) {
                        return a.attr({
                            width: a.width,
                            height: a.height
                        });
                    };
                    ["width", "height"].forEach(function (a) {
                        q[a + "Setter"] = function (a, b) {
                            var c = this["img" + b];
                            this[b] = a;
                            x(c) && (f && "within" === f.backgroundSize && this.width && this.height && (c = Math.round(c * Math.min(this.width / this.imgwidth, this.height / this.imgheight))),
                                this.element && this.element.setAttribute(b, c), this.alignByTranslate || (a = ((this[b] || 0) - c) / 2,
                                    this.attr("width" === b ? {
                                        translateX: a
                                    } : {
                                        translateY: a
                                    })));
                        };
                    });
                    x(b) && q.attr({
                        x: b,
                        y: c
                    });
                    q.isImg = !0;
                    x(q.imgwidth) && x(q.imgheight) ? s(q) : (q.attr({
                        width: 0,
                        height: 0
                    }), v("img", {
                        onload: function () {
                            var a = j[g.chartIndex];
                            0 === this.width && (w(this, {
                                position: "absolute",
                                top: "-999em"
                            }), l.body.appendChild(this));
                            r[p] = {
                                width: this.width,
                                height: this.height
                            };
                            q.imgwidth = this.width;
                            q.imgheight = this.height;
                            q.element && s(q);
                            this.parentNode && this.parentNode.removeChild(this);
                            g.imgCount--;
                            if (!g.imgCount && a && !a.hasLoaded) a.onload();
                        },
                        src: p
                    }), this.imgCount++);
                }
                return o;
            };
            c.prototype.clipRect = function (a, b, c, d) {
                var e = H() + "-", f = this.createElement("clipPath").attr({
                    id: e
                }).add(this.defs);
                a = this.rect(a, b, c, d, 0).add(f);
                a.id = e;
                a.clipPath = f;
                a.count = 0;
                return a;
            };
            c.prototype.text = function (a, b, c, d) {
                var e = {};
                if (d && (this.allowHTML || !this.forExport)) return this.html(a, b, c);
                e.x = Math.round(b || 0);
                c && (e.y = Math.round(c));
                x(a) && (e.text = a);
                a = this.createElement("text").attr(e);
                if (!d || this.forExport && !this.allowHTML) a.xSetter = function (a, b, c) {
                    for (var d = c.getElementsByTagName("tspan"), e = c.getAttribute(b), f = 0, g; f < d.length; f++) g = d[f],
                        g.getAttribute(b) === e && g.setAttribute(b, a);
                    c.setAttribute(b, a);
                };
                return a;
            };
            c.prototype.fontMetrics = function (a, b) {
                a = !this.styledMode && /px/.test(a) || !s.getComputedStyle ? a || b && b.style && b.style.fontSize || this.style && this.style.fontSize : b && e.prototype.getStyle.call(b, "font-size");
                a = /px/.test(a) ? G(a) : 12;
                b = 24 > a ? a + 3 : Math.round(1.2 * a);
                return {
                    h: b,
                    b: Math.round(.8 * b),
                    f: a
                };
            };
            c.prototype.rotCorr = function (a, b, c) {
                var d = a;
                b && c && (d = Math.max(d * Math.cos(b * k), 4));
                return {
                    x: -a / 3 * Math.sin(b * k),
                    y: d
                };
            };
            c.prototype.pathToSegments = function (a) {
                for (var b = [], c = [], d = {
                    A: 8,
                    C: 7,
                    H: 2,
                    L: 3,
                    M: 3,
                    Q: 5,
                    S: 5,
                    T: 3,
                    V: 2
                }, e = 0; e < a.length; e++) D(c[0]) && B(a[e]) && c.length === d[c[0].toUpperCase()] && a.splice(e, 0, c[0].replace("M", "L").replace("m", "l")),
                    "string" === typeof a[e] && (c.length && b.push(c.slice(0)), c.length = 0), c.push(a[e]);
                b.push(c.slice(0));
                return b;
            };
            c.prototype.label = function (a, b, c, d, e, g, h, i, j) {
                return new f(this, a, b, c, d, e, g, h, i, j);
            };
            c.prototype.alignElements = function () {
                this.alignedObjects.forEach(function (a) {
                    return a.align();
                });
            };
            return c;
        }();
        z(c.prototype, {
            Element: e,
            SVG_NS: q,
            escapes: {
                "&": "&amp;",
                "<": "&lt;",
                ">": "&gt;",
                "'": "&#39;",
                '"': "&quot;"
            },
            symbols: g,
            draw: p
        });
        d.registerRendererType("svg", c, !0);
        return c;
    });
    b(c, "Core/Renderer/HTML/HTMLElement.js", [c["Core/Globals.js"], c["Core/Renderer/SVG/SVGElement.js"], c["Core/Utilities.js"]], function (a, b, c) {
        var d = this && this.__extends || function () {
            var a = function (b, c) {
                a = Object.setPrototypeOf || {
                    __proto__: []
                } instanceof Array && function (a, b) {
                    a.__proto__ = b;
                } || function (a, b) {
                    for (var c in b) b.hasOwnProperty(c) && (a[c] = b[c]);
                };
                return a(b, c);
            };
            return function (b, c) {
                function d() {
                    this.constructor = b;
                }
                a(b, c);
                b.prototype = null === c ? Object.create(c) : (d.prototype = c.prototype, new d());
            };
        }(), e = a.isFirefox, f = a.isMS, g = a.isWebKit, h = a.win, i = c.css, j = c.defined, k = c.extend, l = c.pick, m = c.pInt;
        return function (a) {
            function b() {
                return null !== a && a.apply(this, arguments) || this;
            }
            d(b, a);
            b.compose = function (a) {
                if (-1 === b.composedClasses.indexOf(a)) {
                    b.composedClasses.push(a);
                    var c = b.prototype, d = a.prototype;
                    d.getSpanCorrection = c.getSpanCorrection;
                    d.htmlCss = c.htmlCss;
                    d.htmlGetBBox = c.htmlGetBBox;
                    d.htmlUpdateTransform = c.htmlUpdateTransform;
                    d.setSpanRotation = c.setSpanRotation;
                }
                return a;
            };
            b.prototype.getSpanCorrection = function (a, b, c) {
                this.xCorr = -a * c;
                this.yCorr = -b;
            };
            b.prototype.htmlCss = function (a) {
                var b = "SPAN" === this.element.tagName && a && "width" in a, c = l(b && a.width, void 0);
                if (b) {
                    delete a.width;
                    this.textWidth = c;
                    var d = !0;
                }
                a && "ellipsis" === a.textOverflow && (a.whiteSpace = "nowrap", a.overflow = "hidden");
                this.styles = k(this.styles, a);
                i(this.element, a);
                d && this.htmlUpdateTransform();
                return this;
            };
            b.prototype.htmlGetBBox = function () {
                var a = this.element;
                return {
                    x: a.offsetLeft,
                    y: a.offsetTop,
                    width: a.offsetWidth,
                    height: a.offsetHeight
                };
            };
            b.prototype.htmlUpdateTransform = function () {
                if (this.added) {
                    var a = this.renderer, b = this.element, c = this.translateX || 0, d = this.translateY || 0, e = this.x || 0, f = this.y || 0, g = this.textAlign || "left", h = {
                        left: 0,
                        center: .5,
                        right: 1
                    }[g], k = this.styles;
                    k = k && k.whiteSpace;
                    i(b, {
                        marginLeft: c,
                        marginTop: d
                    });
                    !a.styledMode && this.shadows && this.shadows.forEach(function (a) {
                        i(a, {
                            marginLeft: c + 1,
                            marginTop: d + 1
                        });
                    });
                    this.inverted && [].forEach.call(b.childNodes, function (c) {
                        a.invertChild(c, b);
                    });
                    if ("SPAN" === b.tagName) {
                        var l = this.rotation, n = this.textWidth && m(this.textWidth), o = [l, g, b.innerHTML, this.textWidth, this.textAlign].join(), p = void 0;
                        p = !1;
                        if (n !== this.oldTextWidth) {
                            if (this.textPxLength) var q = this.textPxLength; else i(b, {
                                width: "",
                                whiteSpace: k || "nowrap"
                            }), q = b.offsetWidth;
                            (n > this.oldTextWidth || q > n) && (/[ \-]/.test(b.textContent || b.innerText) || "ellipsis" === b.style.textOverflow) && (i(b, {
                                width: q > n || l ? n + "px" : "auto",
                                display: "block",
                                whiteSpace: k || "normal"
                            }), this.oldTextWidth = n, p = !0);
                        }
                        this.hasBoxWidthChanged = p;
                        o !== this.cTT && (p = a.fontMetrics(b.style.fontSize, b).b, !j(l) || l === (this.oldRotation || 0) && g === this.oldAlign || this.setSpanRotation(l, h, p),
                            this.getSpanCorrection(!j(l) && this.textPxLength || b.offsetWidth, p, h, l, g));
                        i(b, {
                            left: e + (this.xCorr || 0) + "px",
                            top: f + (this.yCorr || 0) + "px"
                        });
                        this.cTT = o;
                        this.oldRotation = l;
                        this.oldAlign = g;
                    }
                } else this.alignOnAdd = !0;
            };
            b.prototype.setSpanRotation = function (a, b, c) {
                var d = {}, j = f && !/Edge/.test(h.navigator.userAgent) ? "-ms-transform" : g ? "-webkit-transform" : e ? "MozTransform" : h.opera ? "-o-transform" : void 0;
                j && (d[j] = d.transform = "rotate(" + a + "deg)", d[j + (e ? "Origin" : "-origin")] = d.transformOrigin = 100 * b + "% " + c + "px",
                    i(this.element, d));
            };
            b.composedClasses = [];
            return b;
        }(b);
    });
    b(c, "Core/Renderer/HTML/HTMLRenderer.js", [c["Core/Renderer/HTML/AST.js"], c["Core/Renderer/SVG/SVGElement.js"], c["Core/Renderer/SVG/SVGRenderer.js"], c["Core/Utilities.js"]], function (a, b, c, d) {
        var e = this && this.__extends || function () {
            var a = function (b, c) {
                a = Object.setPrototypeOf || {
                    __proto__: []
                } instanceof Array && function (a, b) {
                    a.__proto__ = b;
                } || function (a, b) {
                    for (var c in b) b.hasOwnProperty(c) && (a[c] = b[c]);
                };
                return a(b, c);
            };
            return function (b, c) {
                function d() {
                    this.constructor = b;
                }
                a(b, c);
                b.prototype = null === c ? Object.create(c) : (d.prototype = c.prototype, new d());
            };
        }(), f = d.attr, g = d.createElement, h = d.extend, i = d.pick;
        return function (c) {
            function d() {
                return null !== c && c.apply(this, arguments) || this;
            }
            e(d, c);
            d.compose = function (a) {
                -1 === d.composedClasses.indexOf(a) && (d.composedClasses.push(a), a.prototype.html = d.prototype.html);
                return a;
            };
            d.prototype.html = function (c, d, e) {
                var j = this.createElement("span"), k = j.element, l = j.renderer, m = l.isSVG, n = function (a, c) {
                    ["opacity", "visibility"].forEach(function (d) {
                        a[d + "Setter"] = function (e, f, g) {
                            var h = a.div ? a.div.style : c;
                            b.prototype[d + "Setter"].call(this, e, f, g);
                            h && (h[f] = e);
                        };
                    });
                    a.addedSetters = !0;
                };
                j.textSetter = function (b) {
                    b !== this.textStr && (delete this.bBox, delete this.oldTextWidth, a.setElementHTML(this.element, i(b, "")),
                        this.textStr = b, j.doTransform = !0);
                };
                m && n(j, j.element.style);
                j.xSetter = j.ySetter = j.alignSetter = j.rotationSetter = function (a, b) {
                    "align" === b ? j.alignValue = j.textAlign = a : j[b] = a;
                    j.doTransform = !0;
                };
                j.afterSetters = function () {
                    this.doTransform && (this.htmlUpdateTransform(), this.doTransform = !1);
                };
                j.attr({
                    text: c,
                    x: Math.round(d),
                    y: Math.round(e)
                }).css({
                    position: "absolute"
                });
                l.styledMode || j.css({
                    fontFamily: this.style.fontFamily,
                    fontSize: this.style.fontSize
                });
                k.style.whiteSpace = "nowrap";
                j.css = j.htmlCss;
                m && (j.add = function (a) {
                    var b = l.box.parentNode, c = [];
                    if (this.parentGroup = a) {
                        var d = a.div;
                        if (!d) {
                            for (; a;) c.push(a), a = a.parentGroup;
                            c.reverse().forEach(function (a) {
                                function e(b, c) {
                                    a[c] = b;
                                    "translateX" === c ? l.left = b + "px" : l.top = b + "px";
                                    a.doTransform = !0;
                                }
                                var i = f(a.element, "class"), k = a.styles || {};
                                d = a.div = a.div || g("div", i ? {
                                    className: i
                                } : void 0, {
                                    position: "absolute",
                                    left: (a.translateX || 0) + "px",
                                    top: (a.translateY || 0) + "px",
                                    display: a.display,
                                    opacity: a.opacity,
                                    cursor: k.cursor,
                                    pointerEvents: k.pointerEvents,
                                    visibility: a.visibility
                                }, d || b);
                                var l = d.style;
                                h(a, {
                                    classSetter: function (a) {
                                        return function (b) {
                                            this.element.setAttribute("class", b);
                                            a.className = b;
                                        };
                                    }(d),
                                    on: function () {
                                        c[0].div && j.on.apply({
                                            element: c[0].div,
                                            onEvents: a.onEvents
                                        }, arguments);
                                        return a;
                                    },
                                    translateXSetter: e,
                                    translateYSetter: e
                                });
                                a.addedSetters || n(a);
                            });
                        }
                    } else d = b;
                    d.appendChild(k);
                    j.added = !0;
                    j.alignOnAdd && j.htmlUpdateTransform();
                    return j;
                });
                return j;
            };
            d.composedClasses = [];
            return d;
        }(c);
    });
    b(c, "Core/Axis/AxisDefaults.js", [], function () {
        var a;
        !function (a) {
            a.defaultXAxisOptions = {
                alignTicks: !0,
                allowDecimals: void 0,
                panningEnabled: !0,
                zIndex: 2,
                zoomEnabled: !0,
                dateTimeLabelFormats: {
                    millisecond: {
                        main: "%H:%M:%S.%L",
                        range: !1
                    },
                    second: {
                        main: "%H:%M:%S",
                        range: !1
                    },
                    minute: {
                        main: "%H:%M",
                        range: !1
                    },
                    hour: {
                        main: "%H:%M",
                        range: !1
                    },
                    day: {
                        main: "%e. %b"
                    },
                    week: {
                        main: "%e. %b"
                    },
                    month: {
                        main: "%b '%y"
                    },
                    year: {
                        main: "%Y"
                    }
                },
                endOnTick: !1,
                gridLineDashStyle: "Solid",
                gridZIndex: 1,
                labels: {
                    autoRotation: void 0,
                    autoRotationLimit: 80,
                    distance: void 0,
                    enabled: !0,
                    indentation: 10,
                    overflow: "justify",
                    padding: 5,
                    reserveSpace: void 0,
                    rotation: void 0,
                    staggerLines: 0,
                    step: 0,
                    useHTML: !1,
                    x: 0,
                    zIndex: 7,
                    style: {
                        color: "#666666",
                        cursor: "default",
                        fontSize: "11px"
                    }
                },
                maxPadding: .01,
                minorGridLineDashStyle: "Solid",
                minorTickLength: 2,
                minorTickPosition: "outside",
                minPadding: .01,
                offset: void 0,
                opposite: !1,
                reversed: void 0,
                reversedStacks: !1,
                showEmpty: !0,
                showFirstLabel: !0,
                showLastLabel: !0,
                startOfWeek: 1,
                startOnTick: !1,
                tickLength: 10,
                tickPixelInterval: 100,
                tickmarkPlacement: "between",
                tickPosition: "outside",
                title: {
                    align: "middle",
                    rotation: 0,
                    useHTML: !1,
                    x: 0,
                    y: 0,
                    style: {
                        color: "#666666"
                    }
                },
                type: "linear",
                uniqueNames: !0,
                visible: !0,
                minorGridLineColor: "#f2f2f2",
                minorGridLineWidth: 1,
                minorTickColor: "#999999",
                lineColor: "#ccd6eb",
                lineWidth: 1,
                gridLineColor: "#e6e6e6",
                gridLineWidth: void 0,
                tickColor: "#ccd6eb"
            };
            a.defaultYAxisOptions = {
                reversedStacks: !0,
                endOnTick: !0,
                maxPadding: .05,
                minPadding: .05,
                tickPixelInterval: 72,
                showLastLabel: !0,
                labels: {
                    x: -8
                },
                startOnTick: !0,
                title: {
                    rotation: 270,
                    text: "Values"
                },
                stackLabels: {
                    animation: {},
                    allowOverlap: !1,
                    enabled: !1,
                    crop: !0,
                    overflow: "justify",
                    formatter: function () {
                        var a = this.axis.chart.numberFormatter;
                        return a(this.total, -1);
                    },
                    style: {
                        color: "#000000",
                        fontSize: "11px",
                        fontWeight: "bold",
                        textOutline: "1px contrast"
                    }
                },
                gridLineWidth: 1,
                lineWidth: 0
            };
            a.defaultLeftAxisOptions = {
                labels: {
                    x: -15
                },
                title: {
                    rotation: 270
                }
            };
            a.defaultRightAxisOptions = {
                labels: {
                    x: 15
                },
                title: {
                    rotation: 90
                }
            };
            a.defaultBottomAxisOptions = {
                labels: {
                    autoRotation: [-45],
                    x: 0
                },
                margin: 15,
                title: {
                    rotation: 0
                }
            };
            a.defaultTopAxisOptions = {
                labels: {
                    autoRotation: [-45],
                    x: 0
                },
                margin: 15,
                title: {
                    rotation: 0
                }
            };
        }(a || (a = {}));
        return a;
    });
    b(c, "Core/Foundation.js", [c["Core/Utilities.js"]], function (a) {
        var b = a.addEvent, c = a.isFunction, d = a.objectEach, e = a.removeEvent, f;
        !function (a) {
            a.registerEventOptions = function (a, f) {
                a.eventOptions = a.eventOptions || {};
                d(f.events, function (d, f) {
                    a.eventOptions[f] !== d && (a.eventOptions[f] && (e(a, f, a.eventOptions[f]), delete a.eventOptions[f]),
                        c(d) && (a.eventOptions[f] = d, b(a, f, d)));
                });
            };
        }(f || (f = {}));
        return f;
    });
    b(c, "Core/Axis/Tick.js", [c["Core/FormatUtilities.js"], c["Core/Globals.js"], c["Core/Utilities.js"]], function (a, b, c) {
        var d = b.deg2rad, e = c.clamp, f = c.correctFloat, g = c.defined, h = c.destroyObjectProperties, i = c.extend, j = c.fireEvent, k = c.isNumber, l = c.merge, m = c.objectEach, n = c.pick;
        b = function () {
            function b(a, b, c, d, e) {
                this.isNewLabel = this.isNew = !0;
                this.axis = a;
                this.pos = b;
                this.type = c || "";
                this.parameters = e || {};
                this.tickmarkOffset = this.parameters.tickmarkOffset;
                this.options = this.parameters.options;
                j(this, "init");
                c || d || this.addLabel();
            }
            b.prototype.addLabel = function () {
                var b = this, c = b.axis, d = c.options, e = c.chart, h = c.categories, l = c.logarithmic, m = c.names, o = b.pos, p = n(b.options && b.options.labels, d.labels), q = c.tickPositions, r = o === q[0], s = o === q[q.length - 1], t = (!p.step || 1 === p.step) && 1 === c.tickInterval;
                q = q.info;
                var u = b.label, v;
                h = this.parameters.category || (h ? n(h[o], m[o], o) : o);
                l && k(h) && (h = f(l.lin2log(h)));
                if (c.dateTime) if (q) {
                    var w = e.time.resolveDTLFormat(d.dateTimeLabelFormats[!d.grid && q.higherRanks[o] || q.unitName]);
                    var x = w.main;
                } else k(h) && (x = c.dateTime.getXDateFormat(h, d.dateTimeLabelFormats || {}));
                b.isFirst = r;
                b.isLast = s;
                var y = {
                    axis: c,
                    chart: e,
                    dateTimeLabelFormat: x,
                    isFirst: r,
                    isLast: s,
                    pos: o,
                    tick: b,
                    tickPositionInfo: q,
                    value: h
                };
                j(this, "labelFormat", y);
                var z = function (b) {
                    return p.formatter ? p.formatter.call(b, b) : p.format ? (b.text = c.defaultLabelFormatter.call(b),
                        a.format(p.format, b, e)) : c.defaultLabelFormatter.call(b, b);
                };
                d = z.call(y, y);
                var A = w && w.list;
                b.shortenLabel = A ? function () {
                    for (v = 0; v < A.length; v++) if (i(y, {
                        dateTimeLabelFormat: A[v]
                    }), u.attr({
                        text: z.call(y, y)
                    }), u.getBBox().width < c.getSlotWidth(b) - 2 * p.padding) return;
                    u.attr({
                        text: ""
                    });
                } : void 0;
                t && c._addedPlotLB && b.moveLabel(d, p);
                g(u) || b.movedLabel ? u && u.textStr !== d && !t && (!u.textWidth || p.style.width || u.styles.width || u.css({
                    width: null
                }), u.attr({
                    text: d
                }), u.textPxLength = u.getBBox().width) : (b.label = u = b.createLabel({
                    x: 0,
                    y: 0
                }, d, p), b.rotation = 0);
            };
            b.prototype.createLabel = function (a, b, c) {
                var d = this.axis, e = d.chart;
                if (a = g(b) && c.enabled ? e.renderer.text(b, a.x, a.y, c.useHTML).add(d.labelGroup) : null) e.styledMode || a.css(l(c.style)),
                    a.textPxLength = a.getBBox().width;
                return a;
            };
            b.prototype.destroy = function () {
                h(this, this.axis);
            };
            b.prototype.getPosition = function (a, b, c, d) {
                var g = this.axis, h = g.chart, i = d && h.oldChartHeight || h.chartHeight;
                a = {
                    x: a ? f(g.translate(b + c, null, null, d) + g.transB) : g.left + g.offset + (g.opposite ? (d && h.oldChartWidth || h.chartWidth) - g.right - g.left : 0),
                    y: a ? i - g.bottom + g.offset - (g.opposite ? g.height : 0) : f(i - g.translate(b + c, null, null, d) - g.transB)
                };
                a.y = e(a.y, -1e5, 1e5);
                j(this, "afterGetPosition", {
                    pos: a
                });
                return a;
            };
            b.prototype.getLabelPosition = function (a, b, c, e, f, h, i, k) {
                var l = this.axis, m = l.transA, n = l.isLinked && l.linkedParent ? l.linkedParent.reversed : l.reversed, o = l.staggerLines, p = l.tickRotCorr || {
                    x: 0,
                    y: 0
                }, q = e || l.reserveSpaceDefault ? 0 : -l.labelOffset * ("center" === l.labelAlign ? .5 : 1), r = {}, s = f.y;
                g(s) || (s = 0 === l.side ? c.rotation ? -8 : -c.getBBox().height : 2 === l.side ? p.y + 8 : Math.cos(c.rotation * d) * (p.y - c.getBBox(!1, 0).height / 2));
                a = a + f.x + q + p.x - (h && e ? h * m * (n ? -1 : 1) : 0);
                b = b + s - (h && !e ? h * m * (n ? 1 : -1) : 0);
                o && (c = i / (k || 1) % o, l.opposite && (c = o - c - 1), b += l.labelOffset / o * c);
                r.x = a;
                r.y = Math.round(b);
                j(this, "afterGetLabelPosition", {
                    pos: r,
                    tickmarkOffset: h,
                    index: i
                });
                return r;
            };
            b.prototype.getLabelSize = function () {
                return this.label ? this.label.getBBox()[this.axis.horiz ? "height" : "width"] : 0;
            };
            b.prototype.getMarkPath = function (a, b, c, d, e, f) {
                return f.crispLine([["M", a, b], ["L", a + (e ? 0 : -c), b + (e ? c : 0)]], d);
            };
            b.prototype.handleOverflow = function (a) {
                var b = this.axis, c = b.options.labels, e = a.x, f = b.chart.chartWidth, g = b.chart.spacing, h = n(b.labelLeft, Math.min(b.pos, g[3]));
                g = n(b.labelRight, Math.max(b.isRadial ? 0 : b.pos + b.len, f - g[1]));
                var i = this.label, j = this.rotation, k = {
                    left: 0,
                    center: .5,
                    right: 1
                }[b.labelAlign || i.attr("align")], l = i.getBBox().width, m = b.getSlotWidth(this), o = {}, p = m, q = 1, r;
                if (j || "justify" !== c.overflow) 0 > j && e - k * l < h ? r = Math.round(e / Math.cos(j * d) - h) : 0 < j && e + k * l > g && (r = Math.round((f - e) / Math.cos(j * d))); else if (f = e + (1 - k) * l,
                    e - k * l < h ? p = a.x + p * (1 - k) - h : f > g && (p = g - a.x + p * k, q = -1),
                    p = Math.min(m, p), p < m && "center" === b.labelAlign && (a.x += q * (m - p - k * (m - Math.min(l, p)))),
                    l > p || b.autoRotation && (i.styles || {}).width) r = p;
                r && (this.shortenLabel ? this.shortenLabel() : (o.width = Math.floor(r) + "px",
                    (c.style || {}).textOverflow || (o.textOverflow = "ellipsis"), i.css(o)));
            };
            b.prototype.moveLabel = function (a, b) {
                var c = this, d = c.label, e = c.axis, f = e.reversed, g = !1;
                d && d.textStr === a ? (c.movedLabel = d, g = !0, delete c.label) : m(e.ticks, function (b) {
                    g || b.isNew || b === c || !b.label || b.label.textStr !== a || (c.movedLabel = b.label,
                        g = !0, b.labelPos = c.movedLabel.xy, delete b.label);
                });
                if (!g && (c.labelPos || d)) {
                    var h = c.labelPos || d.xy;
                    d = e.horiz ? f ? 0 : e.width + e.left : h.x;
                    e = e.horiz ? h.y : f ? e.width + e.left : 0;
                    c.movedLabel = c.createLabel({
                        x: d,
                        y: e
                    }, a, b);
                    c.movedLabel && c.movedLabel.attr({
                        opacity: 0
                    });
                }
            };
            b.prototype.render = function (a, b, c) {
                var d = this.axis, e = d.horiz, f = this.pos, g = n(this.tickmarkOffset, d.tickmarkOffset);
                f = this.getPosition(e, f, g, b);
                g = f.x;
                var h = f.y;
                d = e && g === d.pos + d.len || !e && h === d.pos ? -1 : 1;
                e = n(c, this.label && this.label.newOpacity, 1);
                c = n(c, 1);
                this.isActive = !0;
                this.renderGridLine(b, c, d);
                this.renderMark(f, c, d);
                this.renderLabel(f, b, e, a);
                this.isNew = !1;
                j(this, "afterRender");
            };
            b.prototype.renderGridLine = function (a, b, c) {
                var d = this.axis, e = d.options, f = {}, g = this.pos, h = this.type, i = n(this.tickmarkOffset, d.tickmarkOffset), j = d.chart.renderer, k = this.gridLine, l = e.gridLineWidth, m = e.gridLineColor, o = e.gridLineDashStyle;
                "minor" === this.type && (l = e.minorGridLineWidth, m = e.minorGridLineColor, o = e.minorGridLineDashStyle);
                k || (d.chart.styledMode || (f.stroke = m, f["stroke-width"] = l || 0, f.dashstyle = o),
                    h || (f.zIndex = 1), a && (b = 0), this.gridLine = k = j.path().attr(f).addClass("highcharts-" + (h ? h + "-" : "") + "grid-line").add(d.gridGroup));
                if (k && (c = d.getPlotLinePath({
                    value: g + i,
                    lineWidth: k.strokeWidth() * c,
                    force: "pass",
                    old: a
                }))) k[a || this.isNew ? "attr" : "animate"]({
                    d: c,
                    opacity: b
                });
            };
            b.prototype.renderMark = function (a, b, c) {
                var d = this.axis, e = d.options, f = d.chart.renderer, g = this.type, h = d.tickSize(g ? g + "Tick" : "tick"), i = a.x;
                a = a.y;
                var j = n(e["minor" !== g ? "tickWidth" : "minorTickWidth"], !g && d.isXAxis ? 1 : 0);
                e = e["minor" !== g ? "tickColor" : "minorTickColor"];
                var k = this.mark, l = !k;
                h && (d.opposite && (h[0] = -h[0]), k || (this.mark = k = f.path().addClass("highcharts-" + (g ? g + "-" : "") + "tick").add(d.axisGroup),
                    d.chart.styledMode || k.attr({
                        stroke: e,
                        "stroke-width": j
                    })), k[l ? "attr" : "animate"]({
                        d: this.getMarkPath(i, a, h[0], k.strokeWidth() * c, d.horiz, f),
                        opacity: b
                    }));
            };
            b.prototype.renderLabel = function (a, b, c, d) {
                var e = this.axis, f = e.horiz, g = e.options, h = this.label, i = g.labels, j = i.step;
                e = n(this.tickmarkOffset, e.tickmarkOffset);
                var l = a.x;
                a = a.y;
                var m = !0;
                h && k(l) && (h.xy = a = this.getLabelPosition(l, a, h, f, i, e, d, j), this.isFirst && !this.isLast && !g.showFirstLabel || this.isLast && !this.isFirst && !g.showLastLabel ? m = !1 : !f || i.step || i.rotation || b || 0 === c || this.handleOverflow(a),
                    j && d % j && (m = !1), m && k(a.y) ? (a.opacity = c, h[this.isNewLabel ? "attr" : "animate"](a),
                        this.isNewLabel = !1) : (h.attr("y", -9999), this.isNewLabel = !0));
            };
            b.prototype.replaceMovedLabel = function () {
                var a = this.label, b = this.axis, c = b.reversed;
                if (a && !this.isNew) {
                    var d = b.horiz ? c ? b.left : b.width + b.left : a.xy.x;
                    c = b.horiz ? a.xy.y : c ? b.width + b.top : b.top;
                    a.animate({
                        x: d,
                        y: c,
                        opacity: 0
                    }, void 0, a.destroy);
                    delete this.label;
                }
                b.isDirty = !0;
                this.label = this.movedLabel;
                delete this.movedLabel;
            };
            return b;
        }();
        return b;
    });
    b(c, "Core/Axis/Axis.js", [c["Core/Animation/AnimationUtilities.js"], c["Core/Axis/AxisDefaults.js"], c["Core/Color/Color.js"], c["Core/DefaultOptions.js"], c["Core/Foundation.js"], c["Core/Globals.js"], c["Core/Axis/Tick.js"], c["Core/Utilities.js"]], function (a, b, c, d, e, f, g, h) {
        var i = a.animObject, j = d.defaultOptions, k = e.registerEventOptions, l = f.deg2rad, m = h.arrayMax, n = h.arrayMin, o = h.clamp, p = h.correctFloat, q = h.defined, r = h.destroyObjectProperties, s = h.erase, t = h.error, u = h.extend, v = h.fireEvent, w = h.getMagnitude, x = h.isArray, y = h.isNumber, z = h.isString, A = h.merge, B = h.normalizeTickInterval, C = h.objectEach, D = h.pick, E = h.relativeLength, F = h.removeEvent, G = h.splat, H = h.syncTimeout;
        a = function () {
            function a(a, b) {
                this.zoomEnabled = this.width = this.visible = this.userOptions = this.translationSlope = this.transB = this.transA = this.top = this.ticks = this.tickRotCorr = this.tickPositions = this.tickmarkOffset = this.tickInterval = this.tickAmount = this.side = this.series = this.right = this.positiveValuesOnly = this.pos = this.pointRangePadding = this.pointRange = this.plotLinesAndBandsGroups = this.plotLinesAndBands = this.paddedTicks = this.overlap = this.options = this.offset = this.names = this.minPixelPadding = this.minorTicks = this.minorTickInterval = this.min = this.maxLabelLength = this.max = this.len = this.left = this.labelFormatter = this.labelEdge = this.isLinked = this.height = this.hasVisibleSeries = this.hasNames = this.eventOptions = this.coll = this.closestPointRange = this.chart = this.bottom = this.alternateBands = void 0;
                this.init(a, b);
            }
            a.prototype.init = function (a, b) {
                var c = b.isX;
                this.chart = a;
                this.horiz = a.inverted && !this.isZAxis ? !c : c;
                this.isXAxis = c;
                this.coll = this.coll || (c ? "xAxis" : "yAxis");
                v(this, "init", {
                    userOptions: b
                });
                this.opposite = D(b.opposite, this.opposite);
                this.side = D(b.side, this.side, this.horiz ? this.opposite ? 0 : 2 : this.opposite ? 1 : 3);
                this.setOptions(b);
                var d = this.options, e = d.labels, f = d.type;
                this.userOptions = b;
                this.minPixelPadding = 0;
                this.reversed = D(d.reversed, this.reversed);
                this.visible = d.visible;
                this.zoomEnabled = d.zoomEnabled;
                this.hasNames = "category" === f || !0 === d.categories;
                this.categories = d.categories || (this.hasNames ? [] : void 0);
                this.names || (this.names = [], this.names.keys = {});
                this.plotLinesAndBandsGroups = {};
                this.positiveValuesOnly = !!this.logarithmic;
                this.isLinked = q(d.linkedTo);
                this.ticks = {};
                this.labelEdge = [];
                this.minorTicks = {};
                this.plotLinesAndBands = [];
                this.alternateBands = {};
                this.len = 0;
                this.minRange = this.userMinRange = d.minRange || d.maxZoom;
                this.range = d.range;
                this.offset = d.offset || 0;
                this.min = this.max = null;
                b = D(d.crosshair, G(a.options.tooltip.crosshairs)[c ? 0 : 1]);
                this.crosshair = !0 === b ? {} : b;
                -1 === a.axes.indexOf(this) && (c ? a.axes.splice(a.xAxis.length, 0, this) : a.axes.push(this),
                    a[this.coll].push(this));
                this.series = this.series || [];
                a.inverted && !this.isZAxis && c && "undefined" === typeof this.reversed && (this.reversed = !0);
                this.labelRotation = y(e.rotation) ? e.rotation : void 0;
                k(this, d);
                v(this, "afterInit");
            };
            a.prototype.setOptions = function (a) {
                this.options = A(b.defaultXAxisOptions, "yAxis" === this.coll && b.defaultYAxisOptions, [b.defaultTopAxisOptions, b.defaultRightAxisOptions, b.defaultBottomAxisOptions, b.defaultLeftAxisOptions][this.side], A(j[this.coll], a));
                v(this, "afterSetOptions", {
                    userOptions: a
                });
            };
            a.prototype.defaultLabelFormatter = function (a) {
                var b = this.axis;
                a = this.chart.numberFormatter;
                var c = y(this.value) ? this.value : 0 / 0, d = b.chart.time, e = this.dateTimeLabelFormat, f = j.lang, g = f.numericSymbols;
                f = f.numericSymbolMagnitude || 1e3;
                var h = b.logarithmic ? Math.abs(c) : b.tickInterval, i = g && g.length;
                if (b.categories) var k = "" + this.value; else if (e) k = d.dateFormat(e, c); else if (i && 1e3 <= h) for (; i-- && "undefined" === typeof k;) b = Math.pow(f, i + 1),
                    h >= b && 0 === 10 * c % b && null !== g[i] && 0 !== c && (k = a(c / b, -1) + g[i]);
                "undefined" === typeof k && (k = 1e4 <= Math.abs(c) ? a(c, -1) : a(c, -1, void 0, ""));
                return k;
            };
            a.prototype.getSeriesExtremes = function () {
                var a = this, b = a.chart, c;
                v(this, "getSeriesExtremes", null, function () {
                    a.hasVisibleSeries = !1;
                    a.dataMin = a.dataMax = a.threshold = null;
                    a.softThreshold = !a.isXAxis;
                    a.stacking && a.stacking.buildStacks();
                    a.series.forEach(function (d) {
                        if (d.visible || !b.options.chart.ignoreHiddenSeries) {
                            var e = d.options, f = e.threshold;
                            a.hasVisibleSeries = !0;
                            a.positiveValuesOnly && 0 >= f && (f = null);
                            if (a.isXAxis) {
                                if (e = d.xData, e.length) {
                                    e = a.logarithmic ? e.filter(a.validatePositiveValue) : e;
                                    c = d.getXExtremes(e);
                                    var g = c.min;
                                    var h = c.max;
                                    y(g) || g instanceof Date || (e = e.filter(y), c = d.getXExtremes(e), g = c.min,
                                        h = c.max);
                                    e.length && (a.dataMin = Math.min(D(a.dataMin, g), g), a.dataMax = Math.max(D(a.dataMax, h), h));
                                }
                            } else if (d = d.applyExtremes(), y(d.dataMin) && (g = d.dataMin, a.dataMin = Math.min(D(a.dataMin, g), g)),
                                y(d.dataMax) && (h = d.dataMax, a.dataMax = Math.max(D(a.dataMax, h), h)), q(f) && (a.threshold = f),
                                !e.softThreshold || a.positiveValuesOnly) a.softThreshold = !1;
                        }
                    });
                });
                v(this, "afterGetSeriesExtremes");
            };
            a.prototype.translate = function (a, b, c, d, e, f) {
                var g = this.linkedParent || this, h = d && g.old ? g.old.min : g.min, i = g.minPixelPadding;
                e = (g.isOrdinal || g.brokenAxis && g.brokenAxis.hasBreaks || g.logarithmic && e) && g.lin2val;
                var j = 1, k = 0;
                d = d && g.old ? g.old.transA : g.transA;
                d || (d = g.transA);
                c && (j *= -1, k = g.len);
                g.reversed && (j *= -1, k -= j * (g.sector || g.len));
                b ? (f = (a * j + k - i) / d + h, e && (f = g.lin2val(f))) : (e && (a = g.val2lin(a)),
                    a = j * (a - h) * d, f = y(h) ? (g.isRadial ? a : p(a)) + k + j * i + (y(f) ? d * f : 0) : void 0);
                return f;
            };
            a.prototype.toPixels = function (a, b) {
                return this.translate(a, !1, !this.horiz, null, !0) + (b ? 0 : this.pos);
            };
            a.prototype.toValue = function (a, b) {
                return this.translate(a - (b ? 0 : this.pos), !0, !this.horiz, null, !0);
            };
            a.prototype.getPlotLinePath = function (a) {
                function b(a, b, c) {
                    if ("pass" !== n && a < b || a > c) n ? a = o(a, b, c) : t = !0;
                    return a;
                }
                var c = this, d = c.chart, e = c.left, f = c.top, g = a.old, h = a.value, i = a.lineWidth, j = g && d.oldChartHeight || d.chartHeight, k = g && d.oldChartWidth || d.chartWidth, l = c.transB, m = a.translatedValue, n = a.force, p, q, r, s, t;
                a = {
                    value: h,
                    lineWidth: i,
                    old: g,
                    force: n,
                    acrossPanes: a.acrossPanes,
                    translatedValue: m
                };
                v(this, "getPlotLinePath", a, function (a) {
                    m = D(m, c.translate(h, null, null, g));
                    m = o(m, -1e5, 1e5);
                    p = r = Math.round(m + l);
                    q = s = Math.round(j - m - l);
                    y(m) ? c.horiz ? (q = f, s = j - c.bottom, p = r = b(p, e, e + c.width)) : (p = e,
                        r = k - c.right, q = s = b(q, f, f + c.height)) : (t = !0, n = !1);
                    a.path = t && !n ? null : d.renderer.crispLine([["M", p, q], ["L", r, s]], i || 1);
                });
                return a.path;
            };
            a.prototype.getLinearTickPositions = function (a, b, c) {
                var d = p(Math.floor(b / a) * a);
                c = p(Math.ceil(c / a) * a);
                var e = [], f;
                p(d + a) === d && (f = 20);
                if (this.single) return [b];
                for (b = d; b <= c;) {
                    e.push(b);
                    b = p(b + a, f);
                    if (b === g) break;
                    var g = b;
                }
                return e;
            };
            a.prototype.getMinorTickInterval = function () {
                var a = this.options;
                return !0 === a.minorTicks ? D(a.minorTickInterval, "auto") : !1 === a.minorTicks ? null : a.minorTickInterval;
            };
            a.prototype.getMinorTickPositions = function () {
                var a = this.options, b = this.tickPositions, c = this.minorTickInterval, d = this.pointRangePadding || 0, e = this.min - d;
                d = this.max + d;
                var f = d - e, g = [];
                if (f && f / c < this.len / 3) {
                    var h = this.logarithmic;
                    if (h) this.paddedTicks.forEach(function (a, b, d) {
                        b && g.push.apply(g, h.getLogTickPositions(c, d[b - 1], d[b], !0));
                    }); else if (this.dateTime && "auto" === this.getMinorTickInterval()) g = g.concat(this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(c), e, d, a.startOfWeek)); else for (a = e + (b[0] - e) % c; a <= d && a !== g[0]; a += c) g.push(a);
                }
                0 !== g.length && this.trimTicks(g);
                return g;
            };
            a.prototype.adjustForMinRange = function () {
                var a = this.options, b = this.logarithmic, c = this.min, d = this.max, e = 0, f, g, h, i;
                this.isXAxis && "undefined" === typeof this.minRange && !b && (q(a.min) || q(a.max) || q(a.floor) || q(a.ceiling) ? this.minRange = null : (this.series.forEach(function (a) {
                    h = a.xData;
                    i = a.xIncrement ? 1 : h.length - 1;
                    if (1 < h.length) for (f = i; 0 < f; f--) if (g = h[f] - h[f - 1], !e || g < e) e = g;
                }), this.minRange = Math.min(5 * e, this.dataMax - this.dataMin)));
                if (d - c < this.minRange) {
                    var j = this.dataMax - this.dataMin >= this.minRange;
                    var k = this.minRange;
                    var l = (k - d + c) / 2;
                    l = [c - l, D(a.min, c - l)];
                    j && (l[2] = this.logarithmic ? this.logarithmic.log2lin(this.dataMin) : this.dataMin);
                    c = m(l);
                    d = [c + k, D(a.max, c + k)];
                    j && (d[2] = b ? b.log2lin(this.dataMax) : this.dataMax);
                    d = n(d);
                    d - c < k && (l[0] = d - k, l[1] = D(a.min, d - k), c = m(l));
                }
                this.min = c;
                this.max = d;
            };
            a.prototype.getClosest = function () {
                var a;
                this.categories ? a = 1 : this.series.forEach(function (b) {
                    var c = b.closestPointRange, d = b.visible || !b.chart.options.chart.ignoreHiddenSeries;
                    !b.noSharedTooltip && q(c) && d && (a = q(a) ? Math.min(a, c) : c);
                });
                return a;
            };
            a.prototype.nameToX = function (a) {
                var b = x(this.options.categories), c = b ? this.categories : this.names, d = a.options.x;
                a.series.requireSorting = !1;
                q(d) || (d = this.options.uniqueNames && c ? b ? c.indexOf(a.name) : D(c.keys[a.name], -1) : a.series.autoIncrement());
                if (-1 === d) {
                    if (!b && c) var e = c.length;
                } else e = d;
                "undefined" !== typeof e && (this.names[e] = a.name, this.names.keys[a.name] = e);
                return e;
            };
            a.prototype.updateNames = function () {
                var a = this, b = this.names;
                0 < b.length && (Object.keys(b.keys).forEach(function (a) {
                    delete b.keys[a];
                }), b.length = 0, this.minRange = this.userMinRange, (this.series || []).forEach(function (b) {
                    b.xIncrement = null;
                    if (!b.points || b.isDirtyData) a.max = Math.max(a.max, b.xData.length - 1), b.processData(),
                        b.generatePoints();
                    b.data.forEach(function (c, d) {
                        if (c && c.options && "undefined" !== typeof c.name) {
                            var e = a.nameToX(c);
                            "undefined" !== typeof e && e !== c.x && (c.x = e, b.xData[d] = e);
                        }
                    });
                }));
            };
            a.prototype.setAxisTranslation = function () {
                var a = this, b = a.max - a.min, c = a.linkedParent, d = !!a.categories, e = a.isXAxis, f = a.axisPointRange || 0, g = 0, h = 0, i = a.transA;
                if (e || d || f) {
                    var j = a.getClosest();
                    c ? (g = c.minPointOffset, h = c.pointRangePadding) : a.series.forEach(function (b) {
                        var c = d ? 1 : e ? D(b.options.pointRange, j, 0) : a.axisPointRange || 0, i = b.options.pointPlacement;
                        f = Math.max(f, c);
                        if (!a.single || d) b = b.is("xrange") ? !e : e, g = Math.max(g, b && z(i) ? 0 : c / 2),
                            h = Math.max(h, b && "on" === i ? 0 : c);
                    });
                    c = a.ordinal && a.ordinal.slope && j ? a.ordinal.slope / j : 1;
                    a.minPointOffset = g *= c;
                    a.pointRangePadding = h *= c;
                    a.pointRange = Math.min(f, a.single && d ? 1 : b);
                    e && (a.closestPointRange = j);
                }
                a.translationSlope = a.transA = i = a.staticScale || a.len / (b + h || 1);
                a.transB = a.horiz ? a.left : a.bottom;
                a.minPixelPadding = i * g;
                v(this, "afterSetAxisTranslation");
            };
            a.prototype.minFromRange = function () {
                return this.max - this.range;
            };
            a.prototype.setTickInterval = function (a) {
                var b = this.chart, c = this.logarithmic, d = this.options, e = this.isXAxis, f = this.isLinked, g = d.tickPixelInterval, h = this.categories, i = this.softThreshold, j = d.maxPadding, k = d.minPadding, l = y(d.tickInterval) && 0 <= d.tickInterval ? d.tickInterval : void 0, m = y(this.threshold) ? this.threshold : null;
                this.dateTime || h || f || this.getTickAmount();
                var n = D(this.userMin, d.min);
                var o = D(this.userMax, d.max);
                if (f) {
                    this.linkedParent = b[this.coll][d.linkedTo];
                    var r = this.linkedParent.getExtremes();
                    this.min = D(r.min, r.dataMin);
                    this.max = D(r.max, r.dataMax);
                    d.type !== this.linkedParent.options.type && t(11, 1, b);
                } else {
                    if (i && q(m)) if (this.dataMin >= m) r = m, k = 0; else if (this.dataMax <= m) {
                        var s = m;
                        j = 0;
                    }
                    this.min = D(n, r, this.dataMin);
                    this.max = D(o, s, this.dataMax);
                }
                c && (this.positiveValuesOnly && !a && 0 >= Math.min(this.min, D(this.dataMin, this.min)) && t(10, 1, b),
                    this.min = p(c.log2lin(this.min), 16), this.max = p(c.log2lin(this.max), 16));
                this.range && q(this.max) && (this.userMin = this.min = n = Math.max(this.dataMin, this.minFromRange()),
                    this.userMax = o = this.max, this.range = null);
                v(this, "foundExtremes");
                this.beforePadding && this.beforePadding();
                this.adjustForMinRange();
                !(h || this.axisPointRange || this.stacking && this.stacking.usePercentage || f) && q(this.min) && q(this.max) && (b = this.max - this.min) && (!q(n) && k && (this.min -= b * k),
                    !q(o) && j && (this.max += b * j));
                y(this.userMin) || (y(d.softMin) && d.softMin < this.min && (this.min = n = d.softMin),
                    y(d.floor) && (this.min = Math.max(this.min, d.floor)));
                y(this.userMax) || (y(d.softMax) && d.softMax > this.max && (this.max = o = d.softMax),
                    y(d.ceiling) && (this.max = Math.min(this.max, d.ceiling)));
                i && q(this.dataMin) && (m = m || 0, !q(n) && this.min < m && this.dataMin >= m ? this.min = this.options.minRange ? Math.min(m, this.max - this.minRange) : m : !q(o) && this.max > m && this.dataMax <= m && (this.max = this.options.minRange ? Math.max(m, this.min + this.minRange) : m));
                y(this.min) && y(this.max) && !this.chart.polar && this.min > this.max && (q(this.options.min) ? this.max = this.min : q(this.options.max) && (this.min = this.max));
                this.tickInterval = this.min === this.max || "undefined" === typeof this.min || "undefined" === typeof this.max ? 1 : f && this.linkedParent && !l && g === this.linkedParent.options.tickPixelInterval ? l = this.linkedParent.tickInterval : D(l, this.tickAmount ? (this.max - this.min) / Math.max(this.tickAmount - 1, 1) : void 0, h ? 1 : (this.max - this.min) * g / Math.max(this.len, g));
                if (e && !a) {
                    var u = this.min !== (this.old && this.old.min) || this.max !== (this.old && this.old.max);
                    this.series.forEach(function (a) {
                        a.forceCrop = a.forceCropping && a.forceCropping();
                        a.processData(u);
                    });
                    v(this, "postProcessData", {
                        hasExtemesChanged: u
                    });
                }
                this.setAxisTranslation();
                v(this, "initialAxisTranslation");
                this.pointRange && !l && (this.tickInterval = Math.max(this.pointRange, this.tickInterval));
                a = D(d.minTickInterval, this.dateTime && !this.series.some(function (a) {
                    return a.noSharedTooltip;
                }) ? this.closestPointRange : 0);
                !l && this.tickInterval < a && (this.tickInterval = a);
                this.dateTime || this.logarithmic || l || (this.tickInterval = B(this.tickInterval, void 0, w(this.tickInterval), D(d.allowDecimals, .5 > this.tickInterval || void 0 !== this.tickAmount), !!this.tickAmount));
                this.tickAmount || (this.tickInterval = this.unsquish());
                this.setTickPositions();
            };
            a.prototype.setTickPositions = function () {
                var a = this.options, b = a.tickPositions, c = this.getMinorTickInterval(), d = this.hasVerticalPanning(), e = "colorAxis" === this.coll, f = (e || !d) && a.startOnTick;
                d = (e || !d) && a.endOnTick;
                e = a.tickPositioner;
                this.tickmarkOffset = this.categories && "between" === a.tickmarkPlacement && 1 === this.tickInterval ? .5 : 0;
                this.minorTickInterval = "auto" === c && this.tickInterval ? this.tickInterval / 5 : c;
                this.single = this.min === this.max && q(this.min) && !this.tickAmount && (parseInt(this.min, 10) === this.min || !1 !== a.allowDecimals);
                this.tickPositions = c = b && b.slice();
                !c && (this.ordinal && this.ordinal.positions || !((this.max - this.min) / this.tickInterval > Math.max(2 * this.len, 200)) ? c = this.dateTime ? this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(this.tickInterval, a.units), this.min, this.max, a.startOfWeek, this.ordinal && this.ordinal.positions, this.closestPointRange, !0) : this.logarithmic ? this.logarithmic.getLogTickPositions(this.tickInterval, this.min, this.max) : this.getLinearTickPositions(this.tickInterval, this.min, this.max) : (c = [this.min, this.max],
                    t(19, !1, this.chart)), c.length > this.len && (c = [c[0], c.pop()], c[0] === c[1] && (c.length = 1)),
                    this.tickPositions = c, e && (e = e.apply(this, [this.min, this.max]))) && (this.tickPositions = c = e);
                this.paddedTicks = c.slice(0);
                this.trimTicks(c, f, d);
                this.isLinked || (this.single && 2 > c.length && !this.categories && !this.series.some(function (a) {
                    return a.is("heatmap") && "between" === a.options.pointPlacement;
                }) && (this.min -= .5, this.max += .5), b || e || this.adjustTickAmount());
                v(this, "afterSetTickPositions");
            };
            a.prototype.trimTicks = function (a, b, c) {
                var d = a[0], e = a[a.length - 1], f = !this.isOrdinal && this.minPointOffset || 0;
                v(this, "trimTicks");
                if (!this.isLinked) {
                    if (b && -1 / 0 !== d) this.min = d; else for (; this.min - f > a[0];) a.shift();
                    if (c) this.max = e; else for (; this.max + f < a[a.length - 1];) a.pop();
                    0 === a.length && q(d) && !this.options.tickPositions && a.push((e + d) / 2);
                }
            };
            a.prototype.alignToOthers = function () {
                var a = this, b = [this], c = a.options, d = "yAxis" === this.coll && this.chart.options.chart.alignThresholds, e = [], f;
                a.thresholdAlignment = void 0;
                if ((!1 !== this.chart.options.chart.alignTicks && c.alignTicks || d) && !1 !== c.startOnTick && !1 !== c.endOnTick && !a.logarithmic) {
                    var g = function (a) {
                        var b = a.options;
                        return [a.horiz ? b.left : b.top, b.width, b.height, b.pane].join();
                    }, h = g(this);
                    this.chart[this.coll].forEach(function (c) {
                        var d = c.series;
                        d.length && d.some(function (a) {
                            return a.visible;
                        }) && c !== a && g(c) === h && (f = !0, b.push(c));
                    });
                }
                if (f && d) {
                    b.forEach(function (b) {
                        b = b.getThresholdAlignment(a);
                        y(b) && e.push(b);
                    });
                    var i = 1 < e.length ? e.reduce(function (a, b) {
                        return a + b;
                    }, 0) / e.length : void 0;
                    b.forEach(function (a) {
                        a.thresholdAlignment = i;
                    });
                }
                return f;
            };
            a.prototype.getThresholdAlignment = function (a) {
                (!y(this.dataMin) || this !== a && this.series.some(function (a) {
                    return a.isDirty || a.isDirtyData;
                })) && this.getSeriesExtremes();
                if (y(this.threshold)) return a = o((this.threshold - (this.dataMin || 0)) / ((this.dataMax || 0) - (this.dataMin || 0)), 0, 1),
                    this.options.reversed && (a = 1 - a), a;
            };
            a.prototype.getTickAmount = function () {
                var a = this.options, b = a.tickPixelInterval, c = a.tickAmount;
                !q(a.tickInterval) && !c && this.len < b && !this.isRadial && !this.logarithmic && a.startOnTick && a.endOnTick && (c = 2);
                !c && this.alignToOthers() && (c = Math.ceil(this.len / b) + 1);
                4 > c && (this.finalTickAmt = c, c = 5);
                this.tickAmount = c;
            };
            a.prototype.adjustTickAmount = function () {
                var a = this, b = a.finalTickAmt, c = a.max, d = a.min, e = a.options, f = a.tickPositions, g = a.tickAmount, h = a.thresholdAlignment, i = f && f.length, j = D(a.threshold, a.softThreshold ? 0 : null);
                var k = a.tickInterval;
                if (y(h)) {
                    var l = .5 > h ? Math.ceil(h * (g - 1)) : Math.floor(h * (g - 1));
                    e.reversed && (l = g - 1 - l);
                }
                if (a.hasData() && y(d) && y(c)) {
                    h = function () {
                        a.transA *= (i - 1) / (g - 1);
                        a.min = e.startOnTick ? f[0] : Math.min(d, f[0]);
                        a.max = e.endOnTick ? f[f.length - 1] : Math.max(c, f[f.length - 1]);
                    };
                    if (y(l) && y(a.threshold)) {
                        for (; f[l] !== j || f.length !== g || f[0] > d || f[f.length - 1] < c;) {
                            f.length = 0;
                            for (f.push(a.threshold); f.length < g;) void 0 === f[l] || f[l] > a.threshold ? f.unshift(p(f[0] - k)) : f.push(p(f[f.length - 1] + k));
                            if (k > 8 * a.tickInterval) break;
                            k *= 2;
                        }
                        h();
                    } else if (i < g) {
                        for (; f.length < g;) f.length % 2 || d === j ? f.push(p(f[f.length - 1] + k)) : f.unshift(p(f[0] - k));
                        h();
                    } else i > g && (a.tickInterval *= 2, a.setTickPositions());
                    if (q(b)) {
                        for (k = j = f.length; k--;) (3 === b && 1 === k % 2 || 2 >= b && 0 < k && k < j - 1) && f.splice(k, 1);
                        a.finalTickAmt = void 0;
                    }
                }
            };
            a.prototype.setScale = function () {
                var a = !1, b = !1;
                this.series.forEach(function (c) {
                    a = a || c.isDirtyData || c.isDirty;
                    b = b || c.xAxis && c.xAxis.isDirty || !1;
                });
                this.setAxisSize();
                var c = this.len !== (this.old && this.old.len);
                c || a || b || this.isLinked || this.forceRedraw || this.userMin !== (this.old && this.old.userMin) || this.userMax !== (this.old && this.old.userMax) || this.alignToOthers() ? (this.stacking && this.stacking.resetStacks(),
                    this.forceRedraw = !1, this.getSeriesExtremes(), this.setTickInterval(), this.isDirty || (this.isDirty = c || this.min !== (this.old && this.old.min) || this.max !== (this.old && this.old.max))) : this.stacking && this.stacking.cleanStacks();
                a && this.panningState && (this.panningState.isDirty = !0);
                v(this, "afterSetScale");
            };
            a.prototype.setExtremes = function (a, b, c, d, e) {
                var f = this, g = f.chart;
                c = D(c, !0);
                f.series.forEach(function (a) {
                    delete a.kdTree;
                });
                e = u(e, {
                    min: a,
                    max: b
                });
                v(f, "setExtremes", e, function () {
                    f.userMin = a;
                    f.userMax = b;
                    f.eventArgs = e;
                    c && g.redraw(d);
                });
            };
            a.prototype.zoom = function (a, b) {
                var c = this, d = this.dataMin, e = this.dataMax, f = this.options, g = Math.min(d, D(f.min, d)), h = Math.max(e, D(f.max, e));
                a = {
                    newMin: a,
                    newMax: b
                };
                v(this, "zoom", a, function (a) {
                    var b = a.newMin, f = a.newMax;
                    if (b !== c.min || f !== c.max) c.allowZoomOutside || (q(d) && (b < g && (b = g),
                        b > h && (b = h)), q(e) && (f < g && (f = g), f > h && (f = h))), c.displayBtn = "undefined" !== typeof b || "undefined" !== typeof f,
                        c.setExtremes(b, f, !1, void 0, {
                            trigger: "zoom"
                        });
                    a.zoomed = !0;
                });
                return a.zoomed;
            };
            a.prototype.setAxisSize = function () {
                var a = this.chart, b = this.options, c = b.offsets || [0, 0, 0, 0], d = this.horiz, e = this.width = Math.round(E(D(b.width, a.plotWidth - c[3] + c[1]), a.plotWidth)), f = this.height = Math.round(E(D(b.height, a.plotHeight - c[0] + c[2]), a.plotHeight)), g = this.top = Math.round(E(D(b.top, a.plotTop + c[0]), a.plotHeight, a.plotTop));
                b = this.left = Math.round(E(D(b.left, a.plotLeft + c[3]), a.plotWidth, a.plotLeft));
                this.bottom = a.chartHeight - f - g;
                this.right = a.chartWidth - e - b;
                this.len = Math.max(d ? e : f, 0);
                this.pos = d ? b : g;
            };
            a.prototype.getExtremes = function () {
                var a = this.logarithmic;
                return {
                    min: a ? p(a.lin2log(this.min)) : this.min,
                    max: a ? p(a.lin2log(this.max)) : this.max,
                    dataMin: this.dataMin,
                    dataMax: this.dataMax,
                    userMin: this.userMin,
                    userMax: this.userMax
                };
            };
            a.prototype.getThreshold = function (a) {
                var b = this.logarithmic, c = b ? b.lin2log(this.min) : this.min;
                b = b ? b.lin2log(this.max) : this.max;
                null === a || -1 / 0 === a ? a = c : 1 / 0 === a ? a = b : c > a ? a = c : b < a && (a = b);
                return this.translate(a, 0, 1, 0, 1);
            };
            a.prototype.autoLabelAlign = function (a) {
                var b = (D(a, 0) - 90 * this.side + 720) % 360;
                a = {
                    align: "center"
                };
                v(this, "autoLabelAlign", a, function (a) {
                    15 < b && 165 > b ? a.align = "right" : 195 < b && 345 > b && (a.align = "left");
                });
                return a.align;
            };
            a.prototype.tickSize = function (a) {
                var b = this.options, c = D(b["tick" === a ? "tickWidth" : "minorTickWidth"], "tick" === a && this.isXAxis && !this.categories ? 1 : 0), d = b["tick" === a ? "tickLength" : "minorTickLength"];
                if (c && d) {
                    "inside" === b[a + "Position"] && (d = -d);
                    var e = [d, c];
                }
                a = {
                    tickSize: e
                };
                v(this, "afterTickSize", a);
                return a.tickSize;
            };
            a.prototype.labelMetrics = function () {
                var a = this.tickPositions && this.tickPositions[0] || 0;
                return this.chart.renderer.fontMetrics(this.options.labels.style.fontSize, this.ticks[a] && this.ticks[a].label);
            };
            a.prototype.unsquish = function () {
                var a = this.options.labels, b = this.horiz, c = this.tickInterval, d = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / c), e = a.rotation, f = this.labelMetrics(), g = Math.max(this.max - this.min, 0), h = function (a) {
                    var b = a / (d || 1);
                    b = 1 < b ? Math.ceil(b) : 1;
                    b * c > g && 1 / 0 !== a && 1 / 0 !== d && g && (b = Math.ceil(g / c));
                    return p(b * c);
                }, i = c, j, k, m = Number.MAX_VALUE;
                if (b) {
                    if (!a.staggerLines && !a.step) if (y(e)) var n = [e]; else d < a.autoRotationLimit && (n = a.autoRotation);
                    n && n.forEach(function (a) {
                        if (a === e || a && -90 <= a && 90 >= a) {
                            k = h(Math.abs(f.h / Math.sin(l * a)));
                            var b = k + Math.abs(a / 360);
                            b < m && (m = b, j = a, i = k);
                        }
                    });
                } else a.step || (i = h(f.h));
                this.autoRotation = n;
                this.labelRotation = D(j, y(e) ? e : 0);
                return i;
            };
            a.prototype.getSlotWidth = function (a) {
                var b = this.chart, c = this.horiz, d = this.options.labels, e = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1), f = b.margin[3];
                if (a && y(a.slotWidth)) return a.slotWidth;
                if (c && 2 > d.step) return d.rotation ? 0 : (this.staggerLines || 1) * this.len / e;
                if (!c) {
                    a = d.style.width;
                    if (void 0 !== a) return parseInt(String(a), 10);
                    if (f) return f - b.spacing[3];
                }
                return .33 * b.chartWidth;
            };
            a.prototype.renderUnsquish = function () {
                var a = this.chart, b = a.renderer, c = this.tickPositions, d = this.ticks, e = this.options.labels, f = e.style, g = this.horiz, h = this.getSlotWidth(), i = Math.max(1, Math.round(h - 2 * e.padding)), j = {}, k = this.labelMetrics(), l = f.textOverflow, m = 0;
                z(e.rotation) || (j.rotation = e.rotation || 0);
                c.forEach(function (a) {
                    a = d[a];
                    a.movedLabel && a.replaceMovedLabel();
                    a && a.label && a.label.textPxLength > m && (m = a.label.textPxLength);
                });
                this.maxLabelLength = m;
                if (this.autoRotation) m > i && m > k.h ? j.rotation = this.labelRotation : this.labelRotation = 0; else if (h) {
                    var n = i;
                    if (!l) {
                        var o = "clip";
                        for (i = c.length; !g && i--;) {
                            var p = c[i];
                            if (p = d[p].label) p.styles && "ellipsis" === p.styles.textOverflow ? p.css({
                                textOverflow: "clip"
                            }) : p.textPxLength > h && p.css({
                                width: h + "px"
                            }), p.getBBox().height > this.len / c.length - (k.h - k.f) && (p.specificTextOverflow = "ellipsis");
                        }
                    }
                }
                j.rotation && (n = m > .5 * a.chartHeight ? .33 * a.chartHeight : m, l || (o = "ellipsis"));
                if (this.labelAlign = e.align || this.autoLabelAlign(this.labelRotation)) j.align = this.labelAlign;
                c.forEach(function (a) {
                    var b = (a = d[a]) && a.label, c = f.width, e = {};
                    b && (b.attr(j), a.shortenLabel ? a.shortenLabel() : n && !c && "nowrap" !== f.whiteSpace && (n < b.textPxLength || "SPAN" === b.element.tagName) ? (e.width = n + "px",
                        l || (e.textOverflow = b.specificTextOverflow || o), b.css(e)) : b.styles && b.styles.width && !e.width && !c && b.css({
                            width: null
                        }), delete b.specificTextOverflow, a.rotation = j.rotation);
                }, this);
                this.tickRotCorr = b.rotCorr(k.b, this.labelRotation || 0, 0 !== this.side);
            };
            a.prototype.hasData = function () {
                return this.series.some(function (a) {
                    return a.hasData();
                }) || this.options.showEmpty && q(this.min) && q(this.max);
            };
            a.prototype.addTitle = function (a) {
                var b = this.chart.renderer, c = this.horiz, d = this.opposite, e = this.options.title, f = this.chart.styledMode, g;
                this.axisTitle || ((g = e.textAlign) || (g = (c ? {
                    low: "left",
                    middle: "center",
                    high: "right"
                } : {
                    low: d ? "right" : "left",
                    middle: "center",
                    high: d ? "left" : "right"
                })[e.align]), this.axisTitle = b.text(e.text || "", 0, 0, e.useHTML).attr({
                    zIndex: 7,
                    rotation: e.rotation,
                    align: g
                }).addClass("highcharts-axis-title"), f || this.axisTitle.css(A(e.style)), this.axisTitle.add(this.axisGroup),
                    this.axisTitle.isNew = !0);
                f || e.style.width || this.isRadial || this.axisTitle.css({
                    width: this.len + "px"
                });
                this.axisTitle[a ? "show" : "hide"](a);
            };
            a.prototype.generateTick = function (a) {
                var b = this.ticks;
                b[a] ? b[a].addLabel() : b[a] = new g(this, a);
            };
            a.prototype.getOffset = function () {
                var a = this, b = this, c = b.chart, d = b.horiz, e = b.options, f = b.side, g = b.ticks, h = b.tickPositions, i = b.coll, j = b.axisParent, k = c.renderer, l = c.inverted && !b.isZAxis ? [1, 0, 3, 2][f] : f, m = b.hasData(), n = e.title, o = e.labels, p = c.axisOffset;
                c = c.clipOffset;
                var r = [-1, 1, 1, -1][f], s = e.className, t, u = 0, w = 0, x = 0;
                b.showAxis = t = m || e.showEmpty;
                b.staggerLines = b.horiz && o.staggerLines || void 0;
                if (!b.axisGroup) {
                    var y = function (b, c, d) {
                        return k.g(b).attr({
                            zIndex: d
                        }).addClass("highcharts-" + i.toLowerCase() + c + " " + (a.isRadial ? "highcharts-radial-axis" + c + " " : "") + (s || "")).add(j);
                    };
                    b.gridGroup = y("grid", "-grid", e.gridZIndex);
                    b.axisGroup = y("axis", "", e.zIndex);
                    b.labelGroup = y("axis-labels", "-labels", o.zIndex);
                }
                m || b.isLinked ? (h.forEach(function (a) {
                    b.generateTick(a);
                }), b.renderUnsquish(), b.reserveSpaceDefault = 0 === f || 2 === f || {
                    1: "left",
                    3: "right"
                }[f] === b.labelAlign, D(o.reserveSpace, "center" === b.labelAlign ? !0 : null, b.reserveSpaceDefault) && h.forEach(function (a) {
                    x = Math.max(g[a].getLabelSize(), x);
                }), b.staggerLines && (x *= b.staggerLines), b.labelOffset = x * (b.opposite ? -1 : 1)) : C(g, function (a, b) {
                    a.destroy();
                    delete g[b];
                });
                if (n && n.text && !1 !== n.enabled && (b.addTitle(t), t && !1 !== n.reserveSpace)) {
                    b.titleOffset = u = b.axisTitle.getBBox()[d ? "height" : "width"];
                    var z = n.offset;
                    w = q(z) ? 0 : D(n.margin, d ? 5 : 10);
                }
                b.renderLine();
                b.offset = r * D(e.offset, p[f] ? p[f] + (e.margin || 0) : 0);
                b.tickRotCorr = b.tickRotCorr || {
                    x: 0,
                    y: 0
                };
                n = 0 === f ? -b.labelMetrics().h : 2 === f ? b.tickRotCorr.y : 0;
                m = Math.abs(x) + w;
                x && (m = m - n + r * (d ? D(o.y, b.tickRotCorr.y + 8 * r) : o.x));
                b.axisTitleMargin = D(z, m);
                b.getMaxLabelDimensions && (b.maxLabelDimensions = b.getMaxLabelDimensions(g, h));
                "colorAxis" !== i && (d = this.tickSize("tick"), p[f] = Math.max(p[f], (b.axisTitleMargin || 0) + u + r * b.offset, m, h && h.length && d ? d[0] + r * b.offset : 0),
                    e = !b.axisLine || e.offset ? 0 : 2 * Math.floor(b.axisLine.strokeWidth() / 2),
                    c[l] = Math.max(c[l], e));
                v(this, "afterGetOffset");
            };
            a.prototype.getLinePath = function (a) {
                var b = this.chart, c = this.opposite, d = this.offset, e = this.horiz, f = this.left + (c ? this.width : 0) + d;
                d = b.chartHeight - this.bottom - (c ? this.height : 0) + d;
                c && (a *= -1);
                return b.renderer.crispLine([["M", e ? this.left : f, e ? d : this.top], ["L", e ? b.chartWidth - this.right : f, e ? d : b.chartHeight - this.bottom]], a);
            };
            a.prototype.renderLine = function () {
                this.axisLine || (this.axisLine = this.chart.renderer.path().addClass("highcharts-axis-line").add(this.axisGroup),
                    this.chart.styledMode || this.axisLine.attr({
                        stroke: this.options.lineColor,
                        "stroke-width": this.options.lineWidth,
                        zIndex: 7
                    }));
            };
            a.prototype.getTitlePosition = function () {
                var a = this.horiz, b = this.left, c = this.top, d = this.len, e = this.options.title, f = a ? b : c, g = this.opposite, h = this.offset, i = e.x, j = e.y, k = this.axisTitle, l = this.chart.renderer.fontMetrics(e.style.fontSize, k);
                k = Math.max(k.getBBox(null, 0).height - l.h - 1, 0);
                d = {
                    low: f + (a ? 0 : d),
                    middle: f + d / 2,
                    high: f + (a ? d : 0)
                }[e.align];
                b = (a ? c + this.height : b) + (a ? 1 : -1) * (g ? -1 : 1) * this.axisTitleMargin + [-k, k, l.f, -k][this.side];
                a = {
                    x: a ? d + i : b + (g ? this.width : 0) + h + i,
                    y: a ? b + j - (g ? this.height : 0) + h : d + j
                };
                v(this, "afterGetTitlePosition", {
                    titlePosition: a
                });
                return a;
            };
            a.prototype.renderMinorTick = function (a, b) {
                var c = this.minorTicks;
                c[a] || (c[a] = new g(this, a, "minor"));
                b && c[a].isNew && c[a].render(null, !0);
                c[a].render(null, !1, 1);
            };
            a.prototype.renderTick = function (a, b, c) {
                var d = this.ticks;
                if (!this.isLinked || a >= this.min && a <= this.max || this.grid && this.grid.isColumn) d[a] || (d[a] = new g(this, a)),
                    c && d[a].isNew && d[a].render(b, !0, -1), d[a].render(b);
            };
            a.prototype.render = function () {
                var a = this, b = a.chart, c = a.logarithmic, d = a.options, e = a.isLinked, h = a.tickPositions, j = a.axisTitle, k = a.ticks, l = a.minorTicks, m = a.alternateBands, n = d.stackLabels, o = d.alternateGridColor, p = a.tickmarkOffset, q = a.axisLine, r = a.showAxis, s = i(b.renderer.globalAnimation), t, u;
                a.labelEdge.length = 0;
                a.overlap = !1;
                [k, l, m].forEach(function (a) {
                    C(a, function (a) {
                        a.isActive = !1;
                    });
                });
                if (a.hasData() || e) {
                    var w = a.chart.hasRendered && a.old && y(a.old.min);
                    a.minorTickInterval && !a.categories && a.getMinorTickPositions().forEach(function (b) {
                        a.renderMinorTick(b, w);
                    });
                    h.length && (h.forEach(function (b, c) {
                        a.renderTick(b, c, w);
                    }), p && (0 === a.min || a.single) && (k[-1] || (k[-1] = new g(a, -1, null, !0)),
                        k[-1].render(-1)));
                    o && h.forEach(function (d, e) {
                        u = "undefined" !== typeof h[e + 1] ? h[e + 1] + p : a.max - p;
                        0 === e % 2 && d < a.max && u <= a.max + (b.polar ? -p : p) && (m[d] || (m[d] = new f.PlotLineOrBand(a)),
                            t = d + p, m[d].options = {
                                from: c ? c.lin2log(t) : t,
                                to: c ? c.lin2log(u) : u,
                                color: o,
                                className: "highcharts-alternate-grid"
                            }, m[d].render(), m[d].isActive = !0);
                    });
                    a._addedPlotLB || (a._addedPlotLB = !0, (d.plotLines || []).concat(d.plotBands || []).forEach(function (b) {
                        a.addPlotBandOrLine(b);
                    }));
                }
                [k, l, m].forEach(function (a) {
                    var c = [], d = s.duration;
                    C(a, function (a, b) {
                        a.isActive || (a.render(b, !1, 0), a.isActive = !1, c.push(b));
                    });
                    H(function () {
                        for (var b = c.length; b--;) a[c[b]] && !a[c[b]].isActive && (a[c[b]].destroy(),
                            delete a[c[b]]);
                    }, a !== m && b.hasRendered && d ? d : 0);
                });
                q && (q[q.isPlaced ? "animate" : "attr"]({
                    d: this.getLinePath(q.strokeWidth())
                }), q.isPlaced = !0, q[r ? "show" : "hide"](r));
                j && r && (d = a.getTitlePosition(), y(d.y) ? (j[j.isNew ? "attr" : "animate"](d),
                    j.isNew = !1) : (j.attr("y", -9999), j.isNew = !0));
                n && n.enabled && a.stacking && a.stacking.renderStackTotals();
                a.old = {
                    len: a.len,
                    max: a.max,
                    min: a.min,
                    transA: a.transA,
                    userMax: a.userMax,
                    userMin: a.userMin
                };
                a.isDirty = !1;
                v(this, "afterRender");
            };
            a.prototype.redraw = function () {
                this.visible && (this.render(), this.plotLinesAndBands.forEach(function (a) {
                    a.render();
                }));
                this.series.forEach(function (a) {
                    a.isDirty = !0;
                });
            };
            a.prototype.getKeepProps = function () {
                return this.keepProps || a.keepProps;
            };
            a.prototype.destroy = function (a) {
                var b = this, c = b.plotLinesAndBands, d = this.eventOptions;
                v(this, "destroy", {
                    keepEvents: a
                });
                a || F(b);
                [b.ticks, b.minorTicks, b.alternateBands].forEach(function (a) {
                    r(a);
                });
                if (c) for (a = c.length; a--;) c[a].destroy();
                "axisLine axisTitle axisGroup gridGroup labelGroup cross scrollbar".split(" ").forEach(function (a) {
                    b[a] && (b[a] = b[a].destroy());
                });
                for (var e in b.plotLinesAndBandsGroups) b.plotLinesAndBandsGroups[e] = b.plotLinesAndBandsGroups[e].destroy();
                C(b, function (a, c) {
                    -1 === b.getKeepProps().indexOf(c) && delete b[c];
                });
                this.eventOptions = d;
            };
            a.prototype.drawCrosshair = function (a, b) {
                var d = this.crosshair, e = D(d && d.snap, !0), f = this.chart, g, h = this.cross;
                v(this, "drawCrosshair", {
                    e: a,
                    point: b
                });
                a || (a = this.cross && this.cross.e);
                if (d && !1 !== (q(b) || !e)) {
                    e ? q(b) && (g = D("colorAxis" !== this.coll ? b.crosshairPos : null, this.isXAxis ? b.plotX : this.len - b.plotY)) : g = a && (this.horiz ? a.chartX - this.pos : this.len - a.chartY + this.pos);
                    if (q(g)) {
                        var i = {
                            value: b && (this.isXAxis ? b.x : D(b.stackY, b.y)),
                            translatedValue: g
                        };
                        f.polar && u(i, {
                            isCrosshair: !0,
                            chartX: a && a.chartX,
                            chartY: a && a.chartY,
                            point: b
                        });
                        i = this.getPlotLinePath(i) || null;
                    }
                    if (!q(i)) {
                        this.hideCrosshair();
                        return;
                    }
                    e = this.categories && !this.isRadial;
                    h || (this.cross = h = f.renderer.path().addClass("highcharts-crosshair highcharts-crosshair-" + (e ? "category " : "thin ") + (d.className || "")).attr({
                        zIndex: D(d.zIndex, 2)
                    }).add(), f.styledMode || (h.attr({
                        stroke: d.color || (e ? c.parse("#ccd6eb").setOpacity(.25).get() : "#cccccc"),
                        "stroke-width": D(d.width, 1)
                    }).css({
                        "pointer-events": "none"
                    }), d.dashStyle && h.attr({
                        dashstyle: d.dashStyle
                    })));
                    h.show().attr({
                        d: i
                    });
                    e && !d.width && h.attr({
                        "stroke-width": this.transA
                    });
                    this.cross.e = a;
                } else this.hideCrosshair();
                v(this, "afterDrawCrosshair", {
                    e: a,
                    point: b
                });
            };
            a.prototype.hideCrosshair = function () {
                this.cross && this.cross.hide();
                v(this, "afterHideCrosshair");
            };
            a.prototype.hasVerticalPanning = function () {
                var a = this.chart.options.chart.panning;
                return !!(a && a.enabled && /y/.test(a.type));
            };
            a.prototype.validatePositiveValue = function (a) {
                return y(a) && 0 < a;
            };
            a.prototype.update = function (a, b) {
                var c = this.chart;
                a = A(this.userOptions, a);
                this.destroy(!0);
                this.init(c, a);
                c.isDirtyBox = !0;
                D(b, !0) && c.redraw();
            };
            a.prototype.remove = function (a) {
                for (var b = this.chart, c = this.coll, d = this.series, e = d.length; e--;) d[e] && d[e].remove(!1);
                s(b.axes, this);
                s(b[c], this);
                b[c].forEach(function (a, b) {
                    a.options.index = a.userOptions.index = b;
                });
                this.destroy();
                b.isDirtyBox = !0;
                D(a, !0) && b.redraw();
            };
            a.prototype.setTitle = function (a, b) {
                this.update({
                    title: a
                }, b);
            };
            a.prototype.setCategories = function (a, b) {
                this.update({
                    categories: a
                }, b);
            };
            a.defaultOptions = b.defaultXAxisOptions;
            a.keepProps = "extKey hcEvents names series userMax userMin".split(" ");
            return a;
        }();
        return a;
    });
    b(c, "Core/Axis/DateTimeAxis.js", [c["Core/Utilities.js"]], function (a) {
        var b = a.addEvent, c = a.getMagnitude, d = a.normalizeTickInterval, e = a.timeUnits, f;
        !function (a) {
            function f() {
                return this.chart.time.getTimeTicks.apply(this.chart.time, arguments);
            }
            function g(a) {
                "datetime" !== a.userOptions.type ? this.dateTime = void 0 : this.dateTime || (this.dateTime = new i(this));
            }
            var h = [];
            a.compose = function (a) {
                -1 === h.indexOf(a) && (h.push(a), a.keepProps.push("dateTime"), a.prototype.getTimeTicks = f,
                    b(a, "init", g));
                return a;
            };
            var i = function () {
                function a(a) {
                    this.axis = a;
                }
                a.prototype.normalizeTimeTickInterval = function (a, b) {
                    var f = b || [["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], ["second", [1, 2, 5, 10, 15, 30]], ["minute", [1, 2, 5, 10, 15, 30]], ["hour", [1, 2, 3, 4, 6, 8, 12]], ["day", [1, 2]], ["week", [1, 2]], ["month", [1, 2, 3, 4, 6]], ["year", null]];
                    b = f[f.length - 1];
                    var g = e[b[0]], h = b[1], i;
                    for (i = 0; i < f.length && !(b = f[i], g = e[b[0]], h = b[1], f[i + 1] && a <= (g * h[h.length - 1] + e[f[i + 1][0]]) / 2); i++);
                    g === e.year && a < 5 * g && (h = [1, 2, 5]);
                    a = d(a / g, h, "year" === b[0] ? Math.max(c(a / g), 1) : 1);
                    return {
                        unitRange: g,
                        count: a,
                        unitName: b[0]
                    };
                };
                a.prototype.getXDateFormat = function (a, b) {
                    var c = this.axis;
                    return c.closestPointRange ? c.chart.time.getDateFormat(c.closestPointRange, a, c.options.startOfWeek, b) || b.year : b.day;
                };
                return a;
            }();
            a.Additions = i;
        }(f || (f = {}));
        return f;
    });
    b(c, "Core/Axis/LogarithmicAxis.js", [c["Core/Utilities.js"]], function (a) {
        var b = a.addEvent, c = a.getMagnitude, d = a.normalizeTickInterval, e = a.pick, f;
        !function (a) {
            function f(a) {
                var b = this.logarithmic;
                "logarithmic" !== a.userOptions.type ? this.logarithmic = void 0 : b || (this.logarithmic = new i(this));
            }
            function g() {
                var a = this.logarithmic;
                a && (this.lin2val = function (b) {
                    return a.lin2log(b);
                }, this.val2lin = function (b) {
                    return a.log2lin(b);
                });
            }
            var h = [];
            a.compose = function (a) {
                -1 === h.indexOf(a) && (h.push(a), a.keepProps.push("logarithmic"), b(a, "init", f),
                    b(a, "afterInit", g));
                return a;
            };
            var i = function () {
                function a(a) {
                    this.axis = a;
                }
                a.prototype.getLogTickPositions = function (a, b, f, g) {
                    var h = this.axis, i = h.len, j = h.options, k = [];
                    g || (this.minorAutoInterval = void 0);
                    if (.5 <= a) a = Math.round(a), k = h.getLinearTickPositions(a, b, f); else if (.08 <= a) {
                        var l = Math.floor(b), m, n = j = void 0;
                        for (i = .3 < a ? [1, 2, 4] : .15 < a ? [1, 2, 4, 6, 8] : [1, 2, 3, 4, 5, 6, 7, 8, 9]; l < f + 1 && !n; l++) {
                            var o = i.length;
                            for (m = 0; m < o && !n; m++) {
                                var p = this.log2lin(this.lin2log(l) * i[m]);
                                p > b && (!g || j <= f) && "undefined" !== typeof j && k.push(j);
                                j > f && (n = !0);
                                j = p;
                            }
                        }
                    } else b = this.lin2log(b), f = this.lin2log(f), a = g ? h.getMinorTickInterval() : j.tickInterval,
                        a = e("auto" === a ? null : a, this.minorAutoInterval, j.tickPixelInterval / (g ? 5 : 1) * (f - b) / ((g ? i / h.tickPositions.length : i) || 1)),
                        a = d(a, void 0, c(a)), k = h.getLinearTickPositions(a, b, f).map(this.log2lin),
                        g || (this.minorAutoInterval = a / 5);
                    g || (h.tickInterval = a);
                    return k;
                };
                a.prototype.lin2log = function (a) {
                    return Math.pow(10, a);
                };
                a.prototype.log2lin = function (a) {
                    return Math.log(a) / Math.LN10;
                };
                return a;
            }();
            a.Additions = i;
        }(f || (f = {}));
        return f;
    });
    b(c, "Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js", [c["Core/Utilities.js"]], function (a) {
        var b = a.erase, c = a.extend, d = a.isNumber, e;
        !function (a) {
            var e = [], f;
            a.compose = function (a, b) {
                f || (f = a);
                -1 === e.indexOf(b) && (e.push(b), c(b.prototype, g.prototype));
                return b;
            };
            var g = function () {
                function a() { }
                a.prototype.getPlotBandPath = function (a, b, c) {
                    void 0 === c && (c = this.options);
                    var e = this.getPlotLinePath({
                        value: b,
                        force: !0,
                        acrossPanes: c.acrossPanes
                    }), f = [], g = this.horiz;
                    b = !d(this.min) || !d(this.max) || a < this.min && b < this.min || a > this.max && b > this.max;
                    a = this.getPlotLinePath({
                        value: a,
                        force: !0,
                        acrossPanes: c.acrossPanes
                    });
                    c = 1;
                    if (a && e) {
                        if (b) {
                            var h = a.toString() === e.toString();
                            c = 0;
                        }
                        for (b = 0; b < a.length; b += 2) {
                            var i = a[b], j = a[b + 1], k = e[b], l = e[b + 1];
                            "M" !== i[0] && "L" !== i[0] || "M" !== j[0] && "L" !== j[0] || "M" !== k[0] && "L" !== k[0] || "M" !== l[0] && "L" !== l[0] || (g && k[1] === i[1] ? (k[1] += c,
                                l[1] += c) : g || k[2] !== i[2] || (k[2] += c, l[2] += c), f.push(["M", i[1], i[2]], ["L", j[1], j[2]], ["L", l[1], l[2]], ["L", k[1], k[2]], ["Z"]));
                            f.isFlat = h;
                        }
                    }
                    return f;
                };
                a.prototype.addPlotBand = function (a) {
                    return this.addPlotBandOrLine(a, "plotBands");
                };
                a.prototype.addPlotLine = function (a) {
                    return this.addPlotBandOrLine(a, "plotLines");
                };
                a.prototype.addPlotBandOrLine = function (a, b) {
                    var c = this, d = this.userOptions, e = new f(this, a);
                    this.visible && (e = e.render());
                    if (e) {
                        this._addedPlotLB || (this._addedPlotLB = !0, (d.plotLines || []).concat(d.plotBands || []).forEach(function (a) {
                            c.addPlotBandOrLine(a);
                        }));
                        if (b) {
                            var g = d[b] || [];
                            g.push(a);
                            d[b] = g;
                        }
                        this.plotLinesAndBands.push(e);
                    }
                    return e;
                };
                a.prototype.removePlotBandOrLine = function (a) {
                    var c = this.plotLinesAndBands, d = this.options, e = this.userOptions;
                    if (c) {
                        for (var f = c.length; f--;) c[f].id === a && c[f].destroy();
                        [d.plotLines || [], e.plotLines || [], d.plotBands || [], e.plotBands || []].forEach(function (c) {
                            for (f = c.length; f--;) (c[f] || {}).id === a && b(c, c[f]);
                        });
                    }
                };
                a.prototype.removePlotBand = function (a) {
                    this.removePlotBandOrLine(a);
                };
                a.prototype.removePlotLine = function (a) {
                    this.removePlotBandOrLine(a);
                };
                return a;
            }();
        }(e || (e = {}));
        return e;
    });
    b(c, "Core/Axis/PlotLineOrBand/PlotLineOrBand.js", [c["Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js"], c["Core/Utilities.js"]], function (a, b) {
        var c = b.arrayMax, d = b.arrayMin, e = b.defined, f = b.destroyObjectProperties, g = b.erase, h = b.fireEvent, i = b.merge, j = b.objectEach, k = b.pick;
        b = function () {
            function b(a, b) {
                this.axis = a;
                b && (this.options = b, this.id = b.id);
            }
            b.compose = function (c) {
                return a.compose(b, c);
            };
            b.prototype.render = function () {
                h(this, "render");
                var a = this, b = a.axis, c = b.horiz, d = b.logarithmic, f = a.options, g = f.color, l = k(f.zIndex, 0), m = f.events, n = {}, o = b.chart.renderer, p = f.label, q = a.label, r = f.to, s = f.from, t = f.value, u = a.svgElem, v = [], w = e(s) && e(r);
                v = e(t);
                var x = !u, y = {
                    "class": "highcharts-plot-" + (w ? "band " : "line ") + (f.className || "")
                }, z = w ? "bands" : "lines";
                d && (s = d.log2lin(s), r = d.log2lin(r), t = d.log2lin(t));
                b.chart.styledMode || (v ? (y.stroke = g || "#999999", y["stroke-width"] = k(f.width, 1),
                    f.dashStyle && (y.dashstyle = f.dashStyle)) : w && (y.fill = g || "#e6ebf5", f.borderWidth && (y.stroke = f.borderColor,
                        y["stroke-width"] = f.borderWidth)));
                n.zIndex = l;
                z += "-" + l;
                (d = b.plotLinesAndBandsGroups[z]) || (b.plotLinesAndBandsGroups[z] = d = o.g("plot-" + z).attr(n).add());
                x && (a.svgElem = u = o.path().attr(y).add(d));
                if (v) v = b.getPlotLinePath({
                    value: t,
                    lineWidth: u.strokeWidth(),
                    acrossPanes: f.acrossPanes
                }); else if (w) v = b.getPlotBandPath(s, r, f); else return;
                !a.eventsAdded && m && (j(m, function (b, c) {
                    u.on(c, function (b) {
                        m[c].apply(a, [b]);
                    });
                }), a.eventsAdded = !0);
                (x || !u.d) && v && v.length ? u.attr({
                    d: v
                }) : u && (v ? (u.show(!0), u.animate({
                    d: v
                })) : u.d && (u.hide(), q && (a.label = q = q.destroy())));
                p && (e(p.text) || e(p.formatter)) && v && v.length && 0 < b.width && 0 < b.height && !v.isFlat ? (p = i({
                    align: c && w && "center",
                    x: c ? !w && 4 : 10,
                    verticalAlign: !c && w && "middle",
                    y: c ? w ? 16 : 10 : w ? 6 : -4,
                    rotation: c && !w && 90
                }, p), this.renderLabel(p, v, w, l)) : q && q.hide();
                return a;
            };
            b.prototype.renderLabel = function (a, b, e, f) {
                var g = this.axis, h = g.chart.renderer, j = this.label;
                j || (this.label = j = h.text(this.getLabelText(a), 0, 0, a.useHTML).attr({
                    align: a.textAlign || a.align,
                    rotation: a.rotation,
                    "class": "highcharts-plot-" + (e ? "band" : "line") + "-label " + (a.className || ""),
                    zIndex: f
                }).add(), g.chart.styledMode || j.css(i({
                    textOverflow: "ellipsis"
                }, a.style)));
                f = b.xBounds || [b[0][1], b[1][1], e ? b[2][1] : b[0][1]];
                b = b.yBounds || [b[0][2], b[1][2], e ? b[2][2] : b[0][2]];
                e = d(f);
                h = d(b);
                j.align(a, !1, {
                    x: e,
                    y: h,
                    width: c(f) - e,
                    height: c(b) - h
                });
                j.alignValue && "left" !== j.alignValue || j.css({
                    width: (90 === j.rotation ? g.height - (j.alignAttr.y - g.top) : g.width - (j.alignAttr.x - g.left)) + "px"
                });
                j.show(!0);
            };
            b.prototype.getLabelText = function (a) {
                return e(a.formatter) ? a.formatter.call(this) : a.text;
            };
            b.prototype.destroy = function () {
                g(this.axis.plotLinesAndBands, this);
                delete this.axis;
                f(this);
            };
            return b;
        }();
        return b;
    });
    b(c, "Core/Tooltip.js", [c["Core/FormatUtilities.js"], c["Core/Globals.js"], c["Core/Renderer/RendererUtilities.js"], c["Core/Renderer/RendererRegistry.js"], c["Core/Utilities.js"]], function (a, b, c, d, e) {
        var f = a.format, g = b.doc, h = c.distribute, i = e.addEvent, j = e.clamp, k = e.css, l = e.defined, m = e.discardElement, n = e.extend, o = e.fireEvent, p = e.isArray, q = e.isNumber, r = e.isString, s = e.merge, t = e.pick, u = e.splat, v = e.syncTimeout;
        a = function () {
            function a(a, b) {
                this.allowShared = !0;
                this.container = void 0;
                this.crosshairs = [];
                this.distance = 0;
                this.isHidden = !0;
                this.isSticky = !1;
                this.now = {};
                this.options = {};
                this.outside = !1;
                this.chart = a;
                this.init(a, b);
            }
            a.prototype.applyFilter = function () {
                var a = this.chart;
                a.renderer.definition({
                    tagName: "filter",
                    attributes: {
                        id: "drop-shadow-" + a.index,
                        opacity: .5
                    },
                    children: [{
                        tagName: "feGaussianBlur",
                        attributes: {
                            "in": "SourceAlpha",
                            stdDeviation: 1
                        }
                    }, {
                        tagName: "feOffset",
                        attributes: {
                            dx: 1,
                            dy: 1
                        }
                    }, {
                        tagName: "feComponentTransfer",
                        children: [{
                            tagName: "feFuncA",
                            attributes: {
                                type: "linear",
                                slope: .3
                            }
                        }]
                    }, {
                        tagName: "feMerge",
                        children: [{
                            tagName: "feMergeNode"
                        }, {
                            tagName: "feMergeNode",
                            attributes: {
                                "in": "SourceGraphic"
                            }
                        }]
                    }]
                });
            };
            a.prototype.bodyFormatter = function (a) {
                return a.map(function (a) {
                    var b = a.series.tooltipOptions;
                    return (b[(a.point.formatPrefix || "point") + "Formatter"] || a.point.tooltipFormatter).call(a.point, b[(a.point.formatPrefix || "point") + "Format"] || "");
                });
            };
            a.prototype.cleanSplit = function (a) {
                this.chart.series.forEach(function (b) {
                    var c = b && b.tt;
                    c && (!c.isActive || a ? b.tt = c.destroy() : c.isActive = !1);
                });
            };
            a.prototype.defaultFormatter = function (a) {
                var b = this.points || u(this);
                var c = [a.tooltipFooterHeaderFormatter(b[0])];
                c = c.concat(a.bodyFormatter(b));
                c.push(a.tooltipFooterHeaderFormatter(b[0], !0));
                return c;
            };
            a.prototype.destroy = function () {
                this.label && (this.label = this.label.destroy());
                this.split && this.tt && (this.cleanSplit(!0), this.tt = this.tt.destroy());
                this.renderer && (this.renderer = this.renderer.destroy(), m(this.container));
                e.clearTimeout(this.hideTimer);
                e.clearTimeout(this.tooltipTimeout);
            };
            a.prototype.getAnchor = function (a, b) {
                var c = this.chart, d = c.pointer, e = c.inverted, f = c.plotTop, g = c.plotLeft, h, i, j = 0, k = 0;
                a = u(a);
                this.followPointer && b ? ("undefined" === typeof b.chartX && (b = d.normalize(b)),
                    d = [b.chartX - g, b.chartY - f]) : a[0].tooltipPos ? d = a[0].tooltipPos : (a.forEach(function (a) {
                        h = a.series.yAxis;
                        i = a.series.xAxis;
                        j += a.plotX || 0;
                        k += a.plotLow ? (a.plotLow + (a.plotHigh || 0)) / 2 : a.plotY || 0;
                        i && h && (e ? (j += f + c.plotHeight - i.len - i.pos, k += g + c.plotWidth - h.len - h.pos) : (j += i.pos - g,
                            k += h.pos - f));
                    }), j /= a.length, k /= a.length, d = [e ? c.plotWidth - k : j, e ? c.plotHeight - j : k],
                        this.shared && 1 < a.length && b && (e ? d[0] = b.chartX - g : d[1] = b.chartY - f));
                return d.map(Math.round);
            };
            a.prototype.getLabel = function () {
                var a = this, c = this.chart.styledMode, e = this.options, f = this.split && this.allowShared, g = "tooltip" + (l(e.className) ? " " + e.className : ""), h = e.style.pointerEvents || (!this.followPointer && e.stickOnContact ? "auto" : "none"), j = function () {
                    a.inContact = !0;
                }, m = function (b) {
                    var c = a.chart.hoverSeries;
                    a.inContact = a.shouldStickOnContact() && a.chart.pointer.inClass(b.relatedTarget, "highcharts-tooltip");
                    if (!a.inContact && c && c.onMouseOut) c.onMouseOut();
                }, n, o = this.chart.renderer;
                if (a.label) {
                    var p = !a.label.hasClass("highcharts-label");
                    (f && !p || !f && p) && a.destroy();
                }
                if (!this.label) {
                    if (this.outside) {
                        p = this.chart.options.chart.style;
                        var q = d.getRendererType();
                        this.container = n = b.doc.createElement("div");
                        n.className = "highcharts-tooltip-container";
                        k(n, {
                            position: "absolute",
                            top: "1px",
                            pointerEvents: h,
                            zIndex: Math.max(this.options.style.zIndex || 0, (p && p.zIndex || 0) + 3)
                        });
                        i(n, "mouseenter", j);
                        i(n, "mouseleave", m);
                        b.doc.body.appendChild(n);
                        this.renderer = o = new q(n, 0, 0, p, void 0, void 0, o.styledMode);
                    }
                    f ? this.label = o.g(g) : (this.label = o.label("", 0, 0, e.shape, void 0, void 0, e.useHTML, void 0, g).attr({
                        padding: e.padding,
                        r: e.borderRadius
                    }), c || this.label.attr({
                        fill: e.backgroundColor,
                        "stroke-width": e.borderWidth
                    }).css(e.style).css({
                        pointerEvents: h
                    }).shadow(e.shadow));
                    c && e.shadow && (this.applyFilter(), this.label.attr({
                        filter: "url(#drop-shadow-" + this.chart.index + ")"
                    }));
                    if (a.outside && !a.split) {
                        var r = this.label, s = r.xSetter, t = r.ySetter;
                        r.xSetter = function (b) {
                            s.call(r, a.distance);
                            n.style.left = b + "px";
                        };
                        r.ySetter = function (b) {
                            t.call(r, a.distance);
                            n.style.top = b + "px";
                        };
                    }
                    this.label.on("mouseenter", j).on("mouseleave", m).attr({
                        zIndex: 8
                    }).add();
                }
                return this.label;
            };
            a.prototype.getPosition = function (a, b, c) {
                var d = this.chart, e = this.distance, f = {}, h = d.inverted && c.h || 0, i = this.outside, j = i ? g.documentElement.clientWidth - 2 * e : d.chartWidth, k = i ? Math.max(g.body.scrollHeight, g.documentElement.scrollHeight, g.body.offsetHeight, g.documentElement.offsetHeight, g.documentElement.clientHeight) : d.chartHeight, l = d.pointer.getChartPosition(), m = function (f) {
                    var g = "x" === f;
                    return [f, g ? j : k, g ? a : b].concat(i ? [g ? a * l.scaleX : b * l.scaleY, g ? l.left - e + (c.plotX + d.plotLeft) * l.scaleX : l.top - e + (c.plotY + d.plotTop) * l.scaleY, 0, g ? j : k] : [g ? a : b, g ? c.plotX + d.plotLeft : c.plotY + d.plotTop, g ? d.plotLeft : d.plotTop, g ? d.plotLeft + d.plotWidth : d.plotTop + d.plotHeight]);
                }, n = m("y"), o = m("x"), p;
                m = !!c.negative;
                !d.polar && d.hoverSeries && d.hoverSeries.yAxis && d.hoverSeries.yAxis.reversed && (m = !m);
                var q = !this.followPointer && t(c.ttBelow, !d.inverted === m), r = function (a, b, c, d, g, j, k) {
                    var m = i ? "y" === a ? e * l.scaleY : e * l.scaleX : e, n = (c - d) / 2, o = d < g - e, p = g + e + d < b, r = g - m - c + n;
                    g = g + m - n;
                    if (q && p) f[a] = g; else if (!q && o) f[a] = r; else if (o) f[a] = Math.min(k - d, 0 > r - h ? r : r - h); else if (p) f[a] = Math.max(j, g + h + c > b ? g : g + h); else return !1;
                }, s = function (a, b, c, d, g) {
                    var h;
                    g < e || g > b - e ? h = !1 : f[a] = g < c / 2 ? 1 : g > b - d / 2 ? b - d - 2 : g - c / 2;
                    return h;
                }, u = function (a) {
                    var b = n;
                    n = o;
                    o = b;
                    p = a;
                }, v = function () {
                    !1 !== r.apply(0, n) ? !1 !== s.apply(0, o) || p || (u(!0), v()) : p ? f.x = f.y = 0 : (u(!0),
                        v());
                };
                (d.inverted || 1 < this.len) && u();
                v();
                return f;
            };
            a.prototype.hide = function (a) {
                var b = this;
                e.clearTimeout(this.hideTimer);
                a = t(a, this.options.hideDelay);
                this.isHidden || (this.hideTimer = v(function () {
                    b.getLabel().fadeOut(a ? void 0 : a);
                    b.isHidden = !0;
                }, a));
            };
            a.prototype.init = function (a, b) {
                this.chart = a;
                this.options = b;
                this.crosshairs = [];
                this.now = {
                    x: 0,
                    y: 0
                };
                this.isHidden = !0;
                this.split = b.split && !a.inverted && !a.polar;
                this.shared = b.shared || this.split;
                this.outside = t(b.outside, !(!a.scrollablePixelsX && !a.scrollablePixelsY));
            };
            a.prototype.shouldStickOnContact = function () {
                return !(this.followPointer || !this.options.stickOnContact);
            };
            a.prototype.isStickyOnContact = function () {
                return !(!this.shouldStickOnContact() || !this.inContact);
            };
            a.prototype.move = function (a, b, c, d) {
                var f = this, g = f.now, h = !1 !== f.options.animation && !f.isHidden && (1 < Math.abs(a - g.x) || 1 < Math.abs(b - g.y)), i = f.followPointer || 1 < f.len;
                n(g, {
                    x: h ? (2 * g.x + a) / 3 : a,
                    y: h ? (g.y + b) / 2 : b,
                    anchorX: i ? void 0 : h ? (2 * g.anchorX + c) / 3 : c,
                    anchorY: i ? void 0 : h ? (g.anchorY + d) / 2 : d
                });
                f.getLabel().attr(g);
                f.drawTracker();
                h && (e.clearTimeout(this.tooltipTimeout), this.tooltipTimeout = setTimeout(function () {
                    f && f.move(a, b, c, d);
                }, 32));
            };
            a.prototype.refresh = function (a, b) {
                var c = this.chart, d = this.options, f = u(a), g = f[0], h = [], i = d.formatter || this.defaultFormatter, j = this.shared, k = c.styledMode, l = {};
                if (d.enabled && g.series) {
                    e.clearTimeout(this.hideTimer);
                    this.allowShared = !(!p(a) && a.series && a.series.noSharedTooltip);
                    this.followPointer = !this.split && g.series.tooltipOptions.followPointer;
                    a = this.getAnchor(a, b);
                    var m = a[0], n = a[1];
                    j && this.allowShared ? (c.pointer.applyInactiveState(f), f.forEach(function (a) {
                        a.setState("hover");
                        h.push(a.getLabelConfig());
                    }), l = {
                        x: g.category,
                        y: g.y
                    }, l.points = h) : l = g.getLabelConfig();
                    this.len = h.length;
                    i = i.call(l, this);
                    j = g.series;
                    this.distance = t(j.tooltipOptions.distance, 16);
                    if (!1 === i) this.hide(); else {
                        if (this.split && this.allowShared) this.renderSplit(i, f); else {
                            var q = m, r = n;
                            b && c.pointer.isDirectTouch && (q = b.chartX - c.plotLeft, r = b.chartY - c.plotTop);
                            if (c.polar || !1 === j.options.clip || f.some(function (a) {
                                return a.series.shouldShowTooltip(q, r);
                            })) b = this.getLabel(), d.style.width && !k || b.css({
                                width: this.chart.spacingBox.width + "px"
                            }), b.attr({
                                text: i && i.join ? i.join("") : i
                            }), b.removeClass(/highcharts-color-[\d]+/g).addClass("highcharts-color-" + t(g.colorIndex, j.colorIndex)),
                                k || b.attr({
                                    stroke: d.borderColor || g.color || j.color || "#666666"
                                }), this.updatePosition({
                                    plotX: m,
                                    plotY: n,
                                    negative: g.negative,
                                    ttBelow: g.ttBelow,
                                    h: a[2] || 0
                                }); else {
                                this.hide();
                                return;
                            }
                        }
                        this.isHidden && this.label && this.label.attr({
                            opacity: 1
                        }).show();
                        this.isHidden = !1;
                    }
                    o(this, "refresh");
                }
            };
            a.prototype.renderSplit = function (a, b) {
                function c(a, b, c, e, f) {
                    void 0 === f && (f = !0);
                    c ? (b = D ? 0 : H, a = j(a - e / 2, A.left, A.right - e - (d.outside ? E : 0))) : (b -= F,
                        a = f ? a - e - x : a + x, a = j(a, f ? a : A.left, A.right));
                    return {
                        x: a,
                        y: b
                    };
                }
                var d = this, e = d.chart, f = d.chart, i = f.chartWidth, k = f.chartHeight, l = f.plotHeight, m = f.plotLeft, o = f.plotTop, p = f.pointer, q = f.scrollablePixelsY;
                q = void 0 === q ? 0 : q;
                var s = f.scrollablePixelsX, u = f.scrollingContainer;
                u = void 0 === u ? {
                    scrollLeft: 0,
                    scrollTop: 0
                } : u;
                var v = u.scrollLeft;
                u = u.scrollTop;
                var w = f.styledMode, x = d.distance, y = d.options, z = d.options.positioner, A = d.outside && "number" !== typeof s ? g.documentElement.getBoundingClientRect() : {
                    left: v,
                    right: v + i,
                    top: u,
                    bottom: u + k
                }, B = d.getLabel(), C = this.renderer || e.renderer, D = !(!e.xAxis[0] || !e.xAxis[0].opposite);
                e = p.getChartPosition();
                var E = e.left;
                e = e.top;
                var F = o + u, G = 0, H = l - q;
                r(a) && (a = [!1, a]);
                a = a.slice(0, b.length + 1).reduce(function (a, e, f) {
                    if (!1 !== e && "" !== e) {
                        f = b[f - 1] || {
                            isHeader: !0,
                            plotX: b[0].plotX,
                            plotY: l,
                            series: {}
                        };
                        var g = f.isHeader, h = g ? d : f.series;
                        e = e.toString();
                        var i = h.tt, k = f.isHeader;
                        var n = f.series;
                        var p = "highcharts-color-" + t(f.colorIndex, n.colorIndex, "none");
                        i || (i = {
                            padding: y.padding,
                            r: y.borderRadius
                        }, w || (i.fill = y.backgroundColor, i["stroke-width"] = y.borderWidth), i = C.label("", 0, 0, y[k ? "headerShape" : "shape"], void 0, void 0, y.useHTML).addClass((k ? "highcharts-tooltip-header " : "") + "highcharts-tooltip-box " + p).attr(i).add(B));
                        i.isActive = !0;
                        i.attr({
                            text: e
                        });
                        w || i.css(y.style).shadow(y.shadow).attr({
                            stroke: y.borderColor || f.color || n.color || "#333333"
                        });
                        h = h.tt = i;
                        k = h.getBBox();
                        e = k.width + h.strokeWidth();
                        g && (G = k.height, H += G, D && (F -= G));
                        n = f.plotX;
                        n = void 0 === n ? 0 : n;
                        p = f.plotY;
                        p = void 0 === p ? 0 : p;
                        i = f.series;
                        if (f.isHeader) {
                            n = m + n;
                            var q = o + l / 2;
                        } else {
                            var r = i.xAxis, s = i.yAxis;
                            n = r.pos + j(n, -x, r.len + x);
                            i.shouldShowTooltip(0, s.pos - o + p, {
                                ignoreX: !0
                            }) && (q = s.pos + p);
                        }
                        n = j(n, A.left - x, A.right + x);
                        "number" === typeof q ? (k = k.height + 1, p = z ? z.call(d, e, k, f) : c(n, q, g, e),
                            a.push({
                                align: z ? 0 : void 0,
                                anchorX: n,
                                anchorY: q,
                                boxWidth: e,
                                point: f,
                                rank: t(p.rank, g ? 1 : 0),
                                size: k,
                                target: p.y,
                                tt: h,
                                x: p.x
                            })) : h.isActive = !1;
                    }
                    return a;
                }, []);
                !z && a.some(function (a) {
                    var b = (d.outside ? E : 0) + a.anchorX;
                    return b < A.left && b + a.boxWidth < A.right ? !0 : b < E - A.left + a.boxWidth && A.right - b > b;
                }) && (a = a.map(function (a) {
                    var b = c(a.anchorX, a.anchorY, a.point.isHeader, a.boxWidth, !1);
                    return n(a, {
                        target: b.y,
                        x: b.x
                    });
                }));
                d.cleanSplit();
                h(a, H);
                var I = E, J = E;
                a.forEach(function (a) {
                    var b = a.x, c = a.boxWidth;
                    a = a.isHeader;
                    a || (d.outside && E + b < I && (I = E + b), !a && d.outside && I + c > J && (J = E + b));
                });
                a.forEach(function (a) {
                    var b = a.x, c = a.anchorX, e = a.pos, f = a.point.isHeader;
                    e = {
                        visibility: "undefined" === typeof e ? "hidden" : "inherit",
                        x: b,
                        y: e + F,
                        anchorX: c,
                        anchorY: a.anchorY
                    };
                    if (d.outside && b < c) {
                        var g = E - I;
                        0 < g && (f || (e.x = b + g, e.anchorX = c + g), f && (e.x = (J - I) / 2, e.anchorX = c + g));
                    }
                    a.tt.attr(e);
                });
                a = d.container;
                q = d.renderer;
                d.outside && a && q && (f = B.getBBox(), q.setSize(f.width + f.x, f.height + f.y, !1),
                    a.style.left = I + "px", a.style.top = e + "px");
            };
            a.prototype.drawTracker = function () {
                if (this.followPointer || !this.options.stickOnContact) this.tracker && this.tracker.destroy(); else {
                    var a = this.chart, b = this.label, c = this.shared ? a.hoverPoints : a.hoverPoint;
                    if (b && c) {
                        var d = {
                            x: 0,
                            y: 0,
                            width: 0,
                            height: 0
                        };
                        c = this.getAnchor(c);
                        var e = b.getBBox();
                        c[0] += a.plotLeft - b.translateX;
                        c[1] += a.plotTop - b.translateY;
                        d.x = Math.min(0, c[0]);
                        d.y = Math.min(0, c[1]);
                        d.width = 0 > c[0] ? Math.max(Math.abs(c[0]), e.width - c[0]) : Math.max(Math.abs(c[0]), e.width);
                        d.height = 0 > c[1] ? Math.max(Math.abs(c[1]), e.height - Math.abs(c[1])) : Math.max(Math.abs(c[1]), e.height);
                        this.tracker ? this.tracker.attr(d) : (this.tracker = b.renderer.rect(d).addClass("highcharts-tracker").add(b),
                            a.styledMode || this.tracker.attr({
                                fill: "rgba(0,0,0,0)"
                            }));
                    }
                }
            };
            a.prototype.styledModeFormat = function (a) {
                return a.replace('style="font-size: 10px"', 'class="highcharts-header"').replace(/style="color:{(point|series)\.color}"/g, 'class="highcharts-color-{$1.colorIndex}"');
            };
            a.prototype.tooltipFooterHeaderFormatter = function (a, b) {
                var c = a.series, d = c.tooltipOptions, e = c.xAxis, g = e && e.dateTime;
                e = {
                    isFooter: b,
                    labelConfig: a
                };
                var h = d.xDateFormat, i = d[b ? "footerFormat" : "headerFormat"];
                o(this, "headerFormatter", e, function (b) {
                    g && !h && q(a.key) && (h = g.getXDateFormat(a.key, d.dateTimeLabelFormats));
                    g && h && (a.point && a.point.tooltipDateKeys || ["key"]).forEach(function (a) {
                        i = i.replace("{point." + a + "}", "{point." + a + ":" + h + "}");
                    });
                    c.chart.styledMode && (i = this.styledModeFormat(i));
                    b.text = f(i, {
                        point: a,
                        series: c
                    }, this.chart);
                });
                return e.text;
            };
            a.prototype.update = function (a) {
                this.destroy();
                s(!0, this.chart.options.tooltip.userOptions, a);
                this.init(this.chart, s(!0, this.options, a));
            };
            a.prototype.updatePosition = function (a) {
                var b = this.chart, c = this.options, d = b.pointer, e = this.getLabel();
                d = d.getChartPosition();
                var f = (c.positioner || this.getPosition).call(this, e.width, e.height, a), g = a.plotX + b.plotLeft;
                a = a.plotY + b.plotTop;
                if (this.outside) {
                    c = c.borderWidth + 2 * this.distance;
                    this.renderer.setSize(e.width + c, e.height + c, !1);
                    if (1 !== d.scaleX || 1 !== d.scaleY) k(this.container, {
                        transform: "scale(" + d.scaleX + ", " + d.scaleY + ")"
                    }), g *= d.scaleX, a *= d.scaleY;
                    g += d.left - f.x;
                    a += d.top - f.y;
                }
                this.move(Math.round(f.x), Math.round(f.y || 0), g, a);
            };
            return a;
        }();
        return a;
    });
    b(c, "Core/Series/Point.js", [c["Core/Renderer/HTML/AST.js"], c["Core/Animation/AnimationUtilities.js"], c["Core/DefaultOptions.js"], c["Core/FormatUtilities.js"], c["Core/Utilities.js"]], function (a, b, c, d, e) {
        var f = b.animObject, g = c.defaultOptions, h = d.format, i = e.addEvent, j = e.defined, k = e.erase, l = e.extend, m = e.fireEvent, n = e.getNestedProperty, o = e.isArray, p = e.isFunction, q = e.isNumber, r = e.isObject, s = e.merge, t = e.objectEach, u = e.pick, v = e.syncTimeout, w = e.removeEvent, x = e.uniqueKey;
        b = function () {
            function b() {
                this.colorIndex = this.category = void 0;
                this.formatPrefix = "point";
                this.id = void 0;
                this.isNull = !1;
                this.percentage = this.options = this.name = void 0;
                this.selected = !1;
                this.total = this.series = void 0;
                this.visible = !0;
                this.x = void 0;
            }
            b.prototype.animateBeforeDestroy = function () {
                var a = this, b = {
                    x: a.startXPos,
                    opacity: 0
                }, c = a.getGraphicalProps();
                c.singular.forEach(function (c) {
                    a[c] = a[c].animate("dataLabel" === c ? {
                        x: a[c].startXPos,
                        y: a[c].startYPos,
                        opacity: 0
                    } : b);
                });
                c.plural.forEach(function (b) {
                    a[b].forEach(function (b) {
                        b.element && b.animate(l({
                            x: a.startXPos
                        }, b.startYPos ? {
                            x: b.startXPos,
                            y: b.startYPos
                        } : {}));
                    });
                });
            };
            b.prototype.applyOptions = function (a, c) {
                var d = this.series, e = d.options.pointValKey || d.pointValKey;
                a = b.prototype.optionsToObject.call(this, a);
                l(this, a);
                this.options = this.options ? l(this.options, a) : a;
                a.group && delete this.group;
                a.dataLabels && delete this.dataLabels;
                e && (this.y = b.prototype.getNestedProperty.call(this, e));
                this.formatPrefix = (this.isNull = u(this.isValid && !this.isValid(), null === this.x || !q(this.y))) ? "null" : "point";
                this.selected && (this.state = "select");
                "name" in this && "undefined" === typeof c && d.xAxis && d.xAxis.hasNames && (this.x = d.xAxis.nameToX(this));
                "undefined" === typeof this.x && d ? this.x = "undefined" === typeof c ? d.autoIncrement() : c : q(a.x) && d.options.relativeXValue && (this.x = d.autoIncrement(a.x));
                return this;
            };
            b.prototype.destroy = function () {
                function a() {
                    if (b.graphic || b.dataLabel || b.dataLabels) w(b), b.destroyElements();
                    for (h in b) b[h] = null;
                }
                var b = this, c = b.series, d = c.chart;
                c = c.options.dataSorting;
                var e = d.hoverPoints, g = f(b.series.chart.renderer.globalAnimation), h;
                b.legendItem && d.legend.destroyItem(b);
                e && (b.setState(), k(e, b), e.length || (d.hoverPoints = null));
                if (b === d.hoverPoint) b.onMouseOut();
                c && c.enabled ? (this.animateBeforeDestroy(), v(a, g.duration)) : a();
                d.pointCount--;
            };
            b.prototype.destroyElements = function (a) {
                var b = this;
                a = b.getGraphicalProps(a);
                a.singular.forEach(function (a) {
                    b[a] = b[a].destroy();
                });
                a.plural.forEach(function (a) {
                    b[a].forEach(function (a) {
                        a.element && a.destroy();
                    });
                    delete b[a];
                });
            };
            b.prototype.firePointEvent = function (a, b, c) {
                var d = this, e = this.series.options;
                (e.point.events[a] || d.options && d.options.events && d.options.events[a]) && d.importEvents();
                "click" === a && e.allowPointSelect && (c = function (a) {
                    d.select && d.select(null, a.ctrlKey || a.metaKey || a.shiftKey);
                });
                m(d, a, b, c);
            };
            b.prototype.getClassName = function () {
                return "highcharts-point" + (this.selected ? " highcharts-point-select" : "") + (this.negative ? " highcharts-negative" : "") + (this.isNull ? " highcharts-null-point" : "") + ("undefined" !== typeof this.colorIndex ? " highcharts-color-" + this.colorIndex : "") + (this.options.className ? " " + this.options.className : "") + (this.zone && this.zone.className ? " " + this.zone.className.replace("highcharts-negative", "") : "");
            };
            b.prototype.getGraphicalProps = function (a) {
                var b = this, c = [], d = {
                    singular: [],
                    plural: []
                }, e;
                a = a || {
                    graphic: 1,
                    dataLabel: 1
                };
                a.graphic && c.push("graphic", "upperGraphic", "shadowGroup");
                a.dataLabel && c.push("dataLabel", "dataLabelUpper", "connector");
                for (e = c.length; e--;) {
                    var f = c[e];
                    b[f] && d.singular.push(f);
                }
                ["dataLabel", "connector"].forEach(function (c) {
                    var e = c + "s";
                    a[c] && b[e] && d.plural.push(e);
                });
                return d;
            };
            b.prototype.getLabelConfig = function () {
                return {
                    x: this.category,
                    y: this.y,
                    color: this.color,
                    colorIndex: this.colorIndex,
                    key: this.name || this.category,
                    series: this.series,
                    point: this,
                    percentage: this.percentage,
                    total: this.total || this.stackTotal
                };
            };
            b.prototype.getNestedProperty = function (a) {
                if (a) return 0 === a.indexOf("custom.") ? n(a, this.options) : this[a];
            };
            b.prototype.getZone = function () {
                var a = this.series, b = a.zones;
                a = a.zoneAxis || "y";
                var c, d = 0;
                for (c = b[d]; this[a] >= c.value;) c = b[++d];
                this.nonZonedColor || (this.nonZonedColor = this.color);
                this.color = c && c.color && !this.options.color ? c.color : this.nonZonedColor;
                return c;
            };
            b.prototype.hasNewShapeType = function () {
                return (this.graphic && (this.graphic.symbolName || this.graphic.element.nodeName)) !== this.shapeType;
            };
            b.prototype.init = function (a, b, c) {
                this.series = a;
                this.applyOptions(b, c);
                this.id = j(this.id) ? this.id : x();
                this.resolveColor();
                a.chart.pointCount++;
                m(this, "afterInit");
                return this;
            };
            b.prototype.optionsToObject = function (a) {
                var c = this.series, d = c.options.keys, e = d || c.pointArrayMap || ["y"], f = e.length, g = {}, h = 0, i = 0;
                if (q(a) || null === a) g[e[0]] = a; else if (o(a)) for (!d && a.length > f && (c = typeof a[0],
                    "string" === c ? g.name = a[0] : "number" === c && (g.x = a[0]), h++); i < f;) d && "undefined" === typeof a[h] || (0 < e[i].indexOf(".") ? b.prototype.setNestedProperty(g, a[h], e[i]) : g[e[i]] = a[h]),
                        h++, i++; else "object" === typeof a && (g = a, a.dataLabels && (c._hasPointLabels = !0),
                            a.marker && (c._hasPointMarkers = !0));
                return g;
            };
            b.prototype.resolveColor = function () {
                var a = this.series, b = a.chart.styledMode;
                var c = a.chart.options.chart.colorCount;
                delete this.nonZonedColor;
                if (a.options.colorByPoint) {
                    if (!b) {
                        c = a.options.colors || a.chart.options.colors;
                        var d = c[a.colorCounter];
                        c = c.length;
                    }
                    b = a.colorCounter;
                    a.colorCounter++;
                    a.colorCounter === c && (a.colorCounter = 0);
                } else b || (d = a.color), b = a.colorIndex;
                this.colorIndex = u(this.options.colorIndex, b);
                this.color = u(this.options.color, d);
            };
            b.prototype.setNestedProperty = function (a, b, c) {
                c.split(".").reduce(function (a, c, d, e) {
                    a[c] = e.length - 1 === d ? b : r(a[c], !0) ? a[c] : {};
                    return a[c];
                }, a);
                return a;
            };
            b.prototype.tooltipFormatter = function (a) {
                var b = this.series, c = b.tooltipOptions, d = u(c.valueDecimals, ""), e = c.valuePrefix || "", f = c.valueSuffix || "";
                b.chart.styledMode && (a = b.chart.tooltip.styledModeFormat(a));
                (b.pointArrayMap || ["y"]).forEach(function (b) {
                    b = "{point." + b;
                    if (e || f) a = a.replace(RegExp(b + "}", "g"), e + b + "}" + f);
                    a = a.replace(RegExp(b + "}", "g"), b + ":,." + d + "f}");
                });
                return h(a, {
                    point: this,
                    series: this.series
                }, b.chart);
            };
            b.prototype.update = function (a, b, c, d) {
                function e() {
                    f.applyOptions(a);
                    var d = h && f.hasDummyGraphic;
                    d = null === f.y ? !d : d;
                    h && d && (f.graphic = h.destroy(), delete f.hasDummyGraphic);
                    r(a, !0) && (h && h.element && a && a.marker && "undefined" !== typeof a.marker.symbol && (f.graphic = h.destroy()),
                        a && a.dataLabels && f.dataLabel && (f.dataLabel = f.dataLabel.destroy()), f.connector && (f.connector = f.connector.destroy()));
                    k = f.index;
                    g.updateParallelArrays(f, k);
                    j.data[k] = r(j.data[k], !0) || r(a, !0) ? f.options : u(a, j.data[k]);
                    g.isDirty = g.isDirtyData = !0;
                    !g.fixedBox && g.hasCartesianSeries && (i.isDirtyBox = !0);
                    "point" === j.legendType && (i.isDirtyLegend = !0);
                    b && i.redraw(c);
                }
                var f = this, g = f.series, h = f.graphic, i = g.chart, j = g.options, k;
                b = u(b, !0);
                !1 === d ? e() : f.firePointEvent("update", {
                    options: a
                }, e);
            };
            b.prototype.remove = function (a, b) {
                this.series.removePoint(this.series.data.indexOf(this), a, b);
            };
            b.prototype.select = function (a, b) {
                var c = this, d = c.series, e = d.chart;
                this.selectedStaging = a = u(a, !c.selected);
                c.firePointEvent(a ? "select" : "unselect", {
                    accumulate: b
                }, function () {
                    c.selected = c.options.selected = a;
                    d.options.data[d.data.indexOf(c)] = c.options;
                    c.setState(a && "select");
                    b || e.getSelectedPoints().forEach(function (a) {
                        var b = a.series;
                        a.selected && a !== c && (a.selected = a.options.selected = !1, b.options.data[b.data.indexOf(a)] = a.options,
                            a.setState(e.hoverPoints && b.options.inactiveOtherPoints ? "inactive" : ""), a.firePointEvent("unselect"));
                    });
                });
                delete this.selectedStaging;
            };
            b.prototype.onMouseOver = function (a) {
                var b = this.series.chart, c = b.pointer;
                a = a ? c.normalize(a) : c.getChartCoordinatesFromPoint(this, b.inverted);
                c.runPointActions(a, this);
            };
            b.prototype.onMouseOut = function () {
                var a = this.series.chart;
                this.firePointEvent("mouseOut");
                this.series.options.inactiveOtherPoints || (a.hoverPoints || []).forEach(function (a) {
                    a.setState();
                });
                a.hoverPoints = a.hoverPoint = null;
            };
            b.prototype.importEvents = function () {
                if (!this.hasImportedEvents) {
                    var a = this, b = s(a.series.options.point, a.options).events;
                    a.events = b;
                    t(b, function (b, c) {
                        p(b) && i(a, c, b);
                    });
                    this.hasImportedEvents = !0;
                }
            };
            b.prototype.setState = function (b, c) {
                var d = this.series, e = this.state, f = d.options.states[b || "normal"] || {}, h = g.plotOptions[d.type].marker && d.options.marker, i = h && !1 === h.enabled, j = h && h.states && h.states[b || "normal"] || {}, k = !1 === j.enabled, n = this.marker || {}, o = d.chart, p = h && d.markerAttribs, r = d.halo, s, t = d.stateMarkerGraphic;
                b = b || "";
                if (!(b === this.state && !c || this.selected && "select" !== b || !1 === f.enabled || b && (k || i && !1 === j.enabled) || b && n.states && n.states[b] && !1 === n.states[b].enabled)) {
                    this.state = b;
                    p && (s = d.markerAttribs(this, b));
                    if (this.graphic && !this.hasDummyGraphic) {
                        e && this.graphic.removeClass("highcharts-point-" + e);
                        b && this.graphic.addClass("highcharts-point-" + b);
                        if (!o.styledMode) {
                            var v = d.pointAttribs(this, b);
                            var w = u(o.options.chart.animation, f.animation);
                            d.options.inactiveOtherPoints && q(v.opacity) && ((this.dataLabels || []).forEach(function (a) {
                                a && a.animate({
                                    opacity: v.opacity
                                }, w);
                            }), this.connector && this.connector.animate({
                                opacity: v.opacity
                            }, w));
                            this.graphic.animate(v, w);
                        }
                        s && this.graphic.animate(s, u(o.options.chart.animation, j.animation, h.animation));
                        t && t.hide();
                    } else {
                        if (b && j) {
                            e = n.symbol || d.symbol;
                            t && t.currentSymbol !== e && (t = t.destroy());
                            if (s) if (t) t[c ? "animate" : "attr"]({
                                x: s.x,
                                y: s.y
                            }); else e && (d.stateMarkerGraphic = t = o.renderer.symbol(e, s.x, s.y, s.width, s.height).add(d.markerGroup),
                                t.currentSymbol = e);
                            !o.styledMode && t && "inactive" !== this.state && t.attr(d.pointAttribs(this, b));
                        }
                        t && (t[b && this.isInside ? "show" : "hide"](), t.element.point = this, t.addClass(this.getClassName(), !0));
                    }
                    f = f.halo;
                    s = (t = this.graphic || t) && t.visibility || "inherit";
                    f && f.size && t && "hidden" !== s && !this.isCluster ? (r || (d.halo = r = o.renderer.path().add(t.parentGroup)),
                        r.show()[c ? "animate" : "attr"]({
                            d: this.haloPath(f.size)
                        }), r.attr({
                            "class": "highcharts-halo highcharts-color-" + u(this.colorIndex, d.colorIndex) + (this.className ? " " + this.className : ""),
                            visibility: s,
                            zIndex: -1
                        }), r.point = this, o.styledMode || r.attr(l({
                            fill: this.color || d.color,
                            "fill-opacity": f.opacity
                        }, a.filterUserAttributes(f.attributes || {})))) : r && r.point && r.point.haloPath && r.animate({
                            d: r.point.haloPath(0)
                        }, null, r.hide);
                    m(this, "afterSetState", {
                        state: b
                    });
                }
            };
            b.prototype.haloPath = function (a) {
                return this.series.chart.renderer.symbols.circle(Math.floor(this.plotX) - a, this.plotY - a, 2 * a, 2 * a);
            };
            return b;
        }();
        return b;
    });
    b(c, "Core/Pointer.js", [c["Core/Color/Color.js"], c["Core/Globals.js"], c["Core/Tooltip.js"], c["Core/Utilities.js"]], function (a, b, c, d) {
        var e = a.parse, f = b.charts, g = b.noop, h = d.addEvent, i = d.attr, j = d.css, k = d.defined, l = d.extend, m = d.find, n = d.fireEvent, o = d.isNumber, p = d.isObject, q = d.objectEach, r = d.offset, s = d.pick, t = d.splat;
        a = function () {
            function a(a, b) {
                this.lastValidTouch = {};
                this.pinchDown = [];
                this.runChartClick = !1;
                this.eventsToUnbind = [];
                this.chart = a;
                this.hasDragged = !1;
                this.options = b;
                this.init(a, b);
            }
            a.prototype.applyInactiveState = function (a) {
                var b = [], c;
                (a || []).forEach(function (a) {
                    c = a.series;
                    b.push(c);
                    c.linkedParent && b.push(c.linkedParent);
                    c.linkedSeries && (b = b.concat(c.linkedSeries));
                    c.navigatorSeries && b.push(c.navigatorSeries);
                });
                this.chart.series.forEach(function (a) {
                    -1 === b.indexOf(a) ? a.setState("inactive", !0) : a.options.inactiveOtherPoints && a.setAllPointsToState("inactive");
                });
            };
            a.prototype.destroy = function () {
                var c = this;
                this.eventsToUnbind.forEach(function (a) {
                    return a();
                });
                this.eventsToUnbind = [];
                b.chartCount || (a.unbindDocumentMouseUp && (a.unbindDocumentMouseUp = a.unbindDocumentMouseUp()),
                    a.unbindDocumentTouchEnd && (a.unbindDocumentTouchEnd = a.unbindDocumentTouchEnd()));
                clearInterval(c.tooltipTimeout);
                q(c, function (a, b) {
                    c[b] = void 0;
                });
            };
            a.prototype.drag = function (a) {
                var b = this.chart, c = b.options.chart, d = this.zoomHor, f = this.zoomVert, g = b.plotLeft, h = b.plotTop, i = b.plotWidth, j = b.plotHeight, k = this.mouseDownX || 0, l = this.mouseDownY || 0, m = p(c.panning) ? c.panning && c.panning.enabled : c.panning, n = c.panKey && a[c.panKey + "Key"], o = a.chartX, q = a.chartY, r = this.selectionMarker;
                if (!r || !r.touch) if (o < g ? o = g : o > g + i && (o = g + i), q < h ? q = h : q > h + j && (q = h + j),
                    this.hasDragged = Math.sqrt(Math.pow(k - o, 2) + Math.pow(l - q, 2)), 10 < this.hasDragged) {
                    var s = b.isInsidePlot(k - g, l - h, {
                        visiblePlotOnly: !0
                    });
                    !b.hasCartesianSeries && !b.mapView || !this.zoomX && !this.zoomY || !s || n || r || (this.selectionMarker = r = b.renderer.rect(g, h, d ? 1 : i, f ? 1 : j, 0).attr({
                        "class": "highcharts-selection-marker",
                        zIndex: 7
                    }).add(), b.styledMode || r.attr({
                        fill: c.selectionMarkerFill || e("#335cad").setOpacity(.25).get()
                    }));
                    r && d && (d = o - k, r.attr({
                        width: Math.abs(d),
                        x: (0 < d ? 0 : d) + k
                    }));
                    r && f && (d = q - l, r.attr({
                        height: Math.abs(d),
                        y: (0 < d ? 0 : d) + l
                    }));
                    s && !r && m && b.pan(a, c.panning);
                }
            };
            a.prototype.dragStart = function (a) {
                var b = this.chart;
                b.mouseIsDown = a.type;
                b.cancelClick = !1;
                b.mouseDownX = this.mouseDownX = a.chartX;
                b.mouseDownY = this.mouseDownY = a.chartY;
            };
            a.prototype.drop = function (a) {
                var b = this, c = this.chart, d = this.hasPinched;
                if (this.selectionMarker) {
                    var e = this.selectionMarker, f = e.attr ? e.attr("x") : e.x, g = e.attr ? e.attr("y") : e.y, h = e.attr ? e.attr("width") : e.width, i = e.attr ? e.attr("height") : e.height, m = {
                        originalEvent: a,
                        xAxis: [],
                        yAxis: [],
                        x: f,
                        y: g,
                        width: h,
                        height: i
                    }, p = !!c.mapView;
                    if (this.hasDragged || d) c.axes.forEach(function (c) {
                        if (c.zoomEnabled && k(c.min) && (d || b[{
                            xAxis: "zoomX",
                            yAxis: "zoomY"
                        }[c.coll]]) && o(f) && o(g)) {
                            var e = c.horiz, j = "touchend" === a.type ? c.minPixelPadding : 0, l = c.toValue((e ? f : g) + j);
                            e = c.toValue((e ? f + h : g + i) - j);
                            m[c.coll].push({
                                axis: c,
                                min: Math.min(l, e),
                                max: Math.max(l, e)
                            });
                            p = !0;
                        }
                    }), p && n(c, "selection", m, function (a) {
                        c.zoom(l(a, d ? {
                            animation: !1
                        } : null));
                    });
                    o(c.index) && (this.selectionMarker = this.selectionMarker.destroy());
                    d && this.scaleGroups();
                }
                c && o(c.index) && (j(c.container, {
                    cursor: c._cursor
                }), c.cancelClick = 10 < this.hasDragged, c.mouseIsDown = this.hasDragged = this.hasPinched = !1,
                    this.pinchDown = []);
            };
            a.prototype.findNearestKDPoint = function (a, b, c) {
                var d = this.chart, e = d.hoverPoint;
                d = d.tooltip;
                if (e && d && d.isStickyOnContact()) return e;
                var f;
                a.forEach(function (a) {
                    var d = !(a.noSharedTooltip && b) && 0 > a.options.findNearestPointBy.indexOf("y");
                    a = a.searchPoint(c, d);
                    if ((d = p(a, !0) && a.series) && !(d = !p(f, !0))) {
                        d = f.distX - a.distX;
                        var e = f.dist - a.dist, g = (a.series.group && a.series.group.zIndex) - (f.series.group && f.series.group.zIndex);
                        d = 0 < (0 !== d && b ? d : 0 !== e ? e : 0 !== g ? g : f.series.index > a.series.index ? -1 : 1);
                    }
                    d && (f = a);
                });
                return f;
            };
            a.prototype.getChartCoordinatesFromPoint = function (a, b) {
                var c = a.series, d = c.xAxis;
                c = c.yAxis;
                var e = a.shapeArgs;
                if (d && c) {
                    var f = s(a.clientX, a.plotX), g = a.plotY || 0;
                    a.isNode && e && o(e.x) && o(e.y) && (f = e.x, g = e.y);
                    return b ? {
                        chartX: c.len + c.pos - g,
                        chartY: d.len + d.pos - f
                    } : {
                        chartX: f + d.pos,
                        chartY: g + c.pos
                    };
                }
                if (e && e.x && e.y) return {
                    chartX: e.x,
                    chartY: e.y
                };
            };
            a.prototype.getChartPosition = function () {
                if (this.chartPosition) return this.chartPosition;
                var a = this.chart.container, b = r(a);
                this.chartPosition = {
                    left: b.left,
                    top: b.top,
                    scaleX: 1,
                    scaleY: 1
                };
                var c = a.offsetWidth;
                a = a.offsetHeight;
                2 < c && 2 < a && (this.chartPosition.scaleX = b.width / c, this.chartPosition.scaleY = b.height / a);
                return this.chartPosition;
            };
            a.prototype.getCoordinates = function (a) {
                var b = {
                    xAxis: [],
                    yAxis: []
                };
                this.chart.axes.forEach(function (c) {
                    b[c.isXAxis ? "xAxis" : "yAxis"].push({
                        axis: c,
                        value: c.toValue(a[c.horiz ? "chartX" : "chartY"])
                    });
                });
                return b;
            };
            a.prototype.getHoverData = function (a, b, c, d, e, f) {
                var g = [];
                d = !(!d || !a);
                var h = {
                    chartX: f ? f.chartX : void 0,
                    chartY: f ? f.chartY : void 0,
                    shared: e
                };
                n(this, "beforeGetHoverData", h);
                var i = b && !b.stickyTracking ? [b] : c.filter(function (a) {
                    return h.filter ? h.filter(a) : a.visible && !(!e && a.directTouch) && s(a.options.enableMouseTracking, !0) && a.stickyTracking;
                });
                var j = d || !f ? a : this.findNearestKDPoint(i, e, f);
                b = j && j.series;
                j && (e && !b.noSharedTooltip ? (i = c.filter(function (a) {
                    return h.filter ? h.filter(a) : a.visible && !(!e && a.directTouch) && s(a.options.enableMouseTracking, !0) && !a.noSharedTooltip;
                }), i.forEach(function (a) {
                    var b = m(a.points, function (a) {
                        return a.x === j.x && !a.isNull;
                    });
                    p(b) && (a.chart.isBoosting && (b = a.getPoint(b)), g.push(b));
                })) : g.push(j));
                h = {
                    hoverPoint: j
                };
                n(this, "afterGetHoverData", h);
                return {
                    hoverPoint: h.hoverPoint,
                    hoverSeries: b,
                    hoverPoints: g
                };
            };
            a.prototype.getPointFromEvent = function (a) {
                a = a.target;
                for (var b; a && !b;) b = a.point, a = a.parentNode;
                return b;
            };
            a.prototype.onTrackerMouseOut = function (a) {
                a = a.relatedTarget || a.toElement;
                var b = this.chart.hoverSeries;
                this.isDirectTouch = !1;
                if (!(!b || !a || b.stickyTracking || this.inClass(a, "highcharts-tooltip") || this.inClass(a, "highcharts-series-" + b.index) && this.inClass(a, "highcharts-tracker"))) b.onMouseOut();
            };
            a.prototype.inClass = function (a, b) {
                for (var c; a;) {
                    if (c = i(a, "class")) {
                        if (-1 !== c.indexOf(b)) return !0;
                        if (-1 !== c.indexOf("highcharts-container")) return !1;
                    }
                    a = a.parentElement;
                }
            };
            a.prototype.init = function (a, b) {
                this.options = b;
                this.chart = a;
                this.runChartClick = !(!b.chart.events || !b.chart.events.click);
                this.pinchDown = [];
                this.lastValidTouch = {};
                c && (a.tooltip = new c(a, b.tooltip), this.followTouchMove = s(b.tooltip.followTouchMove, !0));
                this.setDOMEvents();
            };
            a.prototype.normalize = function (a, b) {
                var c = a.touches, d = c ? c.length ? c.item(0) : s(c.changedTouches, a.changedTouches)[0] : a;
                b || (b = this.getChartPosition());
                c = d.pageX - b.left;
                d = d.pageY - b.top;
                c /= b.scaleX;
                d /= b.scaleY;
                return l(a, {
                    chartX: Math.round(c),
                    chartY: Math.round(d)
                });
            };
            a.prototype.onContainerClick = function (a) {
                var b = this.chart, c = b.hoverPoint;
                a = this.normalize(a);
                var d = b.plotLeft, e = b.plotTop;
                b.cancelClick || (c && this.inClass(a.target, "highcharts-tracker") ? (n(c.series, "click", l(a, {
                    point: c
                })), b.hoverPoint && c.firePointEvent("click", a)) : (l(a, this.getCoordinates(a)),
                    b.isInsidePlot(a.chartX - d, a.chartY - e, {
                        visiblePlotOnly: !0
                    }) && n(b, "click", a)));
            };
            a.prototype.onContainerMouseDown = function (a) {
                var c = 1 === (1 & (a.buttons || a.button));
                a = this.normalize(a);
                if (b.isFirefox && 0 !== a.button) this.onContainerMouseMove(a);
                if ("undefined" === typeof a.button || c) this.zoomOption(a), c && a.preventDefault && a.preventDefault(),
                    this.dragStart(a);
            };
            a.prototype.onContainerMouseLeave = function (b) {
                var c = f[s(a.hoverChartIndex, -1)], d = this.chart.tooltip;
                d && d.shouldStickOnContact() && this.inClass(b.relatedTarget, "highcharts-tooltip-container") || (b = this.normalize(b),
                    c && (b.relatedTarget || b.toElement) && (c.pointer.reset(), c.pointer.chartPosition = void 0),
                    d && !d.isHidden && this.reset());
            };
            a.prototype.onContainerMouseEnter = function (a) {
                delete this.chartPosition;
            };
            a.prototype.onContainerMouseMove = function (a) {
                var b = this.chart;
                a = this.normalize(a);
                this.setHoverChartIndex();
                a.preventDefault || (a.returnValue = !1);
                ("mousedown" === b.mouseIsDown || this.touchSelect(a)) && this.drag(a);
                b.openMenu || !this.inClass(a.target, "highcharts-tracker") && !b.isInsidePlot(a.chartX - b.plotLeft, a.chartY - b.plotTop, {
                    visiblePlotOnly: !0
                }) || (this.inClass(a.target, "highcharts-no-tooltip") ? this.reset(!1, 0) : this.runPointActions(a));
            };
            a.prototype.onDocumentTouchEnd = function (b) {
                var c = f[s(a.hoverChartIndex, -1)];
                c && c.pointer.drop(b);
            };
            a.prototype.onContainerTouchMove = function (a) {
                if (this.touchSelect(a)) this.onContainerMouseMove(a); else this.touch(a);
            };
            a.prototype.onContainerTouchStart = function (a) {
                if (this.touchSelect(a)) this.onContainerMouseDown(a); else this.zoomOption(a),
                    this.touch(a, !0);
            };
            a.prototype.onDocumentMouseMove = function (a) {
                var b = this.chart, c = this.chartPosition;
                a = this.normalize(a, c);
                var d = b.tooltip;
                !c || d && d.isStickyOnContact() || b.isInsidePlot(a.chartX - b.plotLeft, a.chartY - b.plotTop, {
                    visiblePlotOnly: !0
                }) || this.inClass(a.target, "highcharts-tracker") || this.reset();
            };
            a.prototype.onDocumentMouseUp = function (b) {
                var c = f[s(a.hoverChartIndex, -1)];
                c && c.pointer.drop(b);
            };
            a.prototype.pinch = function (a) {
                var b = this, c = b.chart, d = b.pinchDown, e = a.touches || [], f = e.length, h = b.lastValidTouch, i = b.hasZoom, j = {}, k = 1 === f && (b.inClass(a.target, "highcharts-tracker") && c.runTrackerClick || b.runChartClick), m = {}, o = b.selectionMarker;
                1 < f ? b.initiated = !0 : 1 === f && this.followTouchMove && (b.initiated = !1);
                i && b.initiated && !k && !1 !== a.cancelable && a.preventDefault();
                [].map.call(e, function (a) {
                    return b.normalize(a);
                });
                "touchstart" === a.type ? ([].forEach.call(e, function (a, b) {
                    d[b] = {
                        chartX: a.chartX,
                        chartY: a.chartY
                    };
                }), h.x = [d[0].chartX, d[1] && d[1].chartX], h.y = [d[0].chartY, d[1] && d[1].chartY],
                    c.axes.forEach(function (a) {
                        if (a.zoomEnabled) {
                            var b = c.bounds[a.horiz ? "h" : "v"], d = a.minPixelPadding, e = a.toPixels(Math.min(s(a.options.min, a.dataMin), a.dataMin)), f = a.toPixels(Math.max(s(a.options.max, a.dataMax), a.dataMax)), g = Math.max(e, f);
                            b.min = Math.min(a.pos, Math.min(e, f) - d);
                            b.max = Math.max(a.pos + a.len, g + d);
                        }
                    }), b.res = !0) : b.followTouchMove && 1 === f ? this.runPointActions(b.normalize(a)) : d.length && (n(c, "touchpan", {
                        originalEvent: a
                    }, function () {
                        o || (b.selectionMarker = o = l({
                            destroy: g,
                            touch: !0
                        }, c.plotBox));
                        b.pinchTranslate(d, e, j, o, m, h);
                        b.hasPinched = i;
                        b.scaleGroups(j, m);
                    }), b.res && (b.res = !1, this.reset(!1, 0)));
            };
            a.prototype.pinchTranslate = function (a, b, c, d, e, f) {
                this.zoomHor && this.pinchTranslateDirection(!0, a, b, c, d, e, f);
                this.zoomVert && this.pinchTranslateDirection(!1, a, b, c, d, e, f);
            };
            a.prototype.pinchTranslateDirection = function (a, b, c, d, e, f, g, h) {
                var i = this.chart, j = a ? "x" : "y", k = a ? "X" : "Y", l = "chart" + k, m = a ? "width" : "height", n = i["plot" + (a ? "Left" : "Top")], o = i.inverted, p = i.bounds[a ? "h" : "v"], q = 1 === b.length, r = b[0][l], s = !q && b[1][l];
                b = function () {
                    "number" === typeof x && 20 < Math.abs(r - s) && (v = h || Math.abs(w - x) / Math.abs(r - s));
                    u = (n - w) / v + r;
                    t = i["plot" + (a ? "Width" : "Height")] / v;
                };
                var t, u, v = h || 1, w = c[0][l], x = !q && c[1][l];
                b();
                c = u;
                if (c < p.min) {
                    c = p.min;
                    var y = !0;
                } else c + t > p.max && (c = p.max - t, y = !0);
                y ? (w -= .8 * (w - g[j][0]), "number" === typeof x && (x -= .8 * (x - g[j][1])),
                    b()) : g[j] = [w, x];
                o || (f[j] = u - n, f[m] = t);
                f = o ? 1 / v : v;
                e[m] = t;
                e[j] = c;
                d[o ? a ? "scaleY" : "scaleX" : "scale" + k] = v;
                d["translate" + k] = f * n + (w - f * r);
            };
            a.prototype.reset = function (a, b) {
                var c = this.chart, d = c.hoverSeries, e = c.hoverPoint, f = c.hoverPoints, g = c.tooltip, h = g && g.shared ? f : e;
                a && h && t(h).forEach(function (b) {
                    b.series.isCartesian && "undefined" === typeof b.plotX && (a = !1);
                });
                if (a) g && h && t(h).length && (g.refresh(h), g.shared && f ? f.forEach(function (a) {
                    a.setState(a.state, !0);
                    a.series.isCartesian && (a.series.xAxis.crosshair && a.series.xAxis.drawCrosshair(null, a),
                        a.series.yAxis.crosshair && a.series.yAxis.drawCrosshair(null, a));
                }) : e && (e.setState(e.state, !0), c.axes.forEach(function (a) {
                    a.crosshair && e.series[a.coll] === a && a.drawCrosshair(null, e);
                }))); else {
                    if (e) e.onMouseOut();
                    f && f.forEach(function (a) {
                        a.setState();
                    });
                    if (d) d.onMouseOut();
                    g && g.hide(b);
                    this.unDocMouseMove && (this.unDocMouseMove = this.unDocMouseMove());
                    c.axes.forEach(function (a) {
                        a.hideCrosshair();
                    });
                    this.hoverX = c.hoverPoints = c.hoverPoint = null;
                }
            };
            a.prototype.runPointActions = function (b, c) {
                var d = this.chart, e = d.tooltip && d.tooltip.options.enabled ? d.tooltip : void 0, g = e ? e.shared : !1, i = c || d.hoverPoint, j = i && i.series || d.hoverSeries;
                c = this.getHoverData(i, j, d.series, (!b || "touchmove" !== b.type) && (!!c || j && j.directTouch && this.isDirectTouch), g, b);
                i = c.hoverPoint;
                j = c.hoverSeries;
                var k = c.hoverPoints;
                c = j && j.tooltipOptions.followPointer && !j.tooltipOptions.split;
                var l = g && j && !j.noSharedTooltip;
                if (i && (i !== d.hoverPoint || e && e.isHidden)) {
                    (d.hoverPoints || []).forEach(function (a) {
                        -1 === k.indexOf(a) && a.setState();
                    });
                    if (d.hoverSeries !== j) j.onMouseOver();
                    this.applyInactiveState(k);
                    (k || []).forEach(function (a) {
                        a.setState("hover");
                    });
                    d.hoverPoint && d.hoverPoint.firePointEvent("mouseOut");
                    if (!i.series) return;
                    d.hoverPoints = k;
                    d.hoverPoint = i;
                    i.firePointEvent("mouseOver", void 0, function () {
                        e && i && e.refresh(l ? k : i, b);
                    });
                } else c && e && !e.isHidden && (g = e.getAnchor([{}], b), d.isInsidePlot(g[0], g[1], {
                    visiblePlotOnly: !0
                }) && e.updatePosition({
                    plotX: g[0],
                    plotY: g[1]
                }));
                this.unDocMouseMove || (this.unDocMouseMove = h(d.container.ownerDocument, "mousemove", function (b) {
                    var c = f[a.hoverChartIndex];
                    if (c) c.pointer.onDocumentMouseMove(b);
                }), this.eventsToUnbind.push(this.unDocMouseMove));
                d.axes.forEach(function (a) {
                    var c = s((a.crosshair || {}).snap, !0), e;
                    c && ((e = d.hoverPoint) && e.series[a.coll] === a || (e = m(k, function (b) {
                        return b.series && b.series[a.coll] === a;
                    })));
                    e || !c ? a.drawCrosshair(b, e) : a.hideCrosshair();
                });
            };
            a.prototype.scaleGroups = function (a, b) {
                var c = this.chart;
                c.series.forEach(function (d) {
                    var e = a || d.getPlotBox();
                    d.group && (d.xAxis && d.xAxis.zoomEnabled || c.mapView) && (d.group.attr(e), d.markerGroup && (d.markerGroup.attr(e),
                        d.markerGroup.clip(b ? c.clipRect : null)), d.dataLabelsGroup && d.dataLabelsGroup.attr(e));
                });
                c.clipRect.attr(b || c.clipBox);
            };
            a.prototype.setDOMEvents = function () {
                var c = this, d = this.chart.container, e = d.ownerDocument;
                d.onmousedown = this.onContainerMouseDown.bind(this);
                d.onmousemove = this.onContainerMouseMove.bind(this);
                d.onclick = this.onContainerClick.bind(this);
                this.eventsToUnbind.push(h(d, "mouseenter", this.onContainerMouseEnter.bind(this)));
                this.eventsToUnbind.push(h(d, "mouseleave", this.onContainerMouseLeave.bind(this)));
                a.unbindDocumentMouseUp || (a.unbindDocumentMouseUp = h(e, "mouseup", this.onDocumentMouseUp.bind(this)));
                for (var f = this.chart.renderTo.parentElement; f && "BODY" !== f.tagName;) this.eventsToUnbind.push(h(f, "scroll", function () {
                    delete c.chartPosition;
                })), f = f.parentElement;
                b.hasTouch && (this.eventsToUnbind.push(h(d, "touchstart", this.onContainerTouchStart.bind(this), {
                    passive: !1
                })), this.eventsToUnbind.push(h(d, "touchmove", this.onContainerTouchMove.bind(this), {
                    passive: !1
                })), a.unbindDocumentTouchEnd || (a.unbindDocumentTouchEnd = h(e, "touchend", this.onDocumentTouchEnd.bind(this), {
                    passive: !1
                })));
            };
            a.prototype.setHoverChartIndex = function () {
                var c = this.chart, d = b.charts[s(a.hoverChartIndex, -1)];
                if (d && d !== c) d.pointer.onContainerMouseLeave({
                    relatedTarget: c.container
                });
                d && d.mouseIsDown || (a.hoverChartIndex = c.index);
            };
            a.prototype.touch = function (a, b) {
                var c = this.chart, d;
                this.setHoverChartIndex();
                if (1 === a.touches.length) if (a = this.normalize(a), (d = c.isInsidePlot(a.chartX - c.plotLeft, a.chartY - c.plotTop, {
                    visiblePlotOnly: !0
                })) && !c.openMenu) {
                    b && this.runPointActions(a);
                    if ("touchmove" === a.type) {
                        b = this.pinchDown;
                        var e = b[0] ? 4 <= Math.sqrt(Math.pow(b[0].chartX - a.chartX, 2) + Math.pow(b[0].chartY - a.chartY, 2)) : !1;
                    }
                    s(e, !0) && this.pinch(a);
                } else b && this.reset(); else 2 === a.touches.length && this.pinch(a);
            };
            a.prototype.touchSelect = function (a) {
                return !(!this.chart.options.chart.zoomBySingleTouch || !a.touches || 1 !== a.touches.length);
            };
            a.prototype.zoomOption = function (a) {
                var b = this.chart, c = b.options.chart;
                b = b.inverted;
                var d = c.zoomType || "";
                /touch/.test(a.type) && (d = s(c.pinchType, d));
                this.zoomX = a = /x/.test(d);
                this.zoomY = c = /y/.test(d);
                this.zoomHor = a && !b || c && b;
                this.zoomVert = c && !b || a && b;
                this.hasZoom = a || c;
            };
            return a;
        }();
        return a;
    });
    b(c, "Core/MSPointer.js", [c["Core/Globals.js"], c["Core/Pointer.js"], c["Core/Utilities.js"]], function (a, b, c) {
        function d() {
            var a = [];
            a.item = function (a) {
                return this[a];
            };
            m(o, function (b) {
                a.push({
                    pageX: b.pageX,
                    pageY: b.pageY,
                    target: b.target
                });
            });
            return a;
        }
        function e(a, c, e, f) {
            var h = g[b.hoverChartIndex || 0 / 0];
            "touch" !== a.pointerType && a.pointerType !== a.MSPOINTER_TYPE_TOUCH || !h || (h = h.pointer,
                f(a), h[c]({
                    type: e,
                    target: a.currentTarget,
                    preventDefault: i,
                    touches: d()
                }));
        }
        var f = this && this.__extends || function () {
            var a = function (b, c) {
                a = Object.setPrototypeOf || {
                    __proto__: []
                } instanceof Array && function (a, b) {
                    a.__proto__ = b;
                } || function (a, b) {
                    for (var c in b) b.hasOwnProperty(c) && (a[c] = b[c]);
                };
                return a(b, c);
            };
            return function (b, c) {
                function d() {
                    this.constructor = b;
                }
                a(b, c);
                b.prototype = null === c ? Object.create(c) : (d.prototype = c.prototype, new d());
            };
        }(), g = a.charts, h = a.doc, i = a.noop, j = a.win, k = c.addEvent, l = c.css, m = c.objectEach, n = c.removeEvent, o = {}, p = !!j.PointerEvent;
        return function (b) {
            function c() {
                return null !== b && b.apply(this, arguments) || this;
            }
            f(c, b);
            c.isRequired = function () {
                return !(a.hasTouch || !j.PointerEvent && !j.MSPointerEvent);
            };
            c.prototype.batchMSEvents = function (a) {
                a(this.chart.container, p ? "pointerdown" : "MSPointerDown", this.onContainerPointerDown);
                a(this.chart.container, p ? "pointermove" : "MSPointerMove", this.onContainerPointerMove);
                a(h, p ? "pointerup" : "MSPointerUp", this.onDocumentPointerUp);
            };
            c.prototype.destroy = function () {
                this.batchMSEvents(n);
                b.prototype.destroy.call(this);
            };
            c.prototype.init = function (a, c) {
                b.prototype.init.call(this, a, c);
                this.hasZoom && l(a.container, {
                    "-ms-touch-action": "none",
                    "touch-action": "none"
                });
            };
            c.prototype.onContainerPointerDown = function (a) {
                e(a, "onContainerTouchStart", "touchstart", function (a) {
                    o[a.pointerId] = {
                        pageX: a.pageX,
                        pageY: a.pageY,
                        target: a.currentTarget
                    };
                });
            };
            c.prototype.onContainerPointerMove = function (a) {
                e(a, "onContainerTouchMove", "touchmove", function (a) {
                    o[a.pointerId] = {
                        pageX: a.pageX,
                        pageY: a.pageY
                    };
                    o[a.pointerId].target || (o[a.pointerId].target = a.currentTarget);
                });
            };
            c.prototype.onDocumentPointerUp = function (a) {
                e(a, "onDocumentTouchEnd", "touchend", function (a) {
                    delete o[a.pointerId];
                });
            };
            c.prototype.setDOMEvents = function () {
                b.prototype.setDOMEvents.call(this);
                (this.hasZoom || this.followTouchMove) && this.batchMSEvents(k);
            };
            return c;
        }(b);
    });
    b(c, "Core/Legend/Legend.js", [c["Core/Animation/AnimationUtilities.js"], c["Core/FormatUtilities.js"], c["Core/Globals.js"], c["Core/Series/Point.js"], c["Core/Renderer/RendererUtilities.js"], c["Core/Utilities.js"]], function (a, b, c, d, e, f) {
        var g = a.animObject, h = a.setAnimation, i = b.format;
        a = c.isFirefox;
        var j = c.marginNames;
        c = c.win;
        var k = e.distribute, l = f.addEvent, m = f.createElement, n = f.css, o = f.defined, p = f.discardElement, q = f.find, r = f.fireEvent, s = f.isNumber, t = f.merge, u = f.pick, v = f.relativeLength, w = f.stableSort, x = f.syncTimeout;
        e = f.wrap;
        f = function () {
            function a(a, b) {
                this.allItems = [];
                this.contentGroup = this.box = void 0;
                this.display = !1;
                this.group = void 0;
                this.offsetWidth = this.maxLegendWidth = this.maxItemWidth = this.legendWidth = this.legendHeight = this.lastLineHeight = this.lastItemY = this.itemY = this.itemX = this.itemMarginTop = this.itemMarginBottom = this.itemHeight = this.initialItemY = 0;
                this.options = void 0;
                this.padding = 0;
                this.pages = [];
                this.proximate = !1;
                this.scrollGroup = void 0;
                this.widthOption = this.totalItemWidth = this.titleHeight = this.symbolWidth = this.symbolHeight = 0;
                this.chart = a;
                this.init(a, b);
            }
            a.prototype.init = function (a, b) {
                this.chart = a;
                this.setOptions(b);
                b.enabled && (this.render(), l(this.chart, "endResize", function () {
                    this.legend.positionCheckboxes();
                }), this.proximate ? this.unchartrender = l(this.chart, "render", function () {
                    this.legend.proximatePositions();
                    this.legend.positionItems();
                }) : this.unchartrender && this.unchartrender());
            };
            a.prototype.setOptions = function (a) {
                var b = u(a.padding, 8);
                this.options = a;
                this.chart.styledMode || (this.itemStyle = a.itemStyle, this.itemHiddenStyle = t(this.itemStyle, a.itemHiddenStyle));
                this.itemMarginTop = a.itemMarginTop || 0;
                this.itemMarginBottom = a.itemMarginBottom || 0;
                this.padding = b;
                this.initialItemY = b - 5;
                this.symbolWidth = u(a.symbolWidth, 16);
                this.pages = [];
                this.proximate = "proximate" === a.layout && !this.chart.inverted;
                this.baseline = void 0;
            };
            a.prototype.update = function (a, b) {
                var c = this.chart;
                this.setOptions(t(!0, this.options, a));
                this.destroy();
                c.isDirtyLegend = c.isDirtyBox = !0;
                u(b, !0) && c.redraw();
                r(this, "afterUpdate");
            };
            a.prototype.colorizeItem = function (a, b) {
                a.legendGroup[b ? "removeClass" : "addClass"]("highcharts-legend-item-hidden");
                if (!this.chart.styledMode) {
                    var c = this.options, d = a.legendItem, e = a.legendLine, f = a.legendSymbol, g = this.itemHiddenStyle.color;
                    c = b ? c.itemStyle.color : g;
                    var h = b ? a.color || g : g, i = a.options && a.options.marker, j = {
                        fill: h
                    };
                    d && d.css({
                        fill: c,
                        color: c
                    });
                    e && e.attr({
                        stroke: h
                    });
                    f && (i && f.isMarker && (j = a.pointAttribs(), b || (j.stroke = j.fill = g)), f.attr(j));
                }
                r(this, "afterColorizeItem", {
                    item: a,
                    visible: b
                });
            };
            a.prototype.positionItems = function () {
                this.allItems.forEach(this.positionItem, this);
                this.chart.isResizing || this.positionCheckboxes();
            };
            a.prototype.positionItem = function (a) {
                var b = this, c = this.options, d = c.symbolPadding, e = !c.rtl, f = a._legendItemPos;
                c = f[0];
                f = f[1];
                var g = a.checkbox, h = a.legendGroup;
                h && h.element && (d = {
                    translateX: e ? c : this.legendWidth - c - 2 * d - 4,
                    translateY: f
                }, e = function () {
                    r(b, "afterPositionItem", {
                        item: a
                    });
                }, o(h.translateY) ? h.animate(d, void 0, e) : (h.attr(d), e()));
                g && (g.x = c, g.y = f);
            };
            a.prototype.destroyItem = function (a) {
                var b = a.checkbox;
                ["legendItem", "legendLine", "legendSymbol", "legendGroup"].forEach(function (b) {
                    a[b] && (a[b] = a[b].destroy());
                });
                b && p(a.checkbox);
            };
            a.prototype.destroy = function () {
                function a(a) {
                    this[a] && (this[a] = this[a].destroy());
                }
                this.getAllItems().forEach(function (b) {
                    ["legendItem", "legendGroup"].forEach(a, b);
                });
                "clipRect up down pager nav box title group".split(" ").forEach(a, this);
                this.display = null;
            };
            a.prototype.positionCheckboxes = function () {
                var a = this.group && this.group.alignAttr, b = this.clipHeight || this.legendHeight, c = this.titleHeight;
                if (a) {
                    var d = a.translateY;
                    this.allItems.forEach(function (e) {
                        var f = e.checkbox;
                        if (f) {
                            var g = d + c + f.y + (this.scrollOffset || 0) + 3;
                            n(f, {
                                left: a.translateX + e.checkboxOffset + f.x - 20 + "px",
                                top: g + "px",
                                display: this.proximate || g > d - 6 && g < d + b - 6 ? "" : "none"
                            });
                        }
                    }, this);
                }
            };
            a.prototype.renderTitle = function () {
                var a = this.options, b = this.padding, c = a.title, d = 0;
                c.text && (this.title || (this.title = this.chart.renderer.label(c.text, b - 3, b - 4, void 0, void 0, void 0, a.useHTML, void 0, "legend-title").attr({
                    zIndex: 1
                }), this.chart.styledMode || this.title.css(c.style), this.title.add(this.group)),
                    c.width || this.title.css({
                        width: this.maxLegendWidth + "px"
                    }), a = this.title.getBBox(), d = a.height, this.offsetWidth = a.width, this.contentGroup.attr({
                        translateY: d
                    }));
                this.titleHeight = d;
            };
            a.prototype.setText = function (a) {
                var b = this.options;
                a.legendItem.attr({
                    text: b.labelFormat ? i(b.labelFormat, a, this.chart) : b.labelFormatter.call(a)
                });
            };
            a.prototype.renderItem = function (a) {
                var b = this.chart, c = b.renderer, d = this.options, e = this.symbolWidth, f = d.symbolPadding || 0, g = this.itemStyle, h = this.itemHiddenStyle, i = "horizontal" === d.layout ? u(d.itemDistance, 20) : 0, j = !d.rtl, k = !a.series, l = !k && a.series.drawLegendSymbol ? a.series : a, m = l.options, n = this.createCheckboxForItem && m && m.showCheckbox, o = d.useHTML, p = a.options.className, q = a.legendItem;
                m = e + f + i + (n ? 20 : 0);
                q || (a.legendGroup = c.g("legend-item").addClass("highcharts-" + l.type + "-series highcharts-color-" + a.colorIndex + (p ? " " + p : "") + (k ? " highcharts-series-" + a.index : "")).attr({
                    zIndex: 1
                }).add(this.scrollGroup), a.legendItem = q = c.text("", j ? e + f : -f, this.baseline || 0, o),
                    b.styledMode || q.css(t(a.visible ? g : h)), q.attr({
                        align: j ? "left" : "right",
                        zIndex: 2
                    }).add(a.legendGroup), this.baseline || (this.fontMetrics = c.fontMetrics(b.styledMode ? 12 : g.fontSize, q),
                        this.baseline = this.fontMetrics.f + 3 + this.itemMarginTop, q.attr("y", this.baseline),
                        this.symbolHeight = d.symbolHeight || this.fontMetrics.f, d.squareSymbol && (this.symbolWidth = u(d.symbolWidth, Math.max(this.symbolHeight, 16)),
                            m = this.symbolWidth + f + i + (n ? 20 : 0), j && q.attr("x", this.symbolWidth + f))),
                    l.drawLegendSymbol(this, a), this.setItemEvents && this.setItemEvents(a, q, o));
                n && !a.checkbox && this.createCheckboxForItem && this.createCheckboxForItem(a);
                this.colorizeItem(a, a.visible);
                !b.styledMode && g.width || q.css({
                    width: (d.itemWidth || this.widthOption || b.spacingBox.width) - m + "px"
                });
                this.setText(a);
                b = q.getBBox();
                c = this.fontMetrics && this.fontMetrics.h || 0;
                a.itemWidth = a.checkboxOffset = d.itemWidth || a.legendItemWidth || b.width + m;
                this.maxItemWidth = Math.max(this.maxItemWidth, a.itemWidth);
                this.totalItemWidth += a.itemWidth;
                this.itemHeight = a.itemHeight = Math.round(a.legendItemHeight || (b.height > 1.5 * c ? b.height : c));
            };
            a.prototype.layoutItem = function (a) {
                var b = this.options, c = this.padding, d = "horizontal" === b.layout, e = a.itemHeight, f = this.itemMarginBottom, g = this.itemMarginTop, h = d ? u(b.itemDistance, 20) : 0, i = this.maxLegendWidth;
                b = b.alignColumns && this.totalItemWidth > i ? this.maxItemWidth : a.itemWidth;
                d && this.itemX - c + b > i && (this.itemX = c, this.lastLineHeight && (this.itemY += g + this.lastLineHeight + f),
                    this.lastLineHeight = 0);
                this.lastItemY = g + this.itemY + f;
                this.lastLineHeight = Math.max(e, this.lastLineHeight);
                a._legendItemPos = [this.itemX, this.itemY];
                d ? this.itemX += b : (this.itemY += g + e + f, this.lastLineHeight = e);
                this.offsetWidth = this.widthOption || Math.max((d ? this.itemX - c - (a.checkbox ? 0 : h) : b) + c, this.offsetWidth);
            };
            a.prototype.getAllItems = function () {
                var a = [];
                this.chart.series.forEach(function (b) {
                    var c = b && b.options;
                    b && u(c.showInLegend, o(c.linkedTo) ? !1 : void 0, !0) && (a = a.concat(b.legendItems || ("point" === c.legendType ? b.data : b)));
                });
                r(this, "afterGetAllItems", {
                    allItems: a
                });
                return a;
            };
            a.prototype.getAlignment = function () {
                var a = this.options;
                return this.proximate ? a.align.charAt(0) + "tv" : a.floating ? "" : a.align.charAt(0) + a.verticalAlign.charAt(0) + a.layout.charAt(0);
            };
            a.prototype.adjustMargins = function (a, b) {
                var c = this.chart, d = this.options, e = this.getAlignment();
                e && [/(lth|ct|rth)/, /(rtv|rm|rbv)/, /(rbh|cb|lbh)/, /(lbv|lm|ltv)/].forEach(function (f, g) {
                    f.test(e) && !o(a[g]) && (c[j[g]] = Math.max(c[j[g]], c.legend[(g + 1) % 2 ? "legendHeight" : "legendWidth"] + [1, -1, -1, 1][g] * d[g % 2 ? "x" : "y"] + u(d.margin, 12) + b[g] + (c.titleOffset[g] || 0)));
                });
            };
            a.prototype.proximatePositions = function () {
                var a = this.chart, b = [], c = "left" === this.options.align;
                this.allItems.forEach(function (d) {
                    var e;
                    var f = c;
                    if (d.yAxis) {
                        d.xAxis.options.reversed && (f = !f);
                        d.points && (e = q(f ? d.points : d.points.slice(0).reverse(), function (a) {
                            return s(a.plotY);
                        }));
                        f = this.itemMarginTop + d.legendItem.getBBox().height + this.itemMarginBottom;
                        var g = d.yAxis.top - a.plotTop;
                        d.visible ? (e = e ? e.plotY : d.yAxis.height, e += g - .3 * f) : e = g + d.yAxis.height;
                        b.push({
                            target: e,
                            size: f,
                            item: d
                        });
                    }
                }, this);
                k(b, a.plotHeight).forEach(function (b) {
                    b.item._legendItemPos && (b.item._legendItemPos[1] = a.plotTop - a.spacing[0] + b.pos);
                });
            };
            a.prototype.render = function () {
                var a = this.chart, b = a.renderer, c = this.options, d = this.padding, e = this.getAllItems(), f = this.group, g = this.box;
                this.itemX = d;
                this.itemY = this.initialItemY;
                this.lastItemY = this.offsetWidth = 0;
                this.widthOption = v(c.width, a.spacingBox.width - d);
                var h = a.spacingBox.width - 2 * d - c.x;
                -1 < ["rm", "lm"].indexOf(this.getAlignment().substring(0, 2)) && (h /= 2);
                this.maxLegendWidth = this.widthOption || h;
                f || (this.group = f = b.g("legend").addClass(c.className || "").attr({
                    zIndex: 7
                }).add(), this.contentGroup = b.g().attr({
                    zIndex: 1
                }).add(f), this.scrollGroup = b.g().add(this.contentGroup));
                this.renderTitle();
                w(e, function (a, b) {
                    return (a.options && a.options.legendIndex || 0) - (b.options && b.options.legendIndex || 0);
                });
                c.reversed && e.reverse();
                this.allItems = e;
                this.display = h = !!e.length;
                this.itemHeight = this.totalItemWidth = this.maxItemWidth = this.lastLineHeight = 0;
                e.forEach(this.renderItem, this);
                e.forEach(this.layoutItem, this);
                e = (this.widthOption || this.offsetWidth) + d;
                var i = this.lastItemY + this.lastLineHeight + this.titleHeight;
                i = this.handleOverflow(i);
                i += d;
                g || (this.box = g = b.rect().addClass("highcharts-legend-box").attr({
                    r: c.borderRadius
                }).add(f));
                a.styledMode || g.attr({
                    stroke: c.borderColor,
                    "stroke-width": c.borderWidth || 0,
                    fill: c.backgroundColor || "none"
                }).shadow(c.shadow);
                if (0 < e && 0 < i) g[g.placed ? "animate" : "attr"](g.crisp.call({}, {
                    x: 0,
                    y: 0,
                    width: e,
                    height: i
                }, g.strokeWidth()));
                g[h ? "show" : "hide"]();
                a.styledMode && "none" === f.getStyle("display") && (e = i = 0);
                this.legendWidth = e;
                this.legendHeight = i;
                h && this.align();
                this.proximate || this.positionItems();
                r(this, "afterRender");
            };
            a.prototype.align = function (a) {
                void 0 === a && (a = this.chart.spacingBox);
                var b = this.chart, c = this.options, d = a.y;
                /(lth|ct|rth)/.test(this.getAlignment()) && 0 < b.titleOffset[0] ? d += b.titleOffset[0] : /(lbh|cb|rbh)/.test(this.getAlignment()) && 0 < b.titleOffset[2] && (d -= b.titleOffset[2]);
                d !== a.y && (a = t(a, {
                    y: d
                }));
                b.hasRendered || (this.group.placed = !1);
                this.group.align(t(c, {
                    width: this.legendWidth,
                    height: this.legendHeight,
                    verticalAlign: this.proximate ? "top" : c.verticalAlign
                }), !0, a);
            };
            a.prototype.handleOverflow = function (a) {
                var b = this, c = this.chart, d = c.renderer, e = this.options, f = e.y, g = "top" === e.verticalAlign, h = this.padding, i = e.maxHeight, j = e.navigation, k = u(j.animation, !0), l = j.arrowSize || 12, m = this.pages, n = this.allItems, o = function (a) {
                    "number" === typeof a ? t.attr({
                        height: a
                    }) : t && (b.clipRect = t.destroy(), b.contentGroup.clip());
                    b.contentGroup.div && (b.contentGroup.div.style.clip = a ? "rect(" + h + "px,9999px," + (h + a) + "px,0)" : "auto");
                }, p = function (a) {
                    b[a] = d.circle(0, 0, 1.3 * l).translate(l / 2, l / 2).add(s);
                    c.styledMode || b[a].attr("fill", "rgba(0,0,0,0.0001)");
                    return b[a];
                }, q, r;
                f = c.spacingBox.height + (g ? -f : f) - h;
                var s = this.nav, t = this.clipRect;
                "horizontal" !== e.layout || "middle" === e.verticalAlign || e.floating || (f /= 2);
                i && (f = Math.min(f, i));
                m.length = 0;
                a && 0 < f && a > f && !1 !== j.enabled ? (this.clipHeight = q = Math.max(f - 20 - this.titleHeight - h, 0),
                    this.currentPage = u(this.currentPage, 1), this.fullHeight = a, n.forEach(function (a, b) {
                        var c = a._legendItemPos[1], d = Math.round(a.legendItem.getBBox().height), e = m.length;
                        if (!e || c - m[e - 1] > q && (r || c) !== m[e - 1]) m.push(r || c), e++;
                        a.pageIx = e - 1;
                        r && (n[b - 1].pageIx = e - 1);
                        b === n.length - 1 && c + d - m[e - 1] > q && d <= q && (m.push(c), a.pageIx = e);
                        c !== r && (r = c);
                    }), t || (t = b.clipRect = d.clipRect(0, h, 9999, 0), b.contentGroup.clip(t)), o(q),
                    s || (this.nav = s = d.g().attr({
                        zIndex: 1
                    }).add(this.group), this.up = d.symbol("triangle", 0, 0, l, l).add(s), p("upTracker").on("click", function () {
                        b.scroll(-1, k);
                    }), this.pager = d.text("", 15, 10).addClass("highcharts-legend-navigation"), !c.styledMode && j.style && this.pager.css(j.style),
                        this.pager.add(s), this.down = d.symbol("triangle-down", 0, 0, l, l).add(s), p("downTracker").on("click", function () {
                            b.scroll(1, k);
                        })), b.scroll(0), a = f) : s && (o(), this.nav = s.destroy(), this.scrollGroup.attr({
                            translateY: 1
                        }), this.clipHeight = 0);
                return a;
            };
            a.prototype.scroll = function (a, b) {
                var c = this, d = this.chart, e = this.pages, f = e.length, i = this.clipHeight, j = this.options.navigation, k = this.pager, l = this.padding, m = this.currentPage + a;
                m > f && (m = f);
                0 < m && ("undefined" !== typeof b && h(b, d), this.nav.attr({
                    translateX: l,
                    translateY: i + this.padding + 7 + this.titleHeight,
                    visibility: "visible"
                }), [this.up, this.upTracker].forEach(function (a) {
                    a.attr({
                        "class": 1 === m ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active"
                    });
                }), k.attr({
                    text: m + "/" + f
                }), [this.down, this.downTracker].forEach(function (a) {
                    a.attr({
                        x: 18 + this.pager.getBBox().width,
                        "class": m === f ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active"
                    });
                }, this), d.styledMode || (this.up.attr({
                    fill: 1 === m ? j.inactiveColor : j.activeColor
                }), this.upTracker.css({
                    cursor: 1 === m ? "default" : "pointer"
                }), this.down.attr({
                    fill: m === f ? j.inactiveColor : j.activeColor
                }), this.downTracker.css({
                    cursor: m === f ? "default" : "pointer"
                })), this.scrollOffset = -e[m - 1] + this.initialItemY, this.scrollGroup.animate({
                    translateY: this.scrollOffset
                }), this.currentPage = m, this.positionCheckboxes(), a = g(u(b, d.renderer.globalAnimation, !0)),
                    x(function () {
                        r(c, "afterScroll", {
                            currentPage: m
                        });
                    }, a.duration));
            };
            a.prototype.setItemEvents = function (a, b, c) {
                var e = this, f = e.chart.renderer.boxWrapper, g = a instanceof d, h = "highcharts-legend-" + (g ? "point" : "series") + "-active", i = e.chart.styledMode, j = function (b) {
                    e.allItems.forEach(function (c) {
                        a !== c && [c].concat(c.linkedSeries || []).forEach(function (a) {
                            a.setState(b, !g);
                        });
                    });
                };
                (c ? [b, a.legendSymbol] : [a.legendGroup]).forEach(function (c) {
                    if (c) c.on("mouseover", function () {
                        a.visible && j("inactive");
                        a.setState("hover");
                        a.visible && f.addClass(h);
                        i || b.css(e.options.itemHoverStyle);
                    }).on("mouseout", function () {
                        e.chart.styledMode || b.css(t(a.visible ? e.itemStyle : e.itemHiddenStyle));
                        j("");
                        f.removeClass(h);
                        a.setState();
                    }).on("click", function (b) {
                        var c = function () {
                            a.setVisible && a.setVisible();
                            j(a.visible ? "inactive" : "");
                        };
                        f.removeClass(h);
                        b = {
                            browserEvent: b
                        };
                        a.firePointEvent ? a.firePointEvent("legendItemClick", b, c) : r(a, "legendItemClick", b, c);
                    });
                });
            };
            a.prototype.createCheckboxForItem = function (a) {
                a.checkbox = m("input", {
                    type: "checkbox",
                    className: "highcharts-legend-checkbox",
                    checked: a.selected,
                    defaultChecked: a.selected
                }, this.options.itemCheckboxStyle, this.chart.container);
                l(a.checkbox, "click", function (b) {
                    r(a.series || a, "checkboxClick", {
                        checked: b.target.checked,
                        item: a
                    }, function () {
                        a.select();
                    });
                });
            };
            return a;
        }();
        (/Trident\/7\.0/.test(c.navigator && c.navigator.userAgent) || a) && e(f.prototype, "positionItem", function (a, b) {
            var c = this, d = function () {
                b._legendItemPos && a.call(c, b);
            };
            d();
            c.bubbleLegend || setTimeout(d);
        });
        return f;
    });
    b(c, "Core/Series/SeriesRegistry.js", [c["Core/Globals.js"], c["Core/DefaultOptions.js"], c["Core/Series/Point.js"], c["Core/Utilities.js"]], function (a, b, c, d) {
        var e = b.defaultOptions, f = d.error, g = d.extendClass, h = d.merge, i;
        !function (b) {
            function d(a, d) {
                var f = e.plotOptions || {}, g = d.defaultOptions;
                d.prototype.pointClass || (d.prototype.pointClass = c);
                d.prototype.type = a;
                g && (f[a] = g);
                b.seriesTypes[a] = d;
            }
            b.seriesTypes = a.seriesTypes;
            b.getSeries = function (a, c) {
                void 0 === c && (c = {});
                var d = a.options.chart;
                d = c.type || d.type || d.defaultSeriesType || "";
                var e = b.seriesTypes[d];
                b || f(17, !0, a, {
                    missingModuleFor: d
                });
                d = new e();
                "function" === typeof d.init && d.init(a, c);
                return d;
            };
            b.registerSeriesType = d;
            b.seriesType = function (a, f, i, j, k) {
                var l = e.plotOptions || {};
                f = f || "";
                l[a] = h(l[f], i);
                d(a, g(b.seriesTypes[f] || function () { }, j));
                b.seriesTypes[a].prototype.type = a;
                k && (b.seriesTypes[a].prototype.pointClass = g(c, k));
                return b.seriesTypes[a];
            };
        }(i || (i = {}));
        return i;
    });
    b(c, "Core/Chart/Chart.js", [c["Core/Animation/AnimationUtilities.js"], c["Core/Axis/Axis.js"], c["Core/FormatUtilities.js"], c["Core/Foundation.js"], c["Core/Globals.js"], c["Core/Legend/Legend.js"], c["Core/MSPointer.js"], c["Core/DefaultOptions.js"], c["Core/Pointer.js"], c["Core/Renderer/RendererRegistry.js"], c["Core/Series/SeriesRegistry.js"], c["Core/Renderer/SVG/SVGRenderer.js"], c["Core/Time.js"], c["Core/Utilities.js"], c["Core/Renderer/HTML/AST.js"]], function (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o) {
        var p = a.animate, q = a.animObject, r = a.setAnimation, s = c.numberFormat, t = d.registerEventOptions, u = e.charts, v = e.doc, w = e.marginNames, x = e.svg, y = e.win, z = h.defaultOptions, A = h.defaultTime, B = k.seriesTypes, C = n.addEvent, D = n.attr, E = n.cleanRecursively, F = n.createElement, G = n.css, H = n.defined, I = n.discardElement, J = n.erase, K = n.error, L = n.extend, M = n.find, N = n.fireEvent, O = n.getStyle, P = n.isArray, Q = n.isNumber, R = n.isObject, S = n.isString, T = n.merge, U = n.objectEach, V = n.pick, W = n.pInt, X = n.relativeLength, Y = n.removeEvent, Z = n.splat, $ = n.syncTimeout, _ = n.uniqueKey;
        a = function () {
            function a(a, b, c) {
                this.series = this.renderTo = this.renderer = this.pointer = this.pointCount = this.plotWidth = this.plotTop = this.plotLeft = this.plotHeight = this.plotBox = this.options = this.numberFormatter = this.margin = this.legend = this.labelCollectors = this.isResizing = this.index = this.eventOptions = this.container = this.colorCounter = this.clipBox = this.chartWidth = this.chartHeight = this.bounds = this.axisOffset = this.axes = void 0;
                this.sharedClips = {};
                this.yAxis = this.xAxis = this.userOptions = this.titleOffset = this.time = this.symbolCounter = this.spacingBox = this.spacing = void 0;
                this.getArgs(a, b, c);
            }
            a.chart = function (b, c, d) {
                return new a(b, c, d);
            };
            a.prototype.getArgs = function (a, b, c) {
                S(a) || a.nodeName ? (this.renderTo = a, this.init(b, c)) : this.init(a, b);
            };
            a.prototype.init = function (a, b) {
                var c = a.plotOptions || {};
                N(this, "init", {
                    args: arguments
                }, function () {
                    var d = T(z, a), f = d.chart;
                    U(d.plotOptions, function (a, b) {
                        R(a) && (a.tooltip = c[b] && T(c[b].tooltip) || void 0);
                    });
                    d.tooltip.userOptions = a.chart && a.chart.forExport && a.tooltip.userOptions || a.tooltip;
                    this.userOptions = a;
                    this.margin = [];
                    this.spacing = [];
                    this.bounds = {
                        h: {},
                        v: {}
                    };
                    this.labelCollectors = [];
                    this.callback = b;
                    this.isResizing = 0;
                    this.options = d;
                    this.axes = [];
                    this.series = [];
                    this.time = a.time && Object.keys(a.time).length ? new m(a.time) : e.time;
                    this.numberFormatter = f.numberFormatter || s;
                    this.styledMode = f.styledMode;
                    this.hasCartesianSeries = f.showAxes;
                    this.index = u.length;
                    u.push(this);
                    e.chartCount++;
                    t(this, f);
                    this.xAxis = [];
                    this.yAxis = [];
                    this.pointCount = this.colorCounter = this.symbolCounter = 0;
                    N(this, "afterInit");
                    this.firstRender();
                });
            };
            a.prototype.initSeries = function (a) {
                var b = this.options.chart;
                b = a.type || b.type || b.defaultSeriesType;
                var c = B[b];
                c || K(17, !0, this, {
                    missingModuleFor: b
                });
                b = new c();
                "function" === typeof b.init && b.init(this, a);
                return b;
            };
            a.prototype.setSeriesData = function () {
                this.getSeriesOrderByLinks().forEach(function (a) {
                    a.points || a.data || !a.enabledDataSorting || a.setData(a.options.data, !1);
                });
            };
            a.prototype.getSeriesOrderByLinks = function () {
                return this.series.concat().sort(function (a, b) {
                    return a.linkedSeries.length || b.linkedSeries.length ? b.linkedSeries.length - a.linkedSeries.length : 0;
                });
            };
            a.prototype.orderSeries = function (a) {
                var b = this.series;
                a = a || 0;
                for (var c = b.length; a < c; ++a) b[a] && (b[a].index = a, b[a].name = b[a].getName());
            };
            a.prototype.isInsidePlot = function (a, b, c) {
                void 0 === c && (c = {});
                var d = this.inverted, e = this.plotBox, f = this.plotLeft, g = this.plotTop, h = this.scrollablePlotBox, i = 0;
                var j = 0;
                c.visiblePlotOnly && this.scrollingContainer && (j = this.scrollingContainer, i = j.scrollLeft,
                    j = j.scrollTop);
                var k = c.series;
                e = c.visiblePlotOnly && h || e;
                h = c.inverted ? b : a;
                b = c.inverted ? a : b;
                a = {
                    x: h,
                    y: b,
                    isInsidePlot: !0
                };
                if (!c.ignoreX) {
                    var l = k && (d ? k.yAxis : k.xAxis) || {
                        pos: f,
                        len: 1 / 0
                    };
                    h = c.paneCoordinates ? l.pos + h : f + h;
                    h >= Math.max(i + f, l.pos) && h <= Math.min(i + f + e.width, l.pos + l.len) || (a.isInsidePlot = !1);
                }
                !c.ignoreY && a.isInsidePlot && (d = k && (d ? k.xAxis : k.yAxis) || {
                    pos: g,
                    len: 1 / 0
                }, c = c.paneCoordinates ? d.pos + b : g + b, c >= Math.max(j + g, d.pos) && c <= Math.min(j + g + e.height, d.pos + d.len) || (a.isInsidePlot = !1));
                N(this, "afterIsInsidePlot", a);
                return a.isInsidePlot;
            };
            a.prototype.redraw = function (a) {
                N(this, "beforeRedraw");
                var b = this.hasCartesianSeries ? this.axes : this.colorAxis || [], c = this.series, d = this.pointer, e = this.legend, f = this.userOptions.legend, g = this.renderer, h = g.isHidden(), i = [], j = this.isDirtyBox, k = this.isDirtyLegend;
                this.setResponsive && this.setResponsive(!1);
                r(this.hasRendered ? a : !1, this);
                h && this.temporaryDisplay();
                this.layOutTitles();
                for (a = c.length; a--;) {
                    var l = c[a];
                    if (l.options.stacking || l.options.centerInCategory) {
                        var m = !0;
                        if (l.isDirty) {
                            var n = !0;
                            break;
                        }
                    }
                }
                if (n) for (a = c.length; a--;) l = c[a], l.options.stacking && (l.isDirty = !0);
                c.forEach(function (a) {
                    a.isDirty && ("point" === a.options.legendType ? ("function" === typeof a.updateTotals && a.updateTotals(),
                        k = !0) : f && (f.labelFormatter || f.labelFormat) && (k = !0));
                    a.isDirtyData && N(a, "updatedData");
                });
                k && e && e.options.enabled && (e.render(), this.isDirtyLegend = !1);
                m && this.getStacks();
                b.forEach(function (a) {
                    a.updateNames();
                    a.setScale();
                });
                this.getMargins();
                b.forEach(function (a) {
                    a.isDirty && (j = !0);
                });
                b.forEach(function (a) {
                    var b = a.min + "," + a.max;
                    a.extKey !== b && (a.extKey = b, i.push(function () {
                        N(a, "afterSetExtremes", L(a.eventArgs, a.getExtremes()));
                        delete a.eventArgs;
                    }));
                    (j || m) && a.redraw();
                });
                j && this.drawChartBox();
                N(this, "predraw");
                c.forEach(function (a) {
                    (j || a.isDirty) && a.visible && a.redraw();
                    a.isDirtyData = !1;
                });
                d && d.reset(!0);
                g.draw();
                N(this, "redraw");
                N(this, "render");
                h && this.temporaryDisplay(!0);
                i.forEach(function (a) {
                    a.call();
                });
            };
            a.prototype.get = function (a) {
                function b(b) {
                    return b.id === a || b.options && b.options.id === a;
                }
                for (var c = this.series, d = M(this.axes, b) || M(this.series, b), e = 0; !d && e < c.length; e++) d = M(c[e].points || [], b);
                return d;
            };
            a.prototype.getAxes = function () {
                var a = this, c = this.options, d = c.xAxis = Z(c.xAxis || {});
                c = c.yAxis = Z(c.yAxis || {});
                N(this, "getAxes");
                d.forEach(function (a, b) {
                    a.index = b;
                    a.isX = !0;
                });
                c.forEach(function (a, b) {
                    a.index = b;
                });
                d.concat(c).forEach(function (c) {
                    new b(a, c);
                });
                N(this, "afterGetAxes");
            };
            a.prototype.getSelectedPoints = function () {
                return this.series.reduce(function (a, b) {
                    b.getPointsCollection().forEach(function (b) {
                        V(b.selectedStaging, b.selected) && a.push(b);
                    });
                    return a;
                }, []);
            };
            a.prototype.getSelectedSeries = function () {
                return this.series.filter(function (a) {
                    return a.selected;
                });
            };
            a.prototype.setTitle = function (a, b, c) {
                this.applyDescription("title", a);
                this.applyDescription("subtitle", b);
                this.applyDescription("caption", void 0);
                this.layOutTitles(c);
            };
            a.prototype.applyDescription = function (a, b) {
                var c = this, d = "title" === a ? {
                    color: "#333333",
                    fontSize: this.options.isStock ? "16px" : "18px"
                } : {
                    color: "#666666"
                };
                d = this.options[a] = T(!this.styledMode && {
                    style: d
                }, this.options[a], b);
                var e = this[a];
                e && b && (this[a] = e = e.destroy());
                d && !e && (e = this.renderer.text(d.text, 0, 0, d.useHTML).attr({
                    align: d.align,
                    "class": "highcharts-" + a,
                    zIndex: d.zIndex || 4
                }).add(), e.update = function (b) {
                    c[{
                        title: "setTitle",
                        subtitle: "setSubtitle",
                        caption: "setCaption"
                    }[a]](b);
                }, this.styledMode || e.css(d.style), this[a] = e);
            };
            a.prototype.layOutTitles = function (a) {
                var b = [0, 0, 0], c = this.renderer, d = this.spacingBox;
                ["title", "subtitle", "caption"].forEach(function (a) {
                    var e = this[a], f = this.options[a], g = f.verticalAlign || "top";
                    a = "title" === a ? "top" === g ? -3 : 0 : "top" === g ? b[0] + 2 : 0;
                    var h;
                    if (e) {
                        this.styledMode || (h = f.style && f.style.fontSize);
                        h = c.fontMetrics(h, e).b;
                        e.css({
                            width: (f.width || d.width + (f.widthAdjust || 0)) + "px"
                        });
                        var i = Math.round(e.getBBox(f.useHTML).height);
                        e.align(L({
                            y: "bottom" === g ? h : a + h,
                            height: i
                        }, f), !1, "spacingBox");
                        f.floating || ("top" === g ? b[0] = Math.ceil(b[0] + i) : "bottom" === g && (b[2] = Math.ceil(b[2] + i)));
                    }
                }, this);
                b[0] && "top" === (this.options.title.verticalAlign || "top") && (b[0] += this.options.title.margin);
                b[2] && "bottom" === this.options.caption.verticalAlign && (b[2] += this.options.caption.margin);
                var e = !this.titleOffset || this.titleOffset.join(",") !== b.join(",");
                this.titleOffset = b;
                N(this, "afterLayOutTitles");
                !this.isDirtyBox && e && (this.isDirtyBox = this.isDirtyLegend = e, this.hasRendered && V(a, !0) && this.isDirtyBox && this.redraw());
            };
            a.prototype.getChartSize = function () {
                var a = this.options.chart, b = a.width;
                a = a.height;
                var c = this.renderTo;
                H(b) || (this.containerWidth = O(c, "width"));
                H(a) || (this.containerHeight = O(c, "height"));
                this.chartWidth = Math.max(0, b || this.containerWidth || 600);
                this.chartHeight = Math.max(0, X(a, this.chartWidth) || (1 < this.containerHeight ? this.containerHeight : 400));
            };
            a.prototype.temporaryDisplay = function (a) {
                var b = this.renderTo;
                if (a) for (; b && b.style;) b.hcOrigStyle && (G(b, b.hcOrigStyle), delete b.hcOrigStyle),
                    b.hcOrigDetached && (v.body.removeChild(b), b.hcOrigDetached = !1), b = b.parentNode; else for (; b && b.style;) {
                        v.body.contains(b) || b.parentNode || (b.hcOrigDetached = !0, v.body.appendChild(b));
                        if ("none" === O(b, "display", !1) || b.hcOricDetached) b.hcOrigStyle = {
                            display: b.style.display,
                            height: b.style.height,
                            overflow: b.style.overflow
                        }, a = {
                            display: "block",
                            overflow: "hidden"
                        }, b !== this.renderTo && (a.height = 0), G(b, a), b.offsetWidth || b.style.setProperty("display", "block", "important");
                        b = b.parentNode;
                        if (b === v.body) break;
                    }
            };
            a.prototype.setClassName = function (a) {
                this.container.className = "highcharts-container " + (a || "");
            };
            a.prototype.getContainer = function () {
                var a = this.options, b = a.chart, c = _(), d, e = this.renderTo;
                e || (this.renderTo = e = b.renderTo);
                S(e) && (this.renderTo = e = v.getElementById(e));
                e || K(13, !0, this);
                var f = W(D(e, "data-highcharts-chart"));
                Q(f) && u[f] && u[f].hasRendered && u[f].destroy();
                D(e, "data-highcharts-chart", this.index);
                e.innerHTML = o.emptyHTML;
                b.skipClone || e.offsetWidth || this.temporaryDisplay();
                this.getChartSize();
                f = this.chartWidth;
                var g = this.chartHeight;
                G(e, {
                    overflow: "hidden"
                });
                this.styledMode || (d = L({
                    position: "relative",
                    overflow: "hidden",
                    width: f + "px",
                    height: g + "px",
                    textAlign: "left",
                    lineHeight: "normal",
                    zIndex: 0,
                    "-webkit-tap-highlight-color": "rgba(0,0,0,0)",
                    userSelect: "none",
                    "touch-action": "manipulation",
                    outline: "none"
                }, b.style || {}));
                this.container = c = F("div", {
                    id: c
                }, d, e);
                this._cursor = c.style.cursor;
                this.renderer = new (b.renderer || !x ? j.getRendererType(b.renderer) : l)(c, f, g, void 0, b.forExport, a.exporting && a.exporting.allowHTML, this.styledMode);
                r(void 0, this);
                this.setClassName(b.className);
                if (this.styledMode) for (var h in a.defs) this.renderer.definition(a.defs[h]); else this.renderer.setStyle(b.style);
                this.renderer.chartIndex = this.index;
                N(this, "afterGetContainer");
            };
            a.prototype.getMargins = function (a) {
                var b = this.spacing, c = this.margin, d = this.titleOffset;
                this.resetMargins();
                d[0] && !H(c[0]) && (this.plotTop = Math.max(this.plotTop, d[0] + b[0]));
                d[2] && !H(c[2]) && (this.marginBottom = Math.max(this.marginBottom, d[2] + b[2]));
                this.legend && this.legend.display && this.legend.adjustMargins(c, b);
                N(this, "getMargins");
                a || this.getAxisMargins();
            };
            a.prototype.getAxisMargins = function () {
                var a = this, b = a.axisOffset = [0, 0, 0, 0], c = a.colorAxis, d = a.margin, e = function (a) {
                    a.forEach(function (a) {
                        a.visible && a.getOffset();
                    });
                };
                a.hasCartesianSeries ? e(a.axes) : c && c.length && e(c);
                w.forEach(function (c, e) {
                    H(d[e]) || (a[c] += b[e]);
                });
                a.setChartSize();
            };
            a.prototype.reflow = function (a) {
                var b = this, c = b.options.chart, d = b.renderTo, e = H(c.width) && H(c.height), f = c.width || O(d, "width");
                c = c.height || O(d, "height");
                d = a ? a.target : y;
                delete b.pointer.chartPosition;
                if (!e && !b.isPrinting && f && c && (d === y || d === v)) {
                    if (f !== b.containerWidth || c !== b.containerHeight) n.clearTimeout(b.reflowTimeout),
                        b.reflowTimeout = $(function () {
                            b.container && b.setSize(void 0, void 0, !1);
                        }, a ? 100 : 0);
                    b.containerWidth = f;
                    b.containerHeight = c;
                }
            };
            a.prototype.setReflow = function (a) {
                var b = this;
                !1 === a || this.unbindReflow ? !1 === a && this.unbindReflow && (this.unbindReflow = this.unbindReflow()) : (this.unbindReflow = C(y, "resize", function (a) {
                    b.options && b.reflow(a);
                }), C(this, "destroy", this.unbindReflow));
            };
            a.prototype.setSize = function (a, b, c) {
                var d = this, e = d.renderer;
                d.isResizing += 1;
                r(c, d);
                c = e.globalAnimation;
                d.oldChartHeight = d.chartHeight;
                d.oldChartWidth = d.chartWidth;
                "undefined" !== typeof a && (d.options.chart.width = a);
                "undefined" !== typeof b && (d.options.chart.height = b);
                d.getChartSize();
                d.styledMode || (c ? p : G)(d.container, {
                    width: d.chartWidth + "px",
                    height: d.chartHeight + "px"
                }, c);
                d.setChartSize(!0);
                e.setSize(d.chartWidth, d.chartHeight, c);
                d.axes.forEach(function (a) {
                    a.isDirty = !0;
                    a.setScale();
                });
                d.isDirtyLegend = !0;
                d.isDirtyBox = !0;
                d.layOutTitles();
                d.getMargins();
                d.redraw(c);
                d.oldChartHeight = null;
                N(d, "resize");
                $(function () {
                    d && N(d, "endResize", null, function () {
                        --d.isResizing;
                    });
                }, q(c).duration);
            };
            a.prototype.setChartSize = function (a) {
                var b = this.inverted, c = this.renderer, d = this.chartWidth, e = this.chartHeight, f = this.options.chart, g = this.spacing, h = this.clipOffset, i, j, k, l;
                this.plotLeft = i = Math.round(this.plotLeft);
                this.plotTop = j = Math.round(this.plotTop);
                this.plotWidth = k = Math.max(0, Math.round(d - i - this.marginRight));
                this.plotHeight = l = Math.max(0, Math.round(e - j - this.marginBottom));
                this.plotSizeX = b ? l : k;
                this.plotSizeY = b ? k : l;
                this.plotBorderWidth = f.plotBorderWidth || 0;
                this.spacingBox = c.spacingBox = {
                    x: g[3],
                    y: g[0],
                    width: d - g[3] - g[1],
                    height: e - g[0] - g[2]
                };
                this.plotBox = c.plotBox = {
                    x: i,
                    y: j,
                    width: k,
                    height: l
                };
                b = 2 * Math.floor(this.plotBorderWidth / 2);
                d = Math.ceil(Math.max(b, h[3]) / 2);
                e = Math.ceil(Math.max(b, h[0]) / 2);
                this.clipBox = {
                    x: d,
                    y: e,
                    width: Math.floor(this.plotSizeX - Math.max(b, h[1]) / 2 - d),
                    height: Math.max(0, Math.floor(this.plotSizeY - Math.max(b, h[2]) / 2 - e))
                };
                a || (this.axes.forEach(function (a) {
                    a.setAxisSize();
                    a.setAxisTranslation();
                }), c.alignElements());
                N(this, "afterSetChartSize", {
                    skipAxes: a
                });
            };
            a.prototype.resetMargins = function () {
                N(this, "resetMargins");
                var a = this, b = a.options.chart;
                ["margin", "spacing"].forEach(function (c) {
                    var d = b[c], e = R(d) ? d : [d, d, d, d];
                    ["Top", "Right", "Bottom", "Left"].forEach(function (d, f) {
                        a[c][f] = V(b[c + d], e[f]);
                    });
                });
                w.forEach(function (b, c) {
                    a[b] = V(a.margin[c], a.spacing[c]);
                });
                a.axisOffset = [0, 0, 0, 0];
                a.clipOffset = [0, 0, 0, 0];
            };
            a.prototype.drawChartBox = function () {
                var a = this.options.chart, b = this.renderer, c = this.chartWidth, d = this.chartHeight, e = this.styledMode, f = this.plotBGImage, g = a.backgroundColor, h = a.plotBackgroundColor, i = a.plotBackgroundImage, j = this.plotLeft, k = this.plotTop, l = this.plotWidth, m = this.plotHeight, n = this.plotBox, o = this.clipRect, p = this.clipBox, q = this.chartBackground, r = this.plotBackground, s = this.plotBorder, t, u = "animate";
                q || (this.chartBackground = q = b.rect().addClass("highcharts-background").add(),
                    u = "attr");
                if (e) var v = t = q.strokeWidth(); else {
                    v = a.borderWidth || 0;
                    t = v + (a.shadow ? 8 : 0);
                    g = {
                        fill: g || "none"
                    };
                    if (v || q["stroke-width"]) g.stroke = a.borderColor, g["stroke-width"] = v;
                    q.attr(g).shadow(a.shadow);
                }
                q[u]({
                    x: t / 2,
                    y: t / 2,
                    width: c - t - v % 2,
                    height: d - t - v % 2,
                    r: a.borderRadius
                });
                u = "animate";
                r || (u = "attr", this.plotBackground = r = b.rect().addClass("highcharts-plot-background").add());
                r[u](n);
                e || (r.attr({
                    fill: h || "none"
                }).shadow(a.plotShadow), i && (f ? (i !== f.attr("href") && f.attr("href", i), f.animate(n)) : this.plotBGImage = b.image(i, j, k, l, m).add()));
                o ? o.animate({
                    width: p.width,
                    height: p.height
                }) : this.clipRect = b.clipRect(p);
                u = "animate";
                s || (u = "attr", this.plotBorder = s = b.rect().addClass("highcharts-plot-border").attr({
                    zIndex: 1
                }).add());
                e || s.attr({
                    stroke: a.plotBorderColor,
                    "stroke-width": a.plotBorderWidth || 0,
                    fill: "none"
                });
                s[u](s.crisp({
                    x: j,
                    y: k,
                    width: l,
                    height: m
                }, -s.strokeWidth()));
                this.isDirtyBox = !1;
                N(this, "afterDrawChartBox");
            };
            a.prototype.propFromSeries = function () {
                var a = this, b = a.options.chart, c = a.options.series, d, e, f;
                ["inverted", "angular", "polar"].forEach(function (g) {
                    e = B[b.type || b.defaultSeriesType];
                    f = b[g] || e && e.prototype[g];
                    for (d = c && c.length; !f && d--;) (e = B[c[d].type]) && e.prototype[g] && (f = !0);
                    a[g] = f;
                });
            };
            a.prototype.linkSeries = function () {
                var a = this, b = a.series;
                b.forEach(function (a) {
                    a.linkedSeries.length = 0;
                });
                b.forEach(function (b) {
                    var c = b.options.linkedTo;
                    S(c) && (c = ":previous" === c ? a.series[b.index - 1] : a.get(c)) && c.linkedParent !== b && (c.linkedSeries.push(b),
                        b.linkedParent = c, c.enabledDataSorting && b.setDataSortingOptions(), b.visible = V(b.options.visible, c.options.visible, b.visible));
                });
                N(this, "afterLinkSeries");
            };
            a.prototype.renderSeries = function () {
                this.series.forEach(function (a) {
                    a.translate();
                    a.render();
                });
            };
            a.prototype.renderLabels = function () {
                var a = this, b = a.options.labels;
                b.items && b.items.forEach(function (c) {
                    var d = L(b.style, c.style), e = W(d.left) + a.plotLeft, f = W(d.top) + a.plotTop + 12;
                    delete d.left;
                    delete d.top;
                    a.renderer.text(c.html, e, f).attr({
                        zIndex: 2
                    }).css(d).add();
                });
            };
            a.prototype.render = function () {
                var a = this.axes, b = this.colorAxis, c = this.renderer, d = this.options, e = function (a) {
                    a.forEach(function (a) {
                        a.visible && a.render();
                    });
                }, g = 0;
                this.setTitle();
                this.legend = new f(this, d.legend);
                this.getStacks && this.getStacks();
                this.getMargins(!0);
                this.setChartSize();
                d = this.plotWidth;
                a.some(function (a) {
                    if (a.horiz && a.visible && a.options.labels.enabled && a.series.length) return g = 21,
                        !0;
                });
                var h = this.plotHeight = Math.max(this.plotHeight - g, 0);
                a.forEach(function (a) {
                    a.setScale();
                });
                this.getAxisMargins();
                var i = 1.1 < d / this.plotWidth, j = 1.05 < h / this.plotHeight;
                if (i || j) a.forEach(function (a) {
                    (a.horiz && i || !a.horiz && j) && a.setTickInterval(!0);
                }), this.getMargins();
                this.drawChartBox();
                this.hasCartesianSeries ? e(a) : b && b.length && e(b);
                this.seriesGroup || (this.seriesGroup = c.g("series-group").attr({
                    zIndex: 3
                }).add());
                this.renderSeries();
                this.renderLabels();
                this.addCredits();
                this.setResponsive && this.setResponsive();
                this.hasRendered = !0;
            };
            a.prototype.addCredits = function (a) {
                var b = this, c = T(!0, this.options.credits, a);
                c.enabled && !this.credits && (this.credits = this.renderer.text(c.text + (this.mapCredits || ""), 0, 0).addClass("highcharts-credits").on("click", function () {
                    c.href && (y.location.href = c.href);
                }).attr({
                    align: c.position.align,
                    zIndex: 8
                }), b.styledMode || this.credits.css(c.style), this.credits.add().align(c.position),
                    this.credits.update = function (a) {
                        b.credits = b.credits.destroy();
                        b.addCredits(a);
                    });
            };
            a.prototype.destroy = function () {
                var a = this, b = a.axes, c = a.series, d = a.container, f = d && d.parentNode, g;
                N(a, "destroy");
                a.renderer.forExport ? J(u, a) : u[a.index] = void 0;
                e.chartCount--;
                a.renderTo.removeAttribute("data-highcharts-chart");
                Y(a);
                for (g = b.length; g--;) b[g] = b[g].destroy();
                this.scroller && this.scroller.destroy && this.scroller.destroy();
                for (g = c.length; g--;) c[g] = c[g].destroy();
                "title subtitle chartBackground plotBackground plotBGImage plotBorder seriesGroup clipRect credits pointer rangeSelector legend resetZoomButton tooltip renderer".split(" ").forEach(function (b) {
                    var c = a[b];
                    c && c.destroy && (a[b] = c.destroy());
                });
                d && (d.innerHTML = o.emptyHTML, Y(d), f && I(d));
                U(a, function (b, c) {
                    delete a[c];
                });
            };
            a.prototype.firstRender = function () {
                var a = this, b = a.options;
                if (!a.isReadyToRender || a.isReadyToRender()) {
                    a.getContainer();
                    a.resetMargins();
                    a.setChartSize();
                    a.propFromSeries();
                    a.getAxes();
                    (P(b.series) ? b.series : []).forEach(function (b) {
                        a.initSeries(b);
                    });
                    a.linkSeries();
                    a.setSeriesData();
                    N(a, "beforeRender");
                    i && (g.isRequired() ? a.pointer = new g(a, b) : a.pointer = new i(a, b));
                    a.render();
                    a.pointer.getChartPosition();
                    if (!a.renderer.imgCount && !a.hasLoaded) a.onload();
                    a.temporaryDisplay(!0);
                }
            };
            a.prototype.onload = function () {
                this.callbacks.concat([this.callback]).forEach(function (a) {
                    a && "undefined" !== typeof this.index && a.apply(this, [this]);
                }, this);
                N(this, "load");
                N(this, "render");
                H(this.index) && this.setReflow(this.options.chart.reflow);
                this.hasLoaded = !0;
            };
            a.prototype.addSeries = function (a, b, c) {
                var d = this, e;
                a && (b = V(b, !0), N(d, "addSeries", {
                    options: a
                }, function () {
                    e = d.initSeries(a);
                    d.isDirtyLegend = !0;
                    d.linkSeries();
                    e.enabledDataSorting && e.setData(a.data, !1);
                    N(d, "afterAddSeries", {
                        series: e
                    });
                    b && d.redraw(c);
                }));
                return e;
            };
            a.prototype.addAxis = function (a, b, c, d) {
                return this.createAxis(b ? "xAxis" : "yAxis", {
                    axis: a,
                    redraw: c,
                    animation: d
                });
            };
            a.prototype.addColorAxis = function (a, b, c) {
                return this.createAxis("colorAxis", {
                    axis: a,
                    redraw: b,
                    animation: c
                });
            };
            a.prototype.createAxis = function (a, c) {
                a = new b(this, T(c.axis, {
                    index: this[a].length,
                    isX: "xAxis" === a
                }));
                V(c.redraw, !0) && this.redraw(c.animation);
                return a;
            };
            a.prototype.showLoading = function (a) {
                var b = this, c = b.options, d = c.loading, e = function () {
                    f && G(f, {
                        left: b.plotLeft + "px",
                        top: b.plotTop + "px",
                        width: b.plotWidth + "px",
                        height: b.plotHeight + "px"
                    });
                }, f = b.loadingDiv, g = b.loadingSpan;
                f || (b.loadingDiv = f = F("div", {
                    className: "highcharts-loading highcharts-loading-hidden"
                }, null, b.container));
                g || (b.loadingSpan = g = F("span", {
                    className: "highcharts-loading-inner"
                }, null, f), C(b, "redraw", e));
                f.className = "highcharts-loading";
                o.setElementHTML(g, V(a, c.lang.loading, ""));
                b.styledMode || (G(f, L(d.style, {
                    zIndex: 10
                })), G(g, d.labelStyle), b.loadingShown || (G(f, {
                    opacity: 0,
                    display: ""
                }), p(f, {
                    opacity: d.style.opacity || .5
                }, {
                    duration: d.showDuration || 0
                })));
                b.loadingShown = !0;
                e();
            };
            a.prototype.hideLoading = function () {
                var a = this.options, b = this.loadingDiv;
                b && (b.className = "highcharts-loading highcharts-loading-hidden", this.styledMode || p(b, {
                    opacity: 0
                }, {
                    duration: a.loading.hideDuration || 100,
                    complete: function () {
                        G(b, {
                            display: "none"
                        });
                    }
                }));
                this.loadingShown = !1;
            };
            a.prototype.update = function (a, b, c, d) {
                var e = this, f = {
                    credits: "addCredits",
                    title: "setTitle",
                    subtitle: "setSubtitle",
                    caption: "setCaption"
                }, g = a.isResponsiveOptions, h = [], i, j;
                N(e, "update", {
                    options: a
                });
                g || e.setResponsive(!1, !0);
                a = E(a, e.options);
                e.userOptions = T(e.userOptions, a);
                var k = a.chart;
                if (k) {
                    T(!0, e.options.chart, k);
                    "className" in k && e.setClassName(k.className);
                    "reflow" in k && e.setReflow(k.reflow);
                    if ("inverted" in k || "polar" in k || "type" in k) {
                        e.propFromSeries();
                        var l = !0;
                    }
                    "alignTicks" in k && (l = !0);
                    "events" in k && t(this, k);
                    U(k, function (a, b) {
                        -1 !== e.propsRequireUpdateSeries.indexOf("chart." + b) && (i = !0);
                        -1 !== e.propsRequireDirtyBox.indexOf(b) && (e.isDirtyBox = !0);
                        -1 !== e.propsRequireReflow.indexOf(b) && (g ? e.isDirtyBox = !0 : j = !0);
                    });
                    !e.styledMode && k.style && e.renderer.setStyle(e.options.chart.style || {});
                }
                !e.styledMode && a.colors && (this.options.colors = a.colors);
                a.time && (this.time === A && (this.time = new m(a.time)), T(!0, e.options.time, a.time));
                U(a, function (b, c) {
                    if (e[c] && "function" === typeof e[c].update) e[c].update(b, !1); else if ("function" === typeof e[f[c]]) e[f[c]](b); else "colors" !== c && -1 === e.collectionsWithUpdate.indexOf(c) && T(!0, e.options[c], a[c]);
                    "chart" !== c && -1 !== e.propsRequireUpdateSeries.indexOf(c) && (i = !0);
                });
                this.collectionsWithUpdate.forEach(function (b) {
                    if (a[b]) {
                        var d = [];
                        e[b].forEach(function (a, b) {
                            a.options.isInternal || d.push(V(a.options.index, b));
                        });
                        Z(a[b]).forEach(function (a, f) {
                            var g = H(a.id), h;
                            g && (h = e.get(a.id));
                            !h && e[b] && (h = e[b][d ? d[f] : f]) && g && H(h.options.id) && (h = void 0);
                            h && h.coll === b && (h.update(a, !1), c && (h.touched = !0));
                            !h && c && e.collectionsWithInit[b] && (e.collectionsWithInit[b][0].apply(e, [a].concat(e.collectionsWithInit[b][1] || []).concat([!1])).touched = !0);
                        });
                        c && e[b].forEach(function (a) {
                            a.touched || a.options.isInternal ? delete a.touched : h.push(a);
                        });
                    }
                });
                h.forEach(function (a) {
                    a.chart && a.remove && a.remove(!1);
                });
                l && e.axes.forEach(function (a) {
                    a.update({}, !1);
                });
                i && e.getSeriesOrderByLinks().forEach(function (a) {
                    a.chart && a.update({}, !1);
                }, this);
                l = k && k.width;
                k = k && (S(k.height) ? X(k.height, l || e.chartWidth) : k.height);
                j || Q(l) && l !== e.chartWidth || Q(k) && k !== e.chartHeight ? e.setSize(l, k, d) : V(b, !0) && e.redraw(d);
                N(e, "afterUpdate", {
                    options: a,
                    redraw: b,
                    animation: d
                });
            };
            a.prototype.setSubtitle = function (a, b) {
                this.applyDescription("subtitle", a);
                this.layOutTitles(b);
            };
            a.prototype.setCaption = function (a, b) {
                this.applyDescription("caption", a);
                this.layOutTitles(b);
            };
            a.prototype.showResetZoom = function () {
                function a() {
                    b.zoomOut();
                }
                var b = this, c = z.lang, d = b.options.chart.resetZoomButton, e = d.theme, f = e.states, g = "chart" === d.relativeTo || "spacingBox" === d.relativeTo ? null : "scrollablePlotBox";
                N(this, "beforeShowResetZoom", null, function () {
                    b.resetZoomButton = b.renderer.button(c.resetZoom, null, null, a, e, f && f.hover).attr({
                        align: d.position.align,
                        title: c.resetZoomTitle
                    }).addClass("highcharts-reset-zoom").add().align(d.position, !1, g);
                });
                N(this, "afterShowResetZoom");
            };
            a.prototype.zoomOut = function () {
                N(this, "selection", {
                    resetSelection: !0
                }, this.zoom);
            };
            a.prototype.zoom = function (a) {
                var b = this, c = b.pointer, d = b.inverted ? c.mouseDownX : c.mouseDownY, e = !1, f;
                !a || a.resetSelection ? (b.axes.forEach(function (a) {
                    f = a.zoom();
                }), c.initiated = !1) : a.xAxis.concat(a.yAxis).forEach(function (a) {
                    var g = a.axis, h = b.inverted ? g.left : g.top, i = b.inverted ? h + g.width : h + g.height, j = g.isXAxis, k = !1;
                    if (!j && d >= h && d <= i || j || !H(d)) k = !0;
                    c[j ? "zoomX" : "zoomY"] && k && (f = g.zoom(a.min, a.max), g.displayBtn && (e = !0));
                });
                var g = b.resetZoomButton;
                e && !g ? b.showResetZoom() : !e && R(g) && (b.resetZoomButton = g.destroy());
                f && b.redraw(V(b.options.chart.animation, a && a.animation, 100 > b.pointCount));
            };
            a.prototype.pan = function (a, b) {
                var c = this, d = c.hoverPoints;
                b = "object" === typeof b ? b : {
                    enabled: b,
                    type: "x"
                };
                var e = c.options.chart, f = c.options.mapNavigation && c.options.mapNavigation.enabled;
                e && e.panning && (e.panning = b);
                var g = b.type, h;
                N(this, "pan", {
                    originalEvent: a
                }, function () {
                    d && d.forEach(function (a) {
                        a.setState();
                    });
                    var b = c.xAxis;
                    "xy" === g ? b = b.concat(c.yAxis) : "y" === g && (b = c.yAxis);
                    var e = {};
                    b.forEach(function (b) {
                        if (b.options.panningEnabled && !b.options.isInternal) {
                            var d = b.horiz, i = a[d ? "chartX" : "chartY"];
                            d = d ? "mouseDownX" : "mouseDownY";
                            var j = c[d], k = b.minPointOffset || 0, l = b.reversed && !c.inverted || !b.reversed && c.inverted ? -1 : 1, m = b.getExtremes(), n = b.toValue(j - i, !0) + k * l, o = b.toValue(j + b.len - i, !0) - (k * l || b.isXAxis && b.pointRangePadding || 0), p = o < n;
                            l = b.hasVerticalPanning();
                            j = p ? o : n;
                            n = p ? n : o;
                            var q = b.panningState;
                            !l || b.isXAxis || q && !q.isDirty || b.series.forEach(function (a) {
                                var b = a.getProcessedData(!0);
                                b = a.getExtremes(b.yData, !0);
                                q || (q = {
                                    startMin: Number.MAX_VALUE,
                                    startMax: -Number.MAX_VALUE
                                });
                                Q(b.dataMin) && Q(b.dataMax) && (q.startMin = Math.min(V(a.options.threshold, 1 / 0), b.dataMin, q.startMin),
                                    q.startMax = Math.max(V(a.options.threshold, -1 / 0), b.dataMax, q.startMax));
                            });
                            l = Math.min(V(q && q.startMin, m.dataMin), k ? m.min : b.toValue(b.toPixels(m.min) - b.minPixelPadding));
                            o = Math.max(V(q && q.startMax, m.dataMax), k ? m.max : b.toValue(b.toPixels(m.max) + b.minPixelPadding));
                            b.panningState = q;
                            b.isOrdinal || (k = l - j, 0 < k && (n += k, j = l), k = n - o, 0 < k && (n = o,
                                j -= k), b.series.length && j !== m.min && n !== m.max && j >= l && n <= o && (b.setExtremes(j, n, !1, !1, {
                                    trigger: "pan"
                                }), c.resetZoomButton || f || j === l || n === o || !g.match("y") || (c.showResetZoom(),
                                    b.displayBtn = !1), h = !0), e[d] = i);
                        }
                    });
                    U(e, function (a, b) {
                        c[b] = a;
                    });
                    h && c.redraw(!1);
                    G(c.container, {
                        cursor: "move"
                    });
                });
            };
            return a;
        }();
        L(a.prototype, {
            callbacks: [],
            collectionsWithInit: {
                xAxis: [a.prototype.addAxis, [!0]],
                yAxis: [a.prototype.addAxis, [!1]],
                series: [a.prototype.addSeries]
            },
            collectionsWithUpdate: ["xAxis", "yAxis", "series"],
            propsRequireDirtyBox: "backgroundColor borderColor borderWidth borderRadius plotBackgroundColor plotBackgroundImage plotBorderColor plotBorderWidth plotShadow shadow".split(" "),
            propsRequireReflow: "margin marginTop marginRight marginBottom marginLeft spacing spacingTop spacingRight spacingBottom spacingLeft".split(" "),
            propsRequireUpdateSeries: "chart.inverted chart.polar chart.ignoreHiddenSeries chart.type colors plotOptions time tooltip".split(" ")
        });
        return a;
    });
    b(c, "Core/Legend/LegendSymbol.js", [c["Core/Utilities.js"]], function (a) {
        var b = a.merge, c = a.pick, d;
        !function (a) {
            a.drawLineMarker = function (a) {
                var d = this.options, e = a.symbolWidth, f = a.symbolHeight, g = f / 2, h = this.chart.renderer, i = this.legendGroup;
                a = a.baseline - Math.round(.3 * a.fontMetrics.b);
                var j = {}, k = d.marker;
                this.chart.styledMode || (j = {
                    "stroke-width": d.lineWidth || 0
                }, d.dashStyle && (j.dashstyle = d.dashStyle));
                this.legendLine = h.path([["M", 0, a], ["L", e, a]]).addClass("highcharts-graph").attr(j).add(i);
                k && !1 !== k.enabled && e && (d = Math.min(c(k.radius, g), g), 0 === this.symbol.indexOf("url") && (k = b(k, {
                    width: f,
                    height: f
                }), d = 0), this.legendSymbol = e = h.symbol(this.symbol, e / 2 - d, a - d, 2 * d, 2 * d, k).addClass("highcharts-point").add(i),
                    e.isMarker = !0);
            };
            a.drawRectangle = function (a, b) {
                var d = a.symbolHeight, e = a.options.squareSymbol;
                b.legendSymbol = this.chart.renderer.rect(e ? (a.symbolWidth - d) / 2 : 0, a.baseline - d + 1, e ? d : a.symbolWidth, d, c(a.options.symbolRadius, d / 2)).addClass("highcharts-point").attr({
                    zIndex: 3
                }).add(b.legendGroup);
            };
        }(d || (d = {}));
        return d;
    });
    b(c, "Core/Series/SeriesDefaults.js", [], function () {
        return {
            lineWidth: 2,
            allowPointSelect: !1,
            crisp: !0,
            showCheckbox: !1,
            animation: {
                duration: 1e3
            },
            events: {},
            marker: {
                enabledThreshold: 2,
                lineColor: "#ffffff",
                lineWidth: 0,
                radius: 4,
                states: {
                    normal: {
                        animation: !0
                    },
                    hover: {
                        animation: {
                            duration: 50
                        },
                        enabled: !0,
                        radiusPlus: 2,
                        lineWidthPlus: 1
                    },
                    select: {
                        fillColor: "#cccccc",
                        lineColor: "#000000",
                        lineWidth: 2
                    }
                }
            },
            point: {
                events: {}
            },
            dataLabels: {
                animation: {},
                align: "center",
                defer: !0,
                formatter: function () {
                    var a = this.series.chart.numberFormatter;
                    return "number" !== typeof this.y ? "" : a(this.y, -1);
                },
                padding: 5,
                style: {
                    fontSize: "11px",
                    fontWeight: "bold",
                    color: "contrast",
                    textOutline: "1px contrast"
                },
                verticalAlign: "bottom",
                x: 0,
                y: 0
            },
            cropThreshold: 300,
            opacity: 1,
            pointRange: 0,
            softThreshold: !0,
            states: {
                normal: {
                    animation: !0
                },
                hover: {
                    animation: {
                        duration: 50
                    },
                    lineWidthPlus: 1,
                    marker: {},
                    halo: {
                        size: 10,
                        opacity: .25
                    }
                },
                select: {
                    animation: {
                        duration: 0
                    }
                },
                inactive: {
                    animation: {
                        duration: 50
                    },
                    opacity: .2
                }
            },
            stickyTracking: !0,
            turboThreshold: 1e3,
            findNearestPointBy: "x"
        };
    });
    b(c, "Core/Series/Series.js", [c["Core/Animation/AnimationUtilities.js"], c["Core/DefaultOptions.js"], c["Core/Foundation.js"], c["Core/Globals.js"], c["Core/Legend/LegendSymbol.js"], c["Core/Series/Point.js"], c["Core/Series/SeriesDefaults.js"], c["Core/Series/SeriesRegistry.js"], c["Core/Renderer/SVG/SVGElement.js"], c["Core/Utilities.js"]], function (a, b, c, d, e, f, g, h, i, j) {
        var k = a.animObject, l = a.setAnimation, m = b.defaultOptions, n = c.registerEventOptions, o = d.hasTouch, p = d.svg, q = d.win, r = h.seriesTypes, s = j.addEvent, t = j.arrayMax, u = j.arrayMin, v = j.clamp, w = j.cleanRecursively, x = j.correctFloat, y = j.defined, z = j.erase, A = j.error, B = j.extend, C = j.find, D = j.fireEvent, E = j.getNestedProperty, F = j.isArray, G = j.isNumber, H = j.isString, I = j.merge, J = j.objectEach, K = j.pick, L = j.removeEvent, M = j.splat, N = j.syncTimeout;
        a = function () {
            function a() {
                this.zones = this.yAxis = this.xAxis = this.userOptions = this.tooltipOptions = this.processedYData = this.processedXData = this.points = this.options = this.linkedSeries = this.index = this.eventsToUnbind = this.eventOptions = this.data = this.chart = this._i = void 0;
            }
            a.prototype.init = function (a, b) {
                D(this, "init", {
                    options: b
                });
                var c = this, d = a.series;
                this.eventsToUnbind = [];
                c.chart = a;
                c.options = c.setOptions(b);
                b = c.options;
                c.linkedSeries = [];
                c.bindAxes();
                B(c, {
                    name: b.name,
                    state: "",
                    visible: !1 !== b.visible,
                    selected: !0 === b.selected
                });
                n(this, b);
                var e = b.events;
                if (e && e.click || b.point && b.point.events && b.point.events.click || b.allowPointSelect) a.runTrackerClick = !0;
                c.getColor();
                c.getSymbol();
                c.parallelArrays.forEach(function (a) {
                    c[a + "Data"] || (c[a + "Data"] = []);
                });
                c.isCartesian && (a.hasCartesianSeries = !0);
                var f;
                d.length && (f = d[d.length - 1]);
                c._i = K(f && f._i, -1) + 1;
                c.opacity = c.options.opacity;
                a.orderSeries(this.insert(d));
                b.dataSorting && b.dataSorting.enabled ? c.setDataSortingOptions() : c.points || c.data || c.setData(b.data, !1);
                D(this, "afterInit");
            };
            a.prototype.is = function (a) {
                return r[a] && this instanceof r[a];
            };
            a.prototype.insert = function (a) {
                var b = this.options.index, c;
                if (G(b)) {
                    for (c = a.length; c--;) if (b >= K(a[c].options.index, a[c]._i)) {
                        a.splice(c + 1, 0, this);
                        break;
                    }
                    -1 === c && a.unshift(this);
                    c += 1;
                } else a.push(this);
                return K(c, a.length - 1);
            };
            a.prototype.bindAxes = function () {
                var a = this, b = a.options, c = a.chart, d;
                D(this, "bindAxes", null, function () {
                    (a.axisTypes || []).forEach(function (e) {
                        var f = 0;
                        c[e].forEach(function (c) {
                            d = c.options;
                            if (b[e] === f && !d.isInternal || "undefined" !== typeof b[e] && b[e] === d.id || "undefined" === typeof b[e] && 0 === d.index) a.insert(c.series),
                                a[e] = c, c.isDirty = !0;
                            d.isInternal || f++;
                        });
                        a[e] || a.optionalAxis === e || A(18, !0, c);
                    });
                });
                D(this, "afterBindAxes");
            };
            a.prototype.updateParallelArrays = function (a, b) {
                var c = a.series, d = arguments, e = G(b) ? function (d) {
                    var e = "y" === d && c.toYData ? c.toYData(a) : a[d];
                    c[d + "Data"][b] = e;
                } : function (a) {
                    Array.prototype[b].apply(c[a + "Data"], Array.prototype.slice.call(d, 2));
                };
                c.parallelArrays.forEach(e);
            };
            a.prototype.hasData = function () {
                return this.visible && "undefined" !== typeof this.dataMax && "undefined" !== typeof this.dataMin || this.visible && this.yData && 0 < this.yData.length;
            };
            a.prototype.autoIncrement = function (a) {
                var b = this.options, c = b.pointIntervalUnit, d = b.relativeXValue, e = this.chart.time, f = this.xIncrement, g;
                f = K(f, b.pointStart, 0);
                this.pointInterval = g = K(this.pointInterval, b.pointInterval, 1);
                d && G(a) && (g *= a);
                c && (b = new e.Date(f), "day" === c ? e.set("Date", b, e.get("Date", b) + g) : "month" === c ? e.set("Month", b, e.get("Month", b) + g) : "year" === c && e.set("FullYear", b, e.get("FullYear", b) + g),
                    g = b.getTime() - f);
                if (d && G(a)) return f + g;
                this.xIncrement = f + g;
                return f;
            };
            a.prototype.setDataSortingOptions = function () {
                var a = this.options;
                B(this, {
                    requireSorting: !1,
                    sorted: !1,
                    enabledDataSorting: !0,
                    allowDG: !1
                });
                y(a.pointRange) || (a.pointRange = 1);
            };
            a.prototype.setOptions = function (a) {
                var b = this.chart, c = b.options, d = c.plotOptions, e = b.userOptions || {};
                a = I(a);
                b = b.styledMode;
                var f = {
                    plotOptions: d,
                    userOptions: a
                };
                D(this, "setOptions", f);
                var g = f.plotOptions[this.type], h = e.plotOptions || {};
                this.userOptions = f.userOptions;
                e = I(g, d.series, e.plotOptions && e.plotOptions[this.type], a);
                this.tooltipOptions = I(m.tooltip, m.plotOptions.series && m.plotOptions.series.tooltip, m.plotOptions[this.type].tooltip, c.tooltip.userOptions, d.series && d.series.tooltip, d[this.type].tooltip, a.tooltip);
                this.stickyTracking = K(a.stickyTracking, h[this.type] && h[this.type].stickyTracking, h.series && h.series.stickyTracking, this.tooltipOptions.shared && !this.noSharedTooltip ? !0 : e.stickyTracking);
                null === g.marker && delete e.marker;
                this.zoneAxis = e.zoneAxis;
                d = this.zones = (e.zones || []).slice();
                !e.negativeColor && !e.negativeFillColor || e.zones || (c = {
                    value: e[this.zoneAxis + "Threshold"] || e.threshold || 0,
                    className: "highcharts-negative"
                }, b || (c.color = e.negativeColor, c.fillColor = e.negativeFillColor), d.push(c));
                d.length && y(d[d.length - 1].value) && d.push(b ? {} : {
                    color: this.color,
                    fillColor: this.fillColor
                });
                D(this, "afterSetOptions", {
                    options: e
                });
                return e;
            };
            a.prototype.getName = function () {
                return K(this.options.name, "Series " + (this.index + 1));
            };
            a.prototype.getCyclic = function (a, b, c) {
                var d = this.chart, e = this.userOptions, f = a + "Index", g = a + "Counter", h = c ? c.length : K(d.options.chart[a + "Count"], d[a + "Count"]);
                if (!b) {
                    var i = K(e[f], e["_" + f]);
                    y(i) || (d.series.length || (d[g] = 0), e["_" + f] = i = d[g] % h, d[g] += 1);
                    c && (b = c[i]);
                }
                "undefined" !== typeof i && (this[f] = i);
                this[a] = b;
            };
            a.prototype.getColor = function () {
                this.chart.styledMode ? this.getCyclic("color") : this.options.colorByPoint ? this.color = "#cccccc" : this.getCyclic("color", this.options.color || m.plotOptions[this.type].color, this.chart.options.colors);
            };
            a.prototype.getPointsCollection = function () {
                return (this.hasGroupedData ? this.points : this.data) || [];
            };
            a.prototype.getSymbol = function () {
                this.getCyclic("symbol", this.options.marker.symbol, this.chart.options.symbols);
            };
            a.prototype.findPointIndex = function (a, b) {
                var c = a.id, d = a.x, e = this.points, g = this.options.dataSorting, h, i;
                if (c) g = this.chart.get(c), g instanceof f && (h = g); else if (this.linkedParent || this.enabledDataSorting || this.options.relativeXValue) if (h = function (b) {
                    return !b.touched && b.index === a.index;
                }, g && g.matchByName ? h = function (b) {
                    return !b.touched && b.name === a.name;
                } : this.options.relativeXValue && (h = function (b) {
                    return !b.touched && b.options.x === a.x;
                }), h = C(e, h), !h) return;
                if (h) {
                    var j = h && h.index;
                    "undefined" !== typeof j && (i = !0);
                }
                "undefined" === typeof j && G(d) && (j = this.xData.indexOf(d, b));
                -1 !== j && "undefined" !== typeof j && this.cropped && (j = j >= this.cropStart ? j - this.cropStart : j);
                !i && G(j) && e[j] && e[j].touched && (j = void 0);
                return j;
            };
            a.prototype.updateData = function (a, b) {
                var c = this.options, d = c.dataSorting, e = this.points, f = [], g = this.requireSorting, h = a.length === e.length, i, j, k, l = !0;
                this.xIncrement = null;
                a.forEach(function (a, b) {
                    var j = y(a) && this.pointClass.prototype.optionsToObject.call({
                        series: this
                    }, a) || {}, l = j.x;
                    if (j.id || G(l)) {
                        if (j = this.findPointIndex(j, k), -1 === j || "undefined" === typeof j ? f.push(a) : e[j] && a !== c.data[j] ? (e[j].update(a, !1, null, !1),
                            e[j].touched = !0, g && (k = j + 1)) : e[j] && (e[j].touched = !0), !h || b !== j || d && d.enabled || this.hasDerivedData) i = !0;
                    } else f.push(a);
                }, this);
                if (i) for (a = e.length; a--;) (j = e[a]) && !j.touched && j.remove && j.remove(!1, b); else !h || d && d.enabled ? l = !1 : (a.forEach(function (a, b) {
                    a !== e[b].y && e[b].update && e[b].update(a, !1, null, !1);
                }), f.length = 0);
                e.forEach(function (a) {
                    a && (a.touched = !1);
                });
                if (!l) return !1;
                f.forEach(function (a) {
                    this.addPoint(a, !1, null, null, !1);
                }, this);
                null === this.xIncrement && this.xData && this.xData.length && (this.xIncrement = t(this.xData),
                    this.autoIncrement());
                return !0;
            };
            a.prototype.setData = function (a, b, c, d) {
                var e = this, f = e.points, g = f && f.length || 0, h = e.options, i = e.chart, j = h.dataSorting, k = e.xAxis, l = h.turboThreshold, m = this.xData, n = this.yData, o = e.pointArrayMap;
                o = o && o.length;
                var p = h.keys, q, r = 0, s = 1, t = null;
                a = a || [];
                var u = a.length;
                b = K(b, !0);
                j && j.enabled && (a = this.sortData(a));
                !1 !== d && u && g && !e.cropped && !e.hasGroupedData && e.visible && !e.isSeriesBoosting && (q = this.updateData(a, c));
                if (!q) {
                    e.xIncrement = null;
                    e.colorCounter = 0;
                    this.parallelArrays.forEach(function (a) {
                        e[a + "Data"].length = 0;
                    });
                    if (l && u > l) if (t = e.getFirstValidPoint(a), G(t)) for (c = 0; c < u; c++) m[c] = this.autoIncrement(),
                        n[c] = a[c]; else if (F(t)) if (o) if (t.length === o) for (c = 0; c < u; c++) m[c] = this.autoIncrement(),
                            n[c] = a[c]; else for (c = 0; c < u; c++) d = a[c], m[c] = d[0], n[c] = d.slice(1, o + 1); else if (p && (r = p.indexOf("x"),
                                s = p.indexOf("y"), r = 0 <= r ? r : 0, s = 0 <= s ? s : 1), 1 === t.length && (s = 0),
                                r === s) for (c = 0; c < u; c++) m[c] = this.autoIncrement(), n[c] = a[c][s]; else for (c = 0; c < u; c++) d = a[c],
                                    m[c] = d[r], n[c] = d[s]; else A(12, !1, i); else for (c = 0; c < u; c++) "undefined" !== typeof a[c] && (d = {
                                        series: e
                                    }, e.pointClass.prototype.applyOptions.apply(d, [a[c]]), e.updateParallelArrays(d, c));
                    n && H(n[0]) && A(14, !0, i);
                    e.data = [];
                    e.options.data = e.userOptions.data = a;
                    for (c = g; c--;) f[c] && f[c].destroy && f[c].destroy();
                    k && (k.minRange = k.userMinRange);
                    e.isDirty = i.isDirtyBox = !0;
                    e.isDirtyData = !!f;
                    c = !1;
                }
                "point" === h.legendType && (this.processData(), this.generatePoints());
                b && i.redraw(c);
            };
            a.prototype.sortData = function (a) {
                var b = this, c = b.options.dataSorting.sortKey || "y", d = function (a, b) {
                    return y(b) && a.pointClass.prototype.optionsToObject.call({
                        series: a
                    }, b) || {};
                };
                a.forEach(function (c, e) {
                    a[e] = d(b, c);
                    a[e].index = e;
                }, this);
                a.concat().sort(function (a, b) {
                    a = E(c, a);
                    b = E(c, b);
                    return b < a ? -1 : b > a ? 1 : 0;
                }).forEach(function (a, b) {
                    a.x = b;
                }, this);
                b.linkedSeries && b.linkedSeries.forEach(function (b) {
                    var c = b.options, e = c.data;
                    c.dataSorting && c.dataSorting.enabled || !e || (e.forEach(function (c, f) {
                        e[f] = d(b, c);
                        a[f] && (e[f].x = a[f].x, e[f].index = f);
                    }), b.setData(e, !1));
                });
                return a;
            };
            a.prototype.getProcessedData = function (a) {
                var b = this.xAxis, c = this.options, d = c.cropThreshold, e = a || this.getExtremesFromAll || c.getExtremesFromAll, f = this.isCartesian;
                a = b && b.val2lin;
                c = !(!b || !b.logarithmic);
                var g = 0, h = this.xData, i = this.yData, j = this.requireSorting;
                var k = !1;
                var l = h.length;
                if (b) {
                    k = b.getExtremes();
                    var m = k.min;
                    var n = k.max;
                    k = !(!b.categories || b.names.length);
                }
                if (f && this.sorted && !e && (!d || l > d || this.forceCrop)) if (h[l - 1] < m || h[0] > n) h = [],
                    i = []; else if (this.yData && (h[0] < m || h[l - 1] > n)) {
                        var o = this.cropData(this.xData, this.yData, m, n);
                        h = o.xData;
                        i = o.yData;
                        g = o.start;
                        o = !0;
                    }
                for (d = h.length || 1; --d;) if (b = c ? a(h[d]) - a(h[d - 1]) : h[d] - h[d - 1],
                    0 < b && ("undefined" === typeof p || b < p)) var p = b; else 0 > b && j && !k && (A(15, !1, this.chart),
                        j = !1);
                return {
                    xData: h,
                    yData: i,
                    cropped: o,
                    cropStart: g,
                    closestPointRange: p
                };
            };
            a.prototype.processData = function (a) {
                var b = this.xAxis;
                if (this.isCartesian && !this.isDirty && !b.isDirty && !this.yAxis.isDirty && !a) return !1;
                a = this.getProcessedData();
                this.cropped = a.cropped;
                this.cropStart = a.cropStart;
                this.processedXData = a.xData;
                this.processedYData = a.yData;
                this.closestPointRange = this.basePointRange = a.closestPointRange;
                D(this, "afterProcessData");
            };
            a.prototype.cropData = function (a, b, c, d, e) {
                var f = a.length, g, h = 0, i = f;
                e = K(e, this.cropShoulder);
                for (g = 0; g < f; g++) if (a[g] >= c) {
                    h = Math.max(0, g - e);
                    break;
                }
                for (c = g; c < f; c++) if (a[c] > d) {
                    i = c + e;
                    break;
                }
                return {
                    xData: a.slice(h, i),
                    yData: b.slice(h, i),
                    start: h,
                    end: i
                };
            };
            a.prototype.generatePoints = function () {
                var a = this.options, b = this.processedData || a.data, c = this.processedXData, d = this.processedYData, e = this.pointClass, f = c.length, g = this.cropStart || 0, h = this.hasGroupedData, i = a.keys, j = [];
                a = a.dataGrouping && a.dataGrouping.groupAll ? g : 0;
                var k, l, m = this.data;
                if (!m && !h) {
                    var n = [];
                    n.length = b.length;
                    m = this.data = n;
                }
                i && h && (this.options.keys = !1);
                for (l = 0; l < f; l++) {
                    n = g + l;
                    if (h) {
                        var o = new e().init(this, [c[l]].concat(M(d[l])));
                        o.dataGroup = this.groupMap[a + l];
                        o.dataGroup.options && (o.options = o.dataGroup.options, B(o, o.dataGroup.options),
                            delete o.dataLabels);
                    } else (o = m[n]) || "undefined" === typeof b[n] || (m[n] = o = new e().init(this, b[n], c[l]));
                    o && (o.index = h ? a + l : n, j[l] = o);
                }
                this.options.keys = i;
                if (m && (f !== (k = m.length) || h)) for (l = 0; l < k; l++) l !== g || h || (l += f),
                    m[l] && (m[l].destroyElements(), m[l].plotX = void 0);
                this.data = m;
                this.points = j;
                D(this, "afterGeneratePoints");
            };
            a.prototype.getXExtremes = function (a) {
                return {
                    min: u(a),
                    max: t(a)
                };
            };
            a.prototype.getExtremes = function (a, b) {
                var c = this.xAxis, d = this.yAxis, e = this.processedXData || this.xData, f = [], g = this.requireSorting ? this.cropShoulder : 0;
                d = d ? d.positiveValuesOnly : !1;
                var h, i = 0, j = 0, k = 0;
                a = a || this.stackedYData || this.processedYData || [];
                var l = a.length;
                if (c) {
                    var m = c.getExtremes();
                    i = m.min;
                    j = m.max;
                }
                for (h = 0; h < l; h++) {
                    var n = e[h];
                    m = a[h];
                    var o = (G(m) || F(m)) && (m.length || 0 < m || !d);
                    n = b || this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped || !c || (e[h + g] || n) >= i && (e[h - g] || n) <= j;
                    if (o && n) if (o = m.length) for (; o--;) G(m[o]) && (f[k++] = m[o]); else f[k++] = m;
                }
                a = {
                    activeYData: f,
                    dataMin: u(f),
                    dataMax: t(f)
                };
                D(this, "afterGetExtremes", {
                    dataExtremes: a
                });
                return a;
            };
            a.prototype.applyExtremes = function () {
                var a = this.getExtremes();
                this.dataMin = a.dataMin;
                this.dataMax = a.dataMax;
                return a;
            };
            a.prototype.getFirstValidPoint = function (a) {
                for (var b = a.length, c = 0, d = null; null === d && c < b;) d = a[c], c++;
                return d;
            };
            a.prototype.translate = function () {
                this.processedXData || this.processData();
                this.generatePoints();
                var a = this.options, b = a.stacking, c = this.xAxis, d = c.categories, e = this.enabledDataSorting, f = this.yAxis, g = this.points, h = g.length, i = this.pointPlacementToXValue(), j = !!i, k = a.threshold, l = a.startFromThreshold ? k : 0, m = this.zoneAxis || "y", n, o, p = Number.MAX_VALUE;
                for (n = 0; n < h; n++) {
                    var q = g[n], r = q.x, s = void 0, t = void 0, u = q.y, w = q.low, z = b && f.stacking && f.stacking.stacks[(this.negStacks && u < (l ? 0 : k) ? "-" : "") + this.stackKey];
                    if (f.positiveValuesOnly && !f.validatePositiveValue(u) || c.positiveValuesOnly && !c.validatePositiveValue(r)) q.isNull = !0;
                    q.plotX = o = x(v(c.translate(r, 0, 0, 0, 1, i, "flags" === this.type), -1e5, 1e5));
                    if (b && this.visible && z && z[r]) {
                        var A = this.getStackIndicator(A, r, this.index);
                        q.isNull || (s = z[r], t = s.points[A.key]);
                    }
                    F(t) && (w = t[0], u = t[1], w === l && A.key === z[r].base && (w = K(G(k) && k, f.min)),
                        f.positiveValuesOnly && 0 >= w && (w = null), q.total = q.stackTotal = s.total,
                        q.percentage = s.total && q.y / s.total * 100, q.stackY = u, this.irregularWidths || s.setOffset(this.pointXOffset || 0, this.barW || 0));
                    q.yBottom = y(w) ? v(f.translate(w, 0, 1, 0, 1), -1e5, 1e5) : null;
                    this.dataModify && (u = this.dataModify.modifyValue(u, n));
                    q.plotY = void 0;
                    G(u) && (s = f.translate(u, !1, !0, !1, !0), "undefined" !== typeof s && (q.plotY = v(s, -1e5, 1e5)));
                    q.isInside = this.isPointInside(q);
                    q.clientX = j ? x(c.translate(r, 0, 0, 0, 1, i)) : o;
                    q.negative = q[m] < (a[m + "Threshold"] || k || 0);
                    q.category = K(d && d[q.x], q.x);
                    if (!q.isNull && !1 !== q.visible) {
                        "undefined" !== typeof B && (p = Math.min(p, Math.abs(o - B)));
                        var B = o;
                    }
                    q.zone = this.zones.length ? q.getZone() : void 0;
                    !q.graphic && this.group && e && (q.isNew = !0);
                }
                this.closestPointRangePx = p;
                D(this, "afterTranslate");
            };
            a.prototype.getValidPoints = function (a, b, c) {
                var d = this.chart;
                return (a || this.points || []).filter(function (a) {
                    return b && !d.isInsidePlot(a.plotX, a.plotY, {
                        inverted: d.inverted
                    }) ? !1 : !1 !== a.visible && (c || !a.isNull);
                });
            };
            a.prototype.getClipBox = function () {
                var a = this.chart, b = this.xAxis, c = this.yAxis, d = I(a.clipBox);
                b && b.len !== a.plotSizeX && (d.width = b.len);
                c && c.len !== a.plotSizeY && (d.height = c.len);
                return d;
            };
            a.prototype.getSharedClipKey = function () {
                return this.sharedClipKey = (this.options.xAxis || 0) + "," + (this.options.yAxis || 0);
            };
            a.prototype.setClip = function () {
                var a = this.chart, b = this.group, c = this.markerGroup, d = a.sharedClips;
                a = a.renderer;
                var e = this.getClipBox(), f = this.getSharedClipKey(), g = d[f];
                g ? g.animate(e) : d[f] = g = a.clipRect(e);
                b && b.clip(!1 === this.options.clip ? void 0 : g);
                c && c.clip();
            };
            a.prototype.animate = function (a) {
                var b = this.chart, c = this.group, d = this.markerGroup, e = b.inverted, f = k(this.options.animation), g = [this.getSharedClipKey(), f.duration, f.easing, f.defer].join(), h = b.sharedClips[g], i = b.sharedClips[g + "m"];
                if (a && c) f = this.getClipBox(), h ? h.attr("height", f.height) : (f.width = 0,
                    e && (f.x = b.plotHeight), h = b.renderer.clipRect(f), b.sharedClips[g] = h, i = b.renderer.clipRect({
                        x: e ? (b.plotSizeX || 0) + 99 : -99,
                        y: e ? -b.plotLeft : -b.plotTop,
                        width: 99,
                        height: e ? b.chartWidth : b.chartHeight
                    }), b.sharedClips[g + "m"] = i), c.clip(h), d && d.clip(i); else if (h && !h.hasClass("highcharts-animating")) {
                        b = this.getClipBox();
                        var j = f.step;
                        d && d.element.childNodes.length && (f.step = function (a, b) {
                            j && j.apply(b, arguments);
                            i && i.element && i.attr(b.prop, "width" === b.prop ? a + 99 : a);
                        });
                        h.addClass("highcharts-animating").animate(b, f);
                    }
            };
            a.prototype.afterAnimate = function () {
                var a = this;
                this.setClip();
                J(this.chart.sharedClips, function (b, c, d) {
                    b && !a.chart.container.querySelector('[clip-path="url(#' + b.id + ')"]') && (b.destroy(),
                        delete d[c]);
                });
                this.finishedAnimating = !0;
                D(this, "afterAnimate");
            };
            a.prototype.drawPoints = function () {
                var a = this.points, b = this.chart, c = this.options.marker, d = this[this.specialGroup] || this.markerGroup, e = this.xAxis, f = K(c.enabled, !e || e.isRadial ? !0 : null, this.closestPointRangePx >= c.enabledThreshold * c.radius), g, h;
                if (!1 !== c.enabled || this._hasPointMarkers) for (g = 0; g < a.length; g++) {
                    var i = a[g];
                    var j = (h = i.graphic) ? "animate" : "attr";
                    var k = i.marker || {};
                    var l = !!i.marker;
                    if ((f && "undefined" === typeof k.enabled || k.enabled) && !i.isNull && !1 !== i.visible) {
                        var m = K(k.symbol, this.symbol, "rect");
                        var n = this.markerAttribs(i, i.selected && "select");
                        this.enabledDataSorting && (i.startXPos = e.reversed ? -(n.width || 0) : e.width);
                        var o = !1 !== i.isInside;
                        h ? h[o ? "show" : "hide"](o).animate(n) : o && (0 < (n.width || 0) || i.hasImage) && (i.graphic = h = b.renderer.symbol(m, n.x, n.y, n.width, n.height, l ? k : c).add(d),
                            this.enabledDataSorting && b.hasRendered && (h.attr({
                                x: i.startXPos
                            }), j = "animate"));
                        h && "animate" === j && h[o ? "show" : "hide"](o).animate(n);
                        if (h && !b.styledMode) h[j](this.pointAttribs(i, i.selected && "select"));
                        h && h.addClass(i.getClassName(), !0);
                    } else h && (i.graphic = h.destroy());
                }
            };
            a.prototype.markerAttribs = function (a, b) {
                var c = this.options, d = c.marker, e = a.marker || {}, f = e.symbol || d.symbol, g = K(e.radius, d && d.radius);
                b && (d = d.states[b], b = e.states && e.states[b], g = K(b && b.radius, d && d.radius, g && g + (d && d.radiusPlus || 0)));
                a.hasImage = f && 0 === f.indexOf("url");
                a.hasImage && (g = 0);
                a = G(g) ? {
                    x: c.crisp ? Math.floor(a.plotX - g) : a.plotX - g,
                    y: a.plotY - g
                } : {};
                g && (a.width = a.height = 2 * g);
                return a;
            };
            a.prototype.pointAttribs = function (a, b) {
                var c = this.options.marker, d = a && a.options, e = d && d.marker || {}, f = d && d.color, g = a && a.color, h = a && a.zone && a.zone.color, i = this.color;
                a = K(e.lineWidth, c.lineWidth);
                d = 1;
                i = f || h || g || i;
                f = e.fillColor || c.fillColor || i;
                g = e.lineColor || c.lineColor || i;
                b = b || "normal";
                c = c.states[b] || {};
                b = e.states && e.states[b] || {};
                a = K(b.lineWidth, c.lineWidth, a + K(b.lineWidthPlus, c.lineWidthPlus, 0));
                f = b.fillColor || c.fillColor || f;
                g = b.lineColor || c.lineColor || g;
                d = K(b.opacity, c.opacity, d);
                return {
                    stroke: g,
                    "stroke-width": a,
                    fill: f,
                    opacity: d
                };
            };
            a.prototype.destroy = function (a) {
                var b = this, c = b.chart, d = /AppleWebKit\/533/.test(q.navigator.userAgent), e = b.data || [], f, g, h, k;
                D(b, "destroy", {
                    keepEventsForUpdate: a
                });
                this.removeEvents(a);
                (b.axisTypes || []).forEach(function (a) {
                    (k = b[a]) && k.series && (z(k.series, b), k.isDirty = k.forceRedraw = !0);
                });
                b.legendItem && b.chart.legend.destroyItem(b);
                for (g = e.length; g--;) (h = e[g]) && h.destroy && h.destroy();
                b.clips && b.clips.forEach(function (a) {
                    return a.destroy();
                });
                j.clearTimeout(b.animationTimeout);
                J(b, function (a, b) {
                    a instanceof i && !a.survive && (f = d && "group" === b ? "hide" : "destroy", a[f]());
                });
                c.hoverSeries === b && (c.hoverSeries = void 0);
                z(c.series, b);
                c.orderSeries();
                J(b, function (c, d) {
                    a && "hcEvents" === d || delete b[d];
                });
            };
            a.prototype.applyZones = function () {
                var a = this, b = this.chart, c = b.renderer, d = this.zones, e = this.clips || [], f = this.graph, g = this.area, h = Math.max(b.chartWidth, b.chartHeight), i = this[(this.zoneAxis || "y") + "Axis"], j = b.inverted, k, l, m, n, o, p, q, r, s = !1;
                if (d.length && (f || g) && i && "undefined" !== typeof i.min) {
                    var t = i.reversed;
                    var u = i.horiz;
                    f && !this.showLine && f.hide();
                    g && g.hide();
                    var w = i.getExtremes();
                    d.forEach(function (d, x) {
                        k = t ? u ? b.plotWidth : 0 : u ? 0 : i.toPixels(w.min) || 0;
                        k = v(K(l, k), 0, h);
                        l = v(Math.round(i.toPixels(K(d.value, w.max), !0) || 0), 0, h);
                        s && (k = l = i.toPixels(w.max));
                        n = Math.abs(k - l);
                        o = Math.min(k, l);
                        p = Math.max(k, l);
                        i.isXAxis ? (m = {
                            x: j ? p : o,
                            y: 0,
                            width: n,
                            height: h
                        }, u || (m.x = b.plotHeight - m.x)) : (m = {
                            x: 0,
                            y: j ? p : o,
                            width: h,
                            height: n
                        }, u && (m.y = b.plotWidth - m.y));
                        j && c.isVML && (m = i.isXAxis ? {
                            x: 0,
                            y: t ? o : p,
                            height: m.width,
                            width: b.chartWidth
                        } : {
                            x: m.y - b.plotLeft - b.spacingBox.x,
                            y: 0,
                            width: m.height,
                            height: b.chartHeight
                        });
                        e[x] ? e[x].animate(m) : e[x] = c.clipRect(m);
                        q = a["zone-area-" + x];
                        r = a["zone-graph-" + x];
                        f && r && r.clip(e[x]);
                        g && q && q.clip(e[x]);
                        s = d.value > w.max;
                        a.resetZones && 0 === l && (l = void 0);
                    });
                    this.clips = e;
                } else a.visible && (f && f.show(!0), g && g.show(!0));
            };
            a.prototype.invertGroups = function (a) {
                function b() {
                    ["group", "markerGroup"].forEach(function (b) {
                        c[b] && (d.renderer.isVML && c[b].attr({
                            width: c.yAxis.len,
                            height: c.xAxis.len
                        }), c[b].width = c.yAxis.len, c[b].height = c.xAxis.len, c[b].invert(c.isRadialSeries ? !1 : a));
                    });
                }
                var c = this, d = c.chart;
                c.xAxis && (c.eventsToUnbind.push(s(d, "resize", b)), b(), c.invertGroups = b);
            };
            a.prototype.plotGroup = function (a, b, c, d, e) {
                var f = this[a], g = !f;
                c = {
                    visibility: c,
                    zIndex: d || .1
                };
                "undefined" === typeof this.opacity || this.chart.styledMode || "inactive" === this.state || (c.opacity = this.opacity);
                g && (this[a] = f = this.chart.renderer.g().add(e));
                f.addClass("highcharts-" + b + " highcharts-series-" + this.index + " highcharts-" + this.type + "-series " + (y(this.colorIndex) ? "highcharts-color-" + this.colorIndex + " " : "") + (this.options.className || "") + (f.hasClass("highcharts-tracker") ? " highcharts-tracker" : ""), !0);
                f.attr(c)[g ? "attr" : "animate"](this.getPlotBox());
                return f;
            };
            a.prototype.getPlotBox = function () {
                var a = this.chart, b = this.xAxis, c = this.yAxis;
                a.inverted && (b = c, c = this.xAxis);
                return {
                    translateX: b ? b.left : a.plotLeft,
                    translateY: c ? c.top : a.plotTop,
                    scaleX: 1,
                    scaleY: 1
                };
            };
            a.prototype.removeEvents = function (a) {
                a || L(this);
                this.eventsToUnbind.length && (this.eventsToUnbind.forEach(function (a) {
                    a();
                }), this.eventsToUnbind.length = 0);
            };
            a.prototype.render = function () {
                var a = this, b = a.chart, c = a.options, d = k(c.animation), e = a.visible ? "inherit" : "hidden", f = c.zIndex, g = a.hasRendered, h = b.seriesGroup, i = b.inverted;
                b = !a.finishedAnimating && b.renderer.isSVG ? d.duration : 0;
                D(this, "render");
                var j = a.plotGroup("group", "series", e, f, h);
                a.markerGroup = a.plotGroup("markerGroup", "markers", e, f, h);
                !1 !== c.clip && a.setClip();
                a.animate && b && a.animate(!0);
                j.inverted = K(a.invertible, a.isCartesian) ? i : !1;
                a.drawGraph && (a.drawGraph(), a.applyZones());
                a.visible && a.drawPoints();
                a.drawDataLabels && a.drawDataLabels();
                a.redrawPoints && a.redrawPoints();
                a.drawTracker && !1 !== a.options.enableMouseTracking && a.drawTracker();
                a.invertGroups(i);
                a.animate && b && a.animate();
                g || (b && d.defer && (b += d.defer), a.animationTimeout = N(function () {
                    a.afterAnimate();
                }, b || 0));
                a.isDirty = !1;
                a.hasRendered = !0;
                D(a, "afterRender");
            };
            a.prototype.redraw = function () {
                var a = this.chart, b = this.isDirty || this.isDirtyData, c = this.group, d = this.xAxis, e = this.yAxis;
                c && (a.inverted && c.attr({
                    width: a.plotWidth,
                    height: a.plotHeight
                }), c.animate({
                    translateX: K(d && d.left, a.plotLeft),
                    translateY: K(e && e.top, a.plotTop)
                }));
                this.translate();
                this.render();
                b && delete this.kdTree;
            };
            a.prototype.searchPoint = function (a, b) {
                var c = this.xAxis, d = this.yAxis, e = this.chart.inverted;
                return this.searchKDTree({
                    clientX: e ? c.len - a.chartY + c.pos : a.chartX - c.pos,
                    plotY: e ? d.len - a.chartX + d.pos : a.chartY - d.pos
                }, b, a);
            };
            a.prototype.buildKDTree = function (a) {
                function b(a, d, e) {
                    var f = a && a.length;
                    if (f) {
                        var g = c.kdAxisArray[d % e];
                        a.sort(function (a, b) {
                            return a[g] - b[g];
                        });
                        f = Math.floor(f / 2);
                        return {
                            point: a[f],
                            left: b(a.slice(0, f), d + 1, e),
                            right: b(a.slice(f + 1), d + 1, e)
                        };
                    }
                }
                this.buildingKdTree = !0;
                var c = this, d = -1 < c.options.findNearestPointBy.indexOf("y") ? 2 : 1;
                delete c.kdTree;
                N(function () {
                    c.kdTree = b(c.getValidPoints(null, !c.directTouch), d, d);
                    c.buildingKdTree = !1;
                }, c.options.kdNow || a && "touchstart" === a.type ? 0 : 1);
            };
            a.prototype.searchKDTree = function (a, b, c) {
                function d(a, b, c, i) {
                    var j = b.point, k = e.kdAxisArray[c % i], l = j, m = y(a[f]) && y(j[f]) ? Math.pow(a[f] - j[f], 2) : null;
                    var n = y(a[g]) && y(j[g]) ? Math.pow(a[g] - j[g], 2) : null;
                    n = (m || 0) + (n || 0);
                    j.dist = y(n) ? Math.sqrt(n) : Number.MAX_VALUE;
                    j.distX = y(m) ? Math.sqrt(m) : Number.MAX_VALUE;
                    k = a[k] - j[k];
                    n = 0 > k ? "left" : "right";
                    m = 0 > k ? "right" : "left";
                    b[n] && (n = d(a, b[n], c + 1, i), l = n[h] < l[h] ? n : j);
                    b[m] && Math.sqrt(k * k) < l[h] && (a = d(a, b[m], c + 1, i), l = a[h] < l[h] ? a : l);
                    return l;
                }
                var e = this, f = this.kdAxisArray[0], g = this.kdAxisArray[1], h = b ? "distX" : "dist";
                b = -1 < e.options.findNearestPointBy.indexOf("y") ? 2 : 1;
                this.kdTree || this.buildingKdTree || this.buildKDTree(c);
                if (this.kdTree) return d(a, this.kdTree, b, b);
            };
            a.prototype.pointPlacementToXValue = function () {
                var a = this.options, b = a.pointRange, c = this.xAxis;
                a = a.pointPlacement;
                "between" === a && (a = c.reversed ? -.5 : .5);
                return G(a) ? a * (b || c.pointRange) : 0;
            };
            a.prototype.isPointInside = function (a) {
                var b = this.chart, c = this.xAxis, d = this.yAxis;
                return "undefined" !== typeof a.plotY && "undefined" !== typeof a.plotX && 0 <= a.plotY && a.plotY <= (d ? d.len : b.plotHeight) && 0 <= a.plotX && a.plotX <= (c ? c.len : b.plotWidth);
            };
            a.prototype.drawTracker = function () {
                var a = this, b = a.options, c = b.trackByArea, d = [].concat(c ? a.areaPath : a.graphPath), e = a.chart, f = e.pointer, g = e.renderer, h = e.options.tooltip.snap, i = a.tracker, j = function (b) {
                    if (e.hoverSeries !== a) a.onMouseOver();
                }, k = "rgba(192,192,192," + (p ? 1e-4 : .002) + ")";
                i ? i.attr({
                    d: d
                }) : a.graph && (a.tracker = g.path(d).attr({
                    visibility: a.visible ? "visible" : "hidden",
                    zIndex: 2
                }).addClass(c ? "highcharts-tracker-area" : "highcharts-tracker-line").add(a.group),
                    e.styledMode || a.tracker.attr({
                        "stroke-linecap": "round",
                        "stroke-linejoin": "round",
                        stroke: k,
                        fill: c ? k : "none",
                        "stroke-width": a.graph.strokeWidth() + (c ? 0 : 2 * h)
                    }), [a.tracker, a.markerGroup, a.dataLabelsGroup].forEach(function (a) {
                        if (a && (a.addClass("highcharts-tracker").on("mouseover", j).on("mouseout", function (a) {
                            f.onTrackerMouseOut(a);
                        }), b.cursor && !e.styledMode && a.css({
                            cursor: b.cursor
                        }), o)) a.on("touchstart", j);
                    }));
                D(this, "afterDrawTracker");
            };
            a.prototype.addPoint = function (a, b, c, d, e) {
                var f = this.options, g = this.data, h = this.chart, i = this.xAxis;
                i = i && i.hasNames && i.names;
                var j = f.data, k = this.xData, l;
                b = K(b, !0);
                var m = {
                    series: this
                };
                this.pointClass.prototype.applyOptions.apply(m, [a]);
                var n = m.x;
                var o = k.length;
                if (this.requireSorting && n < k[o - 1]) for (l = !0; o && k[o - 1] > n;) o--;
                this.updateParallelArrays(m, "splice", o, 0, 0);
                this.updateParallelArrays(m, o);
                i && m.name && (i[n] = m.name);
                j.splice(o, 0, a);
                if (l || this.processedData) this.data.splice(o, 0, null), this.processData();
                "point" === f.legendType && this.generatePoints();
                c && (g[0] && g[0].remove ? g[0].remove(!1) : (g.shift(), this.updateParallelArrays(m, "shift"),
                    j.shift()));
                !1 !== e && D(this, "addPoint", {
                    point: m
                });
                this.isDirtyData = this.isDirty = !0;
                b && h.redraw(d);
            };
            a.prototype.removePoint = function (a, b, c) {
                var d = this, e = d.data, f = e[a], g = d.points, h = d.chart, i = function () {
                    g && g.length === e.length && g.splice(a, 1);
                    e.splice(a, 1);
                    d.options.data.splice(a, 1);
                    d.updateParallelArrays(f || {
                        series: d
                    }, "splice", a, 1);
                    f && f.destroy();
                    d.isDirty = !0;
                    d.isDirtyData = !0;
                    b && h.redraw();
                };
                l(c, h);
                b = K(b, !0);
                f ? f.firePointEvent("remove", null, i) : i();
            };
            a.prototype.remove = function (a, b, c, d) {
                function e() {
                    f.destroy(d);
                    g.isDirtyLegend = g.isDirtyBox = !0;
                    g.linkSeries();
                    K(a, !0) && g.redraw(b);
                }
                var f = this, g = f.chart;
                !1 !== c ? D(f, "remove", null, e) : e();
            };
            a.prototype.update = function (a, b) {
                a = w(a, this.userOptions);
                D(this, "update", {
                    options: a
                });
                var c = this, d = c.chart, e = c.userOptions, f = c.initialType || c.type, g = d.options.plotOptions, h = r[f].prototype, i = c.finishedAnimating && {
                    animation: !1
                }, j = {}, k, l = ["eventOptions", "navigatorSeries", "baseSeries"], m = a.type || e.type || d.options.chart.type, n = !(this.hasDerivedData || m && m !== this.type || "undefined" !== typeof a.pointStart || "undefined" !== typeof a.pointInterval || "undefined" !== typeof a.relativeXValue || a.joinBy || a.mapData || c.hasOptionChanged("dataGrouping") || c.hasOptionChanged("pointStart") || c.hasOptionChanged("pointInterval") || c.hasOptionChanged("pointIntervalUnit") || c.hasOptionChanged("keys"));
                m = m || f;
                n && (l.push("data", "isDirtyData", "points", "processedXData", "processedYData", "xIncrement", "cropped", "_hasPointMarkers", "_hasPointLabels", "clips", "nodes", "layout", "level", "mapMap", "mapData", "minY", "maxY", "minX", "maxX"),
                    !1 !== a.visible && l.push("area", "graph"), c.parallelArrays.forEach(function (a) {
                        l.push(a + "Data");
                    }), a.data && (a.dataSorting && B(c.options.dataSorting, a.dataSorting), this.setData(a.data, !1)));
                a = I(e, i, {
                    index: "undefined" === typeof e.index ? c.index : e.index,
                    pointStart: K(g && g.series && g.series.pointStart, e.pointStart, c.xData[0])
                }, !n && {
                    data: c.options.data
                }, a);
                n && a.data && (a.data = c.options.data);
                l = ["group", "markerGroup", "dataLabelsGroup", "transformGroup"].concat(l);
                l.forEach(function (a) {
                    l[a] = c[a];
                    delete c[a];
                });
                g = !1;
                if (r[m]) {
                    if (g = m !== c.type, c.remove(!1, !1, !1, !0), g) if (Object.setPrototypeOf) Object.setPrototypeOf(c, r[m].prototype); else {
                        i = Object.hasOwnProperty.call(c, "hcEvents") && c.hcEvents;
                        for (k in h) c[k] = void 0;
                        B(c, r[m].prototype);
                        i ? c.hcEvents = i : delete c.hcEvents;
                    }
                } else A(17, !0, d, {
                    missingModuleFor: m
                });
                l.forEach(function (a) {
                    c[a] = l[a];
                });
                c.init(d, a);
                if (n && this.points) {
                    var o = c.options;
                    !1 === o.visible ? (j.graphic = 1, j.dataLabel = 1) : c._hasPointLabels || (a = o.marker,
                        h = o.dataLabels, !a || !1 !== a.enabled && (e.marker && e.marker.symbol) === a.symbol || (j.graphic = 1),
                        h && !1 === h.enabled && (j.dataLabel = 1));
                    this.points.forEach(function (a) {
                        a && a.series && (a.resolveColor(), Object.keys(j).length && a.destroyElements(j),
                            !1 === o.showInLegend && a.legendItem && d.legend.destroyItem(a));
                    }, this);
                }
                c.initialType = f;
                d.linkSeries();
                g && c.linkedSeries.length && (c.isDirtyData = !0);
                D(this, "afterUpdate");
                K(b, !0) && d.redraw(n ? void 0 : !1);
            };
            a.prototype.setName = function (a) {
                this.name = this.options.name = this.userOptions.name = a;
                this.chart.isDirtyLegend = !0;
            };
            a.prototype.hasOptionChanged = function (a) {
                var b = this.options[a], c = this.chart.options.plotOptions, d = this.userOptions[a];
                return d ? b !== d : b !== K(c && c[this.type] && c[this.type][a], c && c.series && c.series[a], b);
            };
            a.prototype.onMouseOver = function () {
                var a = this.chart, b = a.hoverSeries;
                a.pointer.setHoverChartIndex();
                if (b && b !== this) b.onMouseOut();
                this.options.events.mouseOver && D(this, "mouseOver");
                this.setState("hover");
                a.hoverSeries = this;
            };
            a.prototype.onMouseOut = function () {
                var a = this.options, b = this.chart, c = b.tooltip, d = b.hoverPoint;
                b.hoverSeries = null;
                if (d) d.onMouseOut();
                this && a.events.mouseOut && D(this, "mouseOut");
                !c || this.stickyTracking || c.shared && !this.noSharedTooltip || c.hide();
                b.series.forEach(function (a) {
                    a.setState("", !0);
                });
            };
            a.prototype.setState = function (a, b) {
                var c = this, d = c.options, e = c.graph, f = d.inactiveOtherPoints, g = d.states, h = K(g[a || "normal"] && g[a || "normal"].animation, c.chart.options.chart.animation), i = d.lineWidth, j = 0, k = d.opacity;
                a = a || "";
                if (c.state !== a && ([c.group, c.markerGroup, c.dataLabelsGroup].forEach(function (b) {
                    b && (c.state && b.removeClass("highcharts-series-" + c.state), a && b.addClass("highcharts-series-" + a));
                }), c.state = a, !c.chart.styledMode)) {
                    if (g[a] && !1 === g[a].enabled) return;
                    a && (i = g[a].lineWidth || i + (g[a].lineWidthPlus || 0), k = K(g[a].opacity, k));
                    if (e && !e.dashstyle) for (d = {
                        "stroke-width": i
                    }, e.animate(d, h); c["zone-graph-" + j];) c["zone-graph-" + j].animate(d, h),
                        j += 1;
                    f || [c.group, c.markerGroup, c.dataLabelsGroup, c.labelBySeries].forEach(function (a) {
                        a && a.animate({
                            opacity: k
                        }, h);
                    });
                }
                b && f && c.points && c.setAllPointsToState(a || void 0);
            };
            a.prototype.setAllPointsToState = function (a) {
                this.points.forEach(function (b) {
                    b.setState && b.setState(a);
                });
            };
            a.prototype.setVisible = function (a, b) {
                var c = this, d = c.chart, e = c.legendItem, f = d.options.chart.ignoreHiddenSeries, g = c.visible, h = (c.visible = a = c.options.visible = c.userOptions.visible = "undefined" === typeof a ? !g : a) ? "show" : "hide";
                ["group", "dataLabelsGroup", "markerGroup", "tracker", "tt"].forEach(function (a) {
                    if (c[a]) c[a][h]();
                });
                if (d.hoverSeries === c || (d.hoverPoint && d.hoverPoint.series) === c) c.onMouseOut();
                e && d.legend.colorizeItem(c, a);
                c.isDirty = !0;
                c.options.stacking && d.series.forEach(function (a) {
                    a.options.stacking && a.visible && (a.isDirty = !0);
                });
                c.linkedSeries.forEach(function (b) {
                    b.setVisible(a, !1);
                });
                f && (d.isDirtyBox = !0);
                D(c, h);
                !1 !== b && d.redraw();
            };
            a.prototype.show = function () {
                this.setVisible(!0);
            };
            a.prototype.hide = function () {
                this.setVisible(!1);
            };
            a.prototype.select = function (a) {
                this.selected = a = this.options.selected = "undefined" === typeof a ? !this.selected : a;
                this.checkbox && (this.checkbox.checked = a);
                D(this, a ? "select" : "unselect");
            };
            a.prototype.shouldShowTooltip = function (a, b, c) {
                void 0 === c && (c = {});
                c.series = this;
                c.visiblePlotOnly = !0;
                return this.chart.isInsidePlot(a, b, c);
            };
            a.defaultOptions = g;
            return a;
        }();
        B(a.prototype, {
            axisTypes: ["xAxis", "yAxis"],
            coll: "series",
            colorCounter: 0,
            cropShoulder: 1,
            directTouch: !1,
            drawLegendSymbol: e.drawLineMarker,
            isCartesian: !0,
            kdAxisArray: ["clientX", "plotY"],
            parallelArrays: ["x", "y"],
            pointClass: f,
            requireSorting: !0,
            sorted: !0
        });
        h.series = a;
        return a;
    });
    b(c, "Extensions/ScrollablePlotArea.js", [c["Core/Animation/AnimationUtilities.js"], c["Core/Axis/Axis.js"], c["Core/Chart/Chart.js"], c["Core/Series/Series.js"], c["Core/Renderer/RendererRegistry.js"], c["Core/Utilities.js"]], function (a, b, c, d, e, f) {
        var g = a.stop, h = f.addEvent, i = f.createElement, j = f.merge, k = f.pick;
        h(c, "afterSetChartSize", function (a) {
            var c = this.options.chart.scrollablePlotArea, d = c && c.minWidth;
            c = c && c.minHeight;
            if (!this.renderer.forExport) {
                if (d) {
                    if (this.scrollablePixelsX = d = Math.max(0, d - this.chartWidth)) {
                        this.scrollablePlotBox = this.renderer.scrollablePlotBox = j(this.plotBox);
                        this.plotBox.width = this.plotWidth += d;
                        this.inverted ? this.clipBox.height += d : this.clipBox.width += d;
                        var e = {
                            1: {
                                name: "right",
                                value: d
                            }
                        };
                    }
                } else c && (this.scrollablePixelsY = d = Math.max(0, c - this.chartHeight)) && (this.scrollablePlotBox = this.renderer.scrollablePlotBox = j(this.plotBox),
                    this.plotBox.height = this.plotHeight += d, this.inverted ? this.clipBox.width += d : this.clipBox.height += d,
                    e = {
                        2: {
                            name: "bottom",
                            value: d
                        }
                    });
                e && !a.skipAxes && this.axes.forEach(function (a) {
                    e[a.side] ? a.getPlotLinePath = function () {
                        var c = e[a.side].name, d = this[c];
                        this[c] = d - e[a.side].value;
                        var f = b.prototype.getPlotLinePath.apply(this, arguments);
                        this[c] = d;
                        return f;
                    } : (a.setAxisSize(), a.setAxisTranslation());
                });
            }
        });
        h(c, "render", function () {
            this.scrollablePixelsX || this.scrollablePixelsY ? (this.setUpScrolling && this.setUpScrolling(),
                this.applyFixed()) : this.fixedDiv && this.applyFixed();
        });
        c.prototype.setUpScrolling = function () {
            var a = this, b = {
                WebkitOverflowScrolling: "touch",
                overflowX: "hidden",
                overflowY: "hidden"
            };
            this.scrollablePixelsX && (b.overflowX = "auto");
            this.scrollablePixelsY && (b.overflowY = "auto");
            this.scrollingParent = i("div", {
                className: "highcharts-scrolling-parent"
            }, {
                position: "relative"
            }, this.renderTo);
            this.scrollingContainer = i("div", {
                className: "highcharts-scrolling"
            }, b, this.scrollingParent);
            h(this.scrollingContainer, "scroll", function () {
                a.pointer && delete a.pointer.chartPosition;
            });
            this.innerContainer = i("div", {
                className: "highcharts-inner-container"
            }, null, this.scrollingContainer);
            this.innerContainer.appendChild(this.container);
            this.setUpScrolling = null;
        };
        c.prototype.moveFixedElements = function () {
            var a = this.container, b = this.fixedRenderer, c = ".highcharts-contextbutton .highcharts-credits .highcharts-legend .highcharts-legend-checkbox .highcharts-navigator-series .highcharts-navigator-xaxis .highcharts-navigator-yaxis .highcharts-navigator .highcharts-reset-zoom .highcharts-drillup-button .highcharts-scrollbar .highcharts-subtitle .highcharts-title".split(" "), d;
            this.scrollablePixelsX && !this.inverted ? d = ".highcharts-yaxis" : this.scrollablePixelsX && this.inverted ? d = ".highcharts-xaxis" : this.scrollablePixelsY && !this.inverted ? d = ".highcharts-xaxis" : this.scrollablePixelsY && this.inverted && (d = ".highcharts-yaxis");
            d && c.push(d + ":not(.highcharts-radial-axis)", d + "-labels:not(.highcharts-radial-axis-labels)");
            c.forEach(function (c) {
                [].forEach.call(a.querySelectorAll(c), function (a) {
                    (a.namespaceURI === b.SVG_NS ? b.box : b.box.parentNode).appendChild(a);
                    a.style.pointerEvents = "auto";
                });
            });
        };
        c.prototype.applyFixed = function () {
            var a = !this.fixedDiv, b = this.options.chart, c = b.scrollablePlotArea, d = e.getRendererType();
            a ? (this.fixedDiv = i("div", {
                className: "highcharts-fixed"
            }, {
                position: "absolute",
                overflow: "hidden",
                pointerEvents: "none",
                zIndex: (b.style && b.style.zIndex || 0) + 2,
                top: 0
            }, null, !0), this.scrollingContainer && this.scrollingContainer.parentNode.insertBefore(this.fixedDiv, this.scrollingContainer),
                this.renderTo.style.overflow = "visible", this.fixedRenderer = b = new d(this.fixedDiv, this.chartWidth, this.chartHeight, this.options.chart.style),
                this.scrollableMask = b.path().attr({
                    fill: this.options.chart.backgroundColor || "#fff",
                    "fill-opacity": k(c.opacity, .85),
                    zIndex: -1
                }).addClass("highcharts-scrollable-mask").add(), h(this, "afterShowResetZoom", this.moveFixedElements),
                h(this, "afterApplyDrilldown", this.moveFixedElements), h(this, "afterLayOutTitles", this.moveFixedElements)) : this.fixedRenderer.setSize(this.chartWidth, this.chartHeight);
            if (this.scrollableDirty || a) this.scrollableDirty = !1, this.moveFixedElements();
            b = this.chartWidth + (this.scrollablePixelsX || 0);
            d = this.chartHeight + (this.scrollablePixelsY || 0);
            g(this.container);
            this.container.style.width = b + "px";
            this.container.style.height = d + "px";
            this.renderer.boxWrapper.attr({
                width: b,
                height: d,
                viewBox: [0, 0, b, d].join(" ")
            });
            this.chartBackground.attr({
                width: b,
                height: d
            });
            this.scrollingContainer.style.height = this.chartHeight + "px";
            a && (c.scrollPositionX && (this.scrollingContainer.scrollLeft = this.scrollablePixelsX * c.scrollPositionX),
                c.scrollPositionY && (this.scrollingContainer.scrollTop = this.scrollablePixelsY * c.scrollPositionY));
            d = this.axisOffset;
            a = this.plotTop - d[0] - 1;
            c = this.plotLeft - d[3] - 1;
            b = this.plotTop + this.plotHeight + d[2] + 1;
            d = this.plotLeft + this.plotWidth + d[1] + 1;
            var f = this.plotLeft + this.plotWidth - (this.scrollablePixelsX || 0), j = this.plotTop + this.plotHeight - (this.scrollablePixelsY || 0);
            a = this.scrollablePixelsX ? [["M", 0, a], ["L", this.plotLeft - 1, a], ["L", this.plotLeft - 1, b], ["L", 0, b], ["Z"], ["M", f, a], ["L", this.chartWidth, a], ["L", this.chartWidth, b], ["L", f, b], ["Z"]] : this.scrollablePixelsY ? [["M", c, 0], ["L", c, this.plotTop - 1], ["L", d, this.plotTop - 1], ["L", d, 0], ["Z"], ["M", c, j], ["L", c, this.chartHeight], ["L", d, this.chartHeight], ["L", d, j], ["Z"]] : [["M", 0, 0]];
            "adjustHeight" !== this.redrawTrigger && this.scrollableMask.attr({
                d: a
            });
        };
        h(b, "afterInit", function () {
            this.chart.scrollableDirty = !0;
        });
        h(d, "show", function () {
            this.chart.scrollableDirty = !0;
        });
    });
    b(c, "Core/Axis/StackingAxis.js", [c["Core/Animation/AnimationUtilities.js"], c["Core/Axis/Axis.js"], c["Core/Utilities.js"]], function (a, b, c) {
        var d = a.getDeferredAnimation, e = c.addEvent, f = c.destroyObjectProperties, g = c.fireEvent, h = c.isNumber, i = c.objectEach, j;
        !function (a) {
            function b() {
                var a = this.stacking;
                if (a) {
                    var b = a.stacks;
                    i(b, function (a, c) {
                        f(a);
                        b[c] = null;
                    });
                    a && a.stackTotalGroup && a.stackTotalGroup.destroy();
                }
            }
            function c() {
                this.stacking || (this.stacking = new k(this));
            }
            var j = [];
            a.compose = function (a) {
                -1 === j.indexOf(a) && (j.push(a), e(a, "init", c), e(a, "destroy", b));
                return a;
            };
            var k = function () {
                function a(a) {
                    this.oldStacks = {};
                    this.stacks = {};
                    this.stacksTouched = 0;
                    this.axis = a;
                }
                a.prototype.buildStacks = function () {
                    var a = this.axis, b = a.series, c = a.options.reversedStacks, d = b.length, e;
                    if (!a.isXAxis) {
                        this.usePercentage = !1;
                        for (e = d; e--;) {
                            var f = b[c ? e : d - e - 1];
                            f.setStackedPoints();
                            f.setGroupedPoints();
                        }
                        for (e = 0; e < d; e++) b[e].modifyStacks();
                        g(a, "afterBuildStacks");
                    }
                };
                a.prototype.cleanStacks = function () {
                    if (!this.axis.isXAxis) {
                        if (this.oldStacks) var a = this.stacks = this.oldStacks;
                        i(a, function (a) {
                            i(a, function (a) {
                                a.cumulative = a.total;
                            });
                        });
                    }
                };
                a.prototype.resetStacks = function () {
                    var a = this, b = a.stacks;
                    a.axis.isXAxis || i(b, function (b) {
                        i(b, function (c, d) {
                            h(c.touched) && c.touched < a.stacksTouched ? (c.destroy(), delete b[d]) : (c.total = null,
                                c.cumulative = null);
                        });
                    });
                };
                a.prototype.renderStackTotals = function () {
                    var a = this.axis, b = a.chart, c = b.renderer, e = this.stacks;
                    a = d(b, a.options.stackLabels && a.options.stackLabels.animation || !1);
                    var f = this.stackTotalGroup = this.stackTotalGroup || c.g("stack-labels").attr({
                        visibility: "visible",
                        zIndex: 6,
                        opacity: 0
                    }).add();
                    f.translate(b.plotLeft, b.plotTop);
                    i(e, function (a) {
                        i(a, function (a) {
                            a.render(f);
                        });
                    });
                    f.animate({
                        opacity: 1
                    }, a);
                };
                return a;
            }();
            a.Additions = k;
        }(j || (j = {}));
        return j;
    });
    b(c, "Extensions/Stacking.js", [c["Core/Axis/Axis.js"], c["Core/Chart/Chart.js"], c["Core/FormatUtilities.js"], c["Core/Globals.js"], c["Core/Series/Series.js"], c["Core/Axis/StackingAxis.js"], c["Core/Utilities.js"]], function (a, b, c, d, e, f, g) {
        var h = c.format, i = g.correctFloat, j = g.defined, k = g.destroyObjectProperties, l = g.isArray, m = g.isNumber, n = g.objectEach, o = g.pick, p = function () {
            function a(a, b, c, d, e) {
                var f = a.chart.inverted;
                this.axis = a;
                this.isNegative = c;
                this.options = b = b || {};
                this.x = d;
                this.total = null;
                this.points = {};
                this.hasValidPoints = !1;
                this.stack = e;
                this.rightCliff = this.leftCliff = 0;
                this.alignOptions = {
                    align: b.align || (f ? c ? "left" : "right" : "center"),
                    verticalAlign: b.verticalAlign || (f ? "middle" : c ? "bottom" : "top"),
                    y: b.y,
                    x: b.x
                };
                this.textAlign = b.textAlign || (f ? c ? "right" : "left" : "center");
            }
            a.prototype.destroy = function () {
                k(this, this.axis);
            };
            a.prototype.render = function (a) {
                var b = this.axis.chart, c = this.options, d = c.format;
                d = d ? h(d, this, b) : c.formatter.call(this);
                this.label ? this.label.attr({
                    text: d,
                    visibility: "hidden"
                }) : (this.label = b.renderer.label(d, null, null, c.shape, null, null, c.useHTML, !1, "stack-labels"),
                    d = {
                        r: c.borderRadius || 0,
                        text: d,
                        rotation: c.rotation,
                        padding: o(c.padding, 5),
                        visibility: "hidden"
                    }, b.styledMode || (d.fill = c.backgroundColor, d.stroke = c.borderColor, d["stroke-width"] = c.borderWidth,
                        this.label.css(c.style)), this.label.attr(d), this.label.added || this.label.add(a));
                this.label.labelrank = b.plotSizeY;
            };
            a.prototype.setOffset = function (a, b, c, d, f) {
                var g = this.axis, h = g.chart;
                d = g.translate(g.stacking.usePercentage ? 100 : d ? d : this.total, 0, 0, 0, 1);
                c = g.translate(c ? c : 0);
                c = j(d) && Math.abs(d - c);
                a = o(f, h.xAxis[0].translate(this.x)) + a;
                g = j(d) && this.getStackBox(h, this, a, d, b, c, g);
                b = this.label;
                c = this.isNegative;
                a = "justify" === o(this.options.overflow, "justify");
                var i = this.textAlign;
                b && g && (f = b.getBBox(), d = b.padding, i = "left" === i ? h.inverted ? -d : d : "right" === i ? f.width : h.inverted && "center" === i ? f.width / 2 : h.inverted ? c ? f.width + d : -d : f.width / 2,
                    c = h.inverted ? f.height / 2 : c ? -d : f.height, this.alignOptions.x = o(this.options.x, 0),
                    this.alignOptions.y = o(this.options.y, 0), g.x -= i, g.y -= c, b.align(this.alignOptions, null, g),
                    h.isInsidePlot(b.alignAttr.x + i - this.alignOptions.x, b.alignAttr.y + c - this.alignOptions.y) ? b.show() : (b.alignAttr.y = -9999,
                        a = !1), a && e.prototype.justifyDataLabel.call(this.axis, b, this.alignOptions, b.alignAttr, f, g),
                    b.attr({
                        x: b.alignAttr.x,
                        y: b.alignAttr.y
                    }), o(!a && this.options.crop, !0) && ((h = m(b.x) && m(b.y) && h.isInsidePlot(b.x - d + b.width, b.y) && h.isInsidePlot(b.x + d, b.y)) || b.hide()));
            };
            a.prototype.getStackBox = function (a, b, c, d, e, f, g) {
                var h = b.axis.reversed, i = a.inverted, j = g.height + g.pos - (i ? a.plotLeft : a.plotTop);
                b = b.isNegative && !h || !b.isNegative && h;
                return {
                    x: i ? b ? d - g.right : d - f + g.pos - a.plotLeft : c + a.xAxis[0].transB - a.plotLeft,
                    y: i ? g.height - c - e : b ? j - d - f : j - d,
                    width: i ? f : e,
                    height: i ? e : f
                };
            };
            return a;
        }();
        b.prototype.getStacks = function () {
            var a = this, b = a.inverted;
            a.yAxis.forEach(function (a) {
                a.stacking && a.stacking.stacks && a.hasVisibleSeries && (a.stacking.oldStacks = a.stacking.stacks);
            });
            a.series.forEach(function (c) {
                var d = c.xAxis && c.xAxis.options || {};
                !c.options.stacking || !0 !== c.visible && !1 !== a.options.chart.ignoreHiddenSeries || (c.stackKey = [c.type, o(c.options.stack, ""), b ? d.top : d.left, b ? d.height : d.width].join());
            });
        };
        f.compose(a);
        e.prototype.setGroupedPoints = function () {
            var a = this.yAxis.stacking;
            this.options.centerInCategory && (this.is("column") || this.is("columnrange")) && !this.options.stacking && 1 < this.chart.series.length ? e.prototype.setStackedPoints.call(this, "group") : a && n(a.stacks, function (b, c) {
                "group" === c.slice(-5) && (n(b, function (a) {
                    return a.destroy();
                }), delete a.stacks[c]);
            });
        };
        e.prototype.setStackedPoints = function (a) {
            var b = a || this.options.stacking;
            if (b && (!0 === this.visible || !1 === this.chart.options.chart.ignoreHiddenSeries)) {
                var c = this.processedXData, d = this.processedYData, e = [], f = d.length, g = this.options, h = g.threshold, k = o(g.startFromThreshold && h, 0);
                g = g.stack;
                a = a ? this.type + "," + b : this.stackKey;
                var m = "-" + a, n = this.negStacks, q = this.yAxis, r = q.stacking.stacks, s = q.stacking.oldStacks, t, u;
                q.stacking.stacksTouched += 1;
                for (u = 0; u < f; u++) {
                    var v = c[u];
                    var w = d[u];
                    var x = this.getStackIndicator(x, v, this.index);
                    var y = x.key;
                    var z = (t = n && w < (k ? 0 : h)) ? m : a;
                    r[z] || (r[z] = {});
                    r[z][v] || (s[z] && s[z][v] ? (r[z][v] = s[z][v], r[z][v].total = null) : r[z][v] = new p(q, q.options.stackLabels, t, v, g));
                    z = r[z][v];
                    null !== w ? (z.points[y] = z.points[this.index] = [o(z.cumulative, k)], j(z.cumulative) || (z.base = y),
                        z.touched = q.stacking.stacksTouched, 0 < x.index && !1 === this.singleStacks && (z.points[y][0] = z.points[this.index + "," + v + ",0"][0])) : z.points[y] = z.points[this.index] = null;
                    "percent" === b ? (t = t ? a : m, n && r[t] && r[t][v] ? (t = r[t][v], z.total = t.total = Math.max(t.total, z.total) + Math.abs(w) || 0) : z.total = i(z.total + (Math.abs(w) || 0))) : "group" === b ? (l(w) && (w = w[0]),
                        null !== w && (z.total = (z.total || 0) + 1)) : z.total = i(z.total + (w || 0));
                    z.cumulative = "group" === b ? (z.total || 1) - 1 : o(z.cumulative, k) + (w || 0);
                    null !== w && (z.points[y].push(z.cumulative), e[u] = z.cumulative, z.hasValidPoints = !0);
                }
                "percent" === b && (q.stacking.usePercentage = !0);
                "group" !== b && (this.stackedYData = e);
                q.stacking.oldStacks = {};
            }
        };
        e.prototype.modifyStacks = function () {
            var a = this, b = a.stackKey, c = a.yAxis.stacking.stacks, d = a.processedXData, e, f = a.options.stacking;
            a[f + "Stacker"] && [b, "-" + b].forEach(function (b) {
                for (var g = d.length, h, i; g--;) if (h = d[g], e = a.getStackIndicator(e, h, a.index, b),
                    i = (h = c[b] && c[b][h]) && h.points[e.key]) a[f + "Stacker"](i, h, g);
            });
        };
        e.prototype.percentStacker = function (a, b, c) {
            b = b.total ? 100 / b.total : 0;
            a[0] = i(a[0] * b);
            a[1] = i(a[1] * b);
            this.stackedYData[c] = a[1];
        };
        e.prototype.getStackIndicator = function (a, b, c, d) {
            !j(a) || a.x !== b || d && a.stackKey !== d ? a = {
                x: b,
                index: 0,
                key: d,
                stackKey: d
            } : a.index++;
            a.key = [c, b, a.index].join();
            return a;
        };
        d.StackItem = p;
        return d.StackItem;
    });
    b(c, "Series/Line/LineSeries.js", [c["Core/Series/Series.js"], c["Core/Series/SeriesRegistry.js"], c["Core/Utilities.js"]], function (a, b, c) {
        var d = this && this.__extends || function () {
            var a = function (b, c) {
                a = Object.setPrototypeOf || {
                    __proto__: []
                } instanceof Array && function (a, b) {
                    a.__proto__ = b;
                } || function (a, b) {
                    for (var c in b) b.hasOwnProperty(c) && (a[c] = b[c]);
                };
                return a(b, c);
            };
            return function (b, c) {
                function d() {
                    this.constructor = b;
                }
                a(b, c);
                b.prototype = null === c ? Object.create(c) : (d.prototype = c.prototype, new d());
            };
        }(), e = c.defined, f = c.merge;
        c = function (b) {
            function c() {
                var a = null !== b && b.apply(this, arguments) || this;
                a.data = void 0;
                a.options = void 0;
                a.points = void 0;
                return a;
            }
            d(c, b);
            c.prototype.drawGraph = function () {
                var a = this, b = this.options, c = (this.gappedPath || this.getGraphPath).call(this), d = this.chart.styledMode, e = [["graph", "highcharts-graph"]];
                d || e[0].push(b.lineColor || this.color || "#cccccc", b.dashStyle);
                e = a.getZonesGraphs(e);
                e.forEach(function (e, f) {
                    var g = e[0], h = a[g], i = h ? "animate" : "attr";
                    h ? (h.endX = a.preventGraphAnimation ? null : c.xMap, h.animate({
                        d: c
                    })) : c.length && (a[g] = h = a.chart.renderer.path(c).addClass(e[1]).attr({
                        zIndex: 1
                    }).add(a.group));
                    h && !d && (g = {
                        stroke: e[2],
                        "stroke-width": b.lineWidth,
                        fill: a.fillGraph && a.color || "none"
                    }, e[3] ? g.dashstyle = e[3] : "square" !== b.linecap && (g["stroke-linecap"] = g["stroke-linejoin"] = "round"),
                        h[i](g).shadow(2 > f && b.shadow));
                    h && (h.startX = c.xMap, h.isArea = c.isArea);
                });
            };
            c.prototype.getGraphPath = function (a, b, c) {
                var d = this, f = d.options, g = [], h = [], i, j = f.step;
                a = a || d.points;
                var k = a.reversed;
                k && a.reverse();
                (j = {
                    right: 1,
                    center: 2
                }[j] || j && 3) && k && (j = 4 - j);
                a = this.getValidPoints(a, !1, !(f.connectNulls && !b && !c));
                a.forEach(function (k, l) {
                    var m = k.plotX, n = k.plotY, o = a[l - 1];
                    (k.leftCliff || o && o.rightCliff) && !c && (i = !0);
                    k.isNull && !e(b) && 0 < l ? i = !f.connectNulls : k.isNull && !b ? i = !0 : (0 === l || i ? l = [["M", k.plotX, k.plotY]] : d.getPointSpline ? l = [d.getPointSpline(a, k, l)] : j ? (l = 1 === j ? [["L", o.plotX, n]] : 2 === j ? [["L", (o.plotX + m) / 2, o.plotY], ["L", (o.plotX + m) / 2, n]] : [["L", m, o.plotY]],
                        l.push(["L", m, n])) : l = [["L", m, n]], h.push(k.x), j && (h.push(k.x),
                            2 === j && h.push(k.x)), g.push.apply(g, l), i = !1);
                });
                g.xMap = h;
                return d.graphPath = g;
            };
            c.prototype.getZonesGraphs = function (a) {
                this.zones.forEach(function (b, c) {
                    c = ["zone-graph-" + c, "highcharts-graph highcharts-zone-graph-" + c + " " + (b.className || "")];
                    this.chart.styledMode || c.push(b.color || this.color, b.dashStyle || this.options.dashStyle);
                    a.push(c);
                }, this);
                return a;
            };
            c.defaultOptions = f(a.defaultOptions, {});
            return c;
        }(a);
        b.registerSeriesType("line", c);
        return c;
    });
    b(c, "Series/Area/AreaSeries.js", [c["Core/Color/Color.js"], c["Core/Legend/LegendSymbol.js"], c["Core/Series/SeriesRegistry.js"], c["Core/Utilities.js"]], function (a, b, c, d) {
        var e = this && this.__extends || function () {
            var a = function (b, c) {
                a = Object.setPrototypeOf || {
                    __proto__: []
                } instanceof Array && function (a, b) {
                    a.__proto__ = b;
                } || function (a, b) {
                    for (var c in b) b.hasOwnProperty(c) && (a[c] = b[c]);
                };
                return a(b, c);
            };
            return function (b, c) {
                function d() {
                    this.constructor = b;
                }
                a(b, c);
                b.prototype = null === c ? Object.create(c) : (d.prototype = c.prototype, new d());
            };
        }(), f = a.parse, g = c.seriesTypes.line;
        a = d.extend;
        var h = d.merge, i = d.objectEach, j = d.pick;
        d = function (a) {
            function b() {
                var b = null !== a && a.apply(this, arguments) || this;
                b.data = void 0;
                b.options = void 0;
                b.points = void 0;
                return b;
            }
            e(b, a);
            b.prototype.drawGraph = function () {
                this.areaPath = [];
                a.prototype.drawGraph.apply(this);
                var b = this, c = this.areaPath, d = this.options, e = [["area", "highcharts-area", this.color, d.fillColor]];
                this.zones.forEach(function (a, c) {
                    e.push(["zone-area-" + c, "highcharts-area highcharts-zone-area-" + c + " " + a.className, a.color || b.color, a.fillColor || d.fillColor]);
                });
                e.forEach(function (a) {
                    var e = a[0], g = b[e], h = g ? "animate" : "attr", i = {};
                    g ? (g.endX = b.preventGraphAnimation ? null : c.xMap, g.animate({
                        d: c
                    })) : (i.zIndex = 0, g = b[e] = b.chart.renderer.path(c).addClass(a[1]).add(b.group),
                        g.isArea = !0);
                    b.chart.styledMode || (i.fill = j(a[3], f(a[2]).setOpacity(j(d.fillOpacity, .75)).get()));
                    g[h](i);
                    g.startX = c.xMap;
                    g.shiftUnit = d.step ? 2 : 1;
                });
            };
            b.prototype.getGraphPath = function (a) {
                var b = g.prototype.getGraphPath, c = this.options, d = c.stacking, e = this.yAxis, f, h = [], i = [], k = this.index, l = e.stacking.stacks[this.stackKey], m = c.threshold, n = Math.round(e.getThreshold(c.threshold));
                c = j(c.connectNulls, "percent" === d);
                var o = function (b, c, f) {
                    var g = a[b];
                    b = d && l[g.x].points[k];
                    var j = g[f + "Null"] || 0;
                    f = g[f + "Cliff"] || 0;
                    g = !0;
                    if (f || j) {
                        var o = (j ? b[0] : b[1]) + f;
                        var p = b[0] + f;
                        g = !!j;
                    } else !d && a[c] && a[c].isNull && (o = p = m);
                    "undefined" !== typeof o && (i.push({
                        plotX: q,
                        plotY: null === o ? n : e.getThreshold(o),
                        isNull: g,
                        isCliff: !0
                    }), h.push({
                        plotX: q,
                        plotY: null === p ? n : e.getThreshold(p),
                        doCurve: !1
                    }));
                };
                a = a || this.points;
                d && (a = this.getStackPoints(a));
                for (f = 0; f < a.length; f++) {
                    d || (a[f].leftCliff = a[f].rightCliff = a[f].leftNull = a[f].rightNull = void 0);
                    var p = a[f].isNull;
                    var q = j(a[f].rectPlotX, a[f].plotX);
                    var r = d ? j(a[f].yBottom, n) : n;
                    if (!p || c) c || o(f, f - 1, "left"), p && !d && c || (i.push(a[f]), h.push({
                        x: f,
                        plotX: q,
                        plotY: r
                    })), c || o(f, f + 1, "right");
                }
                f = b.call(this, i, !0, !0);
                h.reversed = !0;
                p = b.call(this, h, !0, !0);
                (r = p[0]) && "M" === r[0] && (p[0] = ["L", r[1], r[2]]);
                p = f.concat(p);
                p.length && p.push(["Z"]);
                b = b.call(this, i, !1, c);
                p.xMap = f.xMap;
                this.areaPath = p;
                return b;
            };
            b.prototype.getStackPoints = function (a) {
                var b = this, c = [], d = [], e = this.xAxis, f = this.yAxis, g = f.stacking.stacks[this.stackKey], h = {}, k = f.series, l = k.length, m = f.options.reversedStacks ? 1 : -1, n = k.indexOf(b);
                a = a || this.points;
                if (this.options.stacking) {
                    for (var o = 0; o < a.length; o++) a[o].leftNull = a[o].rightNull = void 0, h[a[o].x] = a[o];
                    i(g, function (a, b) {
                        null !== a.total && d.push(b);
                    });
                    d.sort(function (a, b) {
                        return a - b;
                    });
                    var p = k.map(function (a) {
                        return a.visible;
                    });
                    d.forEach(function (a, i) {
                        var o = 0, q, r;
                        if (h[a] && !h[a].isNull) c.push(h[a]), [-1, 1].forEach(function (c) {
                            var e = 1 === c ? "rightNull" : "leftNull", f = 0, j = g[d[i + c]];
                            if (j) for (var o = n; 0 <= o && o < l;) {
                                var s = k[o].index;
                                q = j.points[s];
                                q || (s === b.index ? h[a][e] = !0 : p[o] && (r = g[a].points[s]) && (f -= r[1] - r[0]));
                                o += m;
                            }
                            h[a][1 === c ? "rightCliff" : "leftCliff"] = f;
                        }); else {
                            for (var s = n; 0 <= s && s < l;) {
                                if (q = g[a].points[k[s].index]) {
                                    o = q[1];
                                    break;
                                }
                                s += m;
                            }
                            o = j(o, 0);
                            o = f.translate(o, 0, 1, 0, 1);
                            c.push({
                                isNull: !0,
                                plotX: e.translate(a, 0, 0, 0, 1),
                                x: a,
                                plotY: o,
                                yBottom: o
                            });
                        }
                    });
                }
                return c;
            };
            b.defaultOptions = h(g.defaultOptions, {
                threshold: 0
            });
            return b;
        }(g);
        a(d.prototype, {
            singleStacks: !1,
            drawLegendSymbol: b.drawRectangle
        });
        c.registerSeriesType("area", d);
        return d;
    });
    b(c, "Series/Spline/SplineSeries.js", [c["Core/Series/SeriesRegistry.js"], c["Core/Utilities.js"]], function (a, b) {
        var c = this && this.__extends || function () {
            var a = function (b, c) {
                a = Object.setPrototypeOf || {
                    __proto__: []
                } instanceof Array && function (a, b) {
                    a.__proto__ = b;
                } || function (a, b) {
                    for (var c in b) b.hasOwnProperty(c) && (a[c] = b[c]);
                };
                return a(b, c);
            };
            return function (b, c) {
                function d() {
                    this.constructor = b;
                }
                a(b, c);
                b.prototype = null === c ? Object.create(c) : (d.prototype = c.prototype, new d());
            };
        }(), d = a.seriesTypes.line, e = b.merge, f = b.pick;
        b = function (a) {
            function b() {
                var b = null !== a && a.apply(this, arguments) || this;
                b.data = void 0;
                b.options = void 0;
                b.points = void 0;
                return b;
            }
            c(b, a);
            b.prototype.getPointSpline = function (a, b, c) {
                var d = b.plotX || 0, e = b.plotY || 0, g = a[c - 1];
                c = a[c + 1];
                if (g && !g.isNull && !1 !== g.doCurve && !b.isCliff && c && !c.isNull && !1 !== c.doCurve && !b.isCliff) {
                    a = g.plotY || 0;
                    var h = c.plotX || 0;
                    c = c.plotY || 0;
                    var i = 0;
                    var j = (1.5 * d + (g.plotX || 0)) / 2.5;
                    var k = (1.5 * e + a) / 2.5;
                    h = (1.5 * d + h) / 2.5;
                    var l = (1.5 * e + c) / 2.5;
                    h !== j && (i = (l - k) * (h - d) / (h - j) + e - l);
                    k += i;
                    l += i;
                    k > a && k > e ? (k = Math.max(a, e), l = 2 * e - k) : k < a && k < e && (k = Math.min(a, e),
                        l = 2 * e - k);
                    l > c && l > e ? (l = Math.max(c, e), k = 2 * e - l) : l < c && l < e && (l = Math.min(c, e),
                        k = 2 * e - l);
                    b.rightContX = h;
                    b.rightContY = l;
                }
                b = ["C", f(g.rightContX, g.plotX, 0), f(g.rightContY, g.plotY, 0), f(j, d, 0), f(k, e, 0), d, e];
                g.rightContX = g.rightContY = void 0;
                return b;
            };
            b.defaultOptions = e(d.defaultOptions);
            return b;
        }(d);
        a.registerSeriesType("spline", b);
        return b;
    });
    b(c, "Series/AreaSpline/AreaSplineSeries.js", [c["Series/Area/AreaSeries.js"], c["Series/Spline/SplineSeries.js"], c["Core/Legend/LegendSymbol.js"], c["Core/Series/SeriesRegistry.js"], c["Core/Utilities.js"]], function (a, b, c, d, e) {
        var f = this && this.__extends || function () {
            var a = function (b, c) {
                a = Object.setPrototypeOf || {
                    __proto__: []
                } instanceof Array && function (a, b) {
                    a.__proto__ = b;
                } || function (a, b) {
                    for (var c in b) b.hasOwnProperty(c) && (a[c] = b[c]);
                };
                return a(b, c);
            };
            return function (b, c) {
                function d() {
                    this.constructor = b;
                }
                a(b, c);
                b.prototype = null === c ? Object.create(c) : (d.prototype = c.prototype, new d());
            };
        }(), g = a.prototype, h = e.extend, i = e.merge;
        e = function (c) {
            function d() {
                var a = null !== c && c.apply(this, arguments) || this;
                a.data = void 0;
                a.points = void 0;
                a.options = void 0;
                return a;
            }
            f(d, c);
            d.defaultOptions = i(b.defaultOptions, a.defaultOptions);
            return d;
        }(b);
        h(e.prototype, {
            getGraphPath: g.getGraphPath,
            getStackPoints: g.getStackPoints,
            drawGraph: g.drawGraph,
            drawLegendSymbol: c.drawRectangle
        });
        d.registerSeriesType("areaspline", e);
        return e;
    });
    b(c, "Series/Column/ColumnSeries.js", [c["Core/Animation/AnimationUtilities.js"], c["Core/Color/Color.js"], c["Core/Globals.js"], c["Core/Legend/LegendSymbol.js"], c["Core/Series/Series.js"], c["Core/Series/SeriesRegistry.js"], c["Core/Utilities.js"]], function (a, b, c, d, e, f, g) {
        var h = this && this.__extends || function () {
            var a = function (b, c) {
                a = Object.setPrototypeOf || {
                    __proto__: []
                } instanceof Array && function (a, b) {
                    a.__proto__ = b;
                } || function (a, b) {
                    for (var c in b) b.hasOwnProperty(c) && (a[c] = b[c]);
                };
                return a(b, c);
            };
            return function (b, c) {
                function d() {
                    this.constructor = b;
                }
                a(b, c);
                b.prototype = null === c ? Object.create(c) : (d.prototype = c.prototype, new d());
            };
        }(), i = a.animObject, j = b.parse, k = c.hasTouch;
        a = c.noop;
        var l = g.clamp, m = g.css, n = g.defined, o = g.extend, p = g.fireEvent, q = g.isArray, r = g.isNumber, s = g.merge, t = g.pick, u = g.objectEach;
        g = function (a) {
            function b() {
                var b = null !== a && a.apply(this, arguments) || this;
                b.borderWidth = void 0;
                b.data = void 0;
                b.group = void 0;
                b.options = void 0;
                b.points = void 0;
                return b;
            }
            h(b, a);
            b.prototype.animate = function (a) {
                var b = this, c = this.yAxis, d = b.options, e = this.chart.inverted, f = {}, g = e ? "translateX" : "translateY";
                if (a) f.scaleY = .001, a = l(c.toPixels(d.threshold), c.pos, c.pos + c.len), e ? f.translateX = a - c.len : f.translateY = a,
                    b.clipBox && b.setClip(), b.group.attr(f); else {
                    var h = Number(b.group.attr(g));
                    b.group.animate({
                        scaleY: 1
                    }, o(i(b.options.animation), {
                        step: function (a, d) {
                            b.group && (f[g] = h + d.pos * (c.pos - h), b.group.attr(f));
                        }
                    }));
                }
            };
            b.prototype.init = function (b, c) {
                a.prototype.init.apply(this, arguments);
                var d = this;
                b = d.chart;
                b.hasRendered && b.series.forEach(function (a) {
                    a.type === d.type && (a.isDirty = !0);
                });
            };
            b.prototype.getColumnMetrics = function () {
                var a = this, b = a.options, c = a.xAxis, d = a.yAxis, e = c.options.reversedStacks;
                e = c.reversed && !e || !c.reversed && e;
                var f = {}, g, h = 0;
                !1 === b.grouping ? h = 1 : a.chart.series.forEach(function (b) {
                    var c = b.yAxis, e = b.options;
                    if (b.type === a.type && (b.visible || !a.chart.options.chart.ignoreHiddenSeries) && d.len === c.len && d.pos === c.pos) {
                        if (e.stacking && "group" !== e.stacking) {
                            g = b.stackKey;
                            "undefined" === typeof f[g] && (f[g] = h++);
                            var i = f[g];
                        } else !1 !== e.grouping && (i = h++);
                        b.columnIndex = i;
                    }
                });
                var i = Math.min(Math.abs(c.transA) * (c.ordinal && c.ordinal.slope || b.pointRange || c.closestPointRange || c.tickInterval || 1), c.len), j = i * b.groupPadding, k = (i - 2 * j) / (h || 1);
                b = Math.min(b.maxPointWidth || c.len, t(b.pointWidth, k * (1 - 2 * b.pointPadding)));
                a.columnMetrics = {
                    width: b,
                    offset: (k - b) / 2 + (j + ((a.columnIndex || 0) + (e ? 1 : 0)) * k - i / 2) * (e ? -1 : 1),
                    paddedWidth: k,
                    columnCount: h
                };
                return a.columnMetrics;
            };
            b.prototype.crispCol = function (a, b, c, d) {
                var e = this.chart, f = this.borderWidth, g = -(f % 2 ? .5 : 0);
                f = f % 2 ? .5 : 1;
                e.inverted && e.renderer.isVML && (f += 1);
                this.options.crisp && (c = Math.round(a + c) + g, a = Math.round(a) + g, c -= a);
                d = Math.round(b + d) + f;
                g = .5 >= Math.abs(b) && .5 < d;
                b = Math.round(b) + f;
                d -= b;
                g && d && (--b, d += 1);
                return {
                    x: a,
                    y: b,
                    width: c,
                    height: d
                };
            };
            b.prototype.adjustForMissingColumns = function (a, b, c, d) {
                var e = this, f = this.options.stacking;
                if (!c.isNull && 1 < d.columnCount) {
                    var g = this.yAxis.options.reversedStacks, h = 0, i = g ? 0 : -d.columnCount;
                    u(this.yAxis.stacking && this.yAxis.stacking.stacks, function (a) {
                        if ("number" === typeof c.x && (a = a[c.x.toString()])) {
                            var b = a.points[e.index], d = a.total;
                            f ? (b && (h = i), a.hasValidPoints && (g ? i++ : i--)) : q(b) && (h = b[1], i = d || 0);
                        }
                    });
                    a = (c.plotX || 0) + ((i - 1) * d.paddedWidth + b) / 2 - b - h * d.paddedWidth;
                }
                return a;
            };
            b.prototype.translate = function () {
                var a = this, b = a.chart, c = a.options, d = a.dense = 2 > a.closestPointRange * a.xAxis.transA;
                d = a.borderWidth = t(c.borderWidth, d ? 0 : 1);
                var f = a.xAxis, g = a.yAxis, h = c.threshold, i = a.translatedThreshold = g.getThreshold(h), j = t(c.minPointLength, 5), k = a.getColumnMetrics(), m = k.width, o = a.pointXOffset = k.offset, p = a.dataMin, q = a.dataMax, s = a.barW = Math.max(m, 1 + 2 * d);
                b.inverted && (i -= .5);
                c.pointPadding && (s = Math.ceil(s));
                e.prototype.translate.apply(a);
                a.points.forEach(function (d) {
                    var e = t(d.yBottom, i), u = 999 + Math.abs(e), v = d.plotX || 0;
                    u = l(d.plotY, -u, g.len + u);
                    var w = Math.min(u, e), x = Math.max(u, e) - w, y = m, z = v + o, A = s;
                    j && Math.abs(x) < j && (x = j, v = !g.reversed && !d.negative || g.reversed && d.negative,
                        r(h) && r(q) && d.y === h && q <= h && (g.min || 0) < h && (p !== q || (g.max || 0) <= h) && (v = !v),
                        w = Math.abs(w - i) > j ? e - j : i - (v ? j : 0));
                    n(d.options.pointWidth) && (y = A = Math.ceil(d.options.pointWidth), z -= Math.round((y - m) / 2));
                    c.centerInCategory && (z = a.adjustForMissingColumns(z, y, d, k));
                    d.barX = z;
                    d.pointWidth = y;
                    d.tooltipPos = b.inverted ? [l(g.len + g.pos - b.plotLeft - u, g.pos - b.plotLeft, g.len + g.pos - b.plotLeft), f.len + f.pos - b.plotTop - z - A / 2, x] : [f.left - b.plotLeft + z + A / 2, l(u + g.pos - b.plotTop, g.pos - b.plotTop, g.len + g.pos - b.plotTop), x];
                    d.shapeType = a.pointClass.prototype.shapeType || "rect";
                    d.shapeArgs = a.crispCol.apply(a, d.isNull ? [z, i, A, 0] : [z, w, A, x]);
                });
            };
            b.prototype.drawGraph = function () {
                this.group[this.dense ? "addClass" : "removeClass"]("highcharts-dense-data");
            };
            b.prototype.pointAttribs = function (a, b) {
                var c = this.options, d = this.pointAttrToOptions || {}, e = d.stroke || "borderColor", f = d["stroke-width"] || "borderWidth", g = a && a.color || this.color, h = a && a[e] || c[e] || g;
                d = a && a.options.dashStyle || c.dashStyle;
                var i = a && a[f] || c[f] || this[f] || 0, k = t(a && a.opacity, c.opacity, 1);
                if (a && this.zones.length) {
                    var l = a.getZone();
                    g = a.options.color || l && (l.color || a.nonZonedColor) || this.color;
                    l && (h = l.borderColor || h, d = l.dashStyle || d, i = l.borderWidth || i);
                }
                b && a && (a = s(c.states[b], a.options.states && a.options.states[b] || {}), b = a.brightness,
                    g = a.color || "undefined" !== typeof b && j(g).brighten(a.brightness).get() || g,
                    h = a[e] || h, i = a[f] || i, d = a.dashStyle || d, k = t(a.opacity, k));
                e = {
                    fill: g,
                    stroke: h,
                    "stroke-width": i,
                    opacity: k
                };
                d && (e.dashstyle = d);
                return e;
            };
            b.prototype.drawPoints = function () {
                var a = this, b = this.chart, c = a.options, d = b.renderer, e = c.animationLimit || 250, f;
                a.points.forEach(function (g) {
                    var h = g.graphic, i = !!h, j = h && b.pointCount < e ? "animate" : "attr";
                    if (r(g.plotY) && null !== g.y) {
                        f = g.shapeArgs;
                        h && g.hasNewShapeType() && (h = h.destroy());
                        a.enabledDataSorting && (g.startXPos = a.xAxis.reversed ? -(f ? f.width || 0 : 0) : a.xAxis.width);
                        h || (g.graphic = h = d[g.shapeType](f).add(g.group || a.group)) && a.enabledDataSorting && b.hasRendered && b.pointCount < e && (h.attr({
                            x: g.startXPos
                        }), i = !0, j = "animate");
                        if (h && i) h[j](s(f));
                        if (c.borderRadius) h[j]({
                            r: c.borderRadius
                        });
                        b.styledMode || h[j](a.pointAttribs(g, g.selected && "select")).shadow(!1 !== g.allowShadow && c.shadow, null, c.stacking && !c.borderRadius);
                        h && (h.addClass(g.getClassName(), !0), h.attr({
                            visibility: g.visible ? "inherit" : "hidden"
                        }));
                    } else h && (g.graphic = h.destroy());
                });
            };
            b.prototype.drawTracker = function () {
                var a = this, b = a.chart, c = b.pointer, d = function (a) {
                    var b = c.getPointFromEvent(a);
                    "undefined" !== typeof b && (c.isDirectTouch = !0, b.onMouseOver(a));
                }, e;
                a.points.forEach(function (a) {
                    e = q(a.dataLabels) ? a.dataLabels : a.dataLabel ? [a.dataLabel] : [];
                    a.graphic && (a.graphic.element.point = a);
                    e.forEach(function (b) {
                        b.div ? b.div.point = a : b.element.point = a;
                    });
                });
                a._hasTracking || (a.trackerGroups.forEach(function (e) {
                    if (a[e]) {
                        a[e].addClass("highcharts-tracker").on("mouseover", d).on("mouseout", function (a) {
                            c.onTrackerMouseOut(a);
                        });
                        if (k) a[e].on("touchstart", d);
                        !b.styledMode && a.options.cursor && a[e].css(m).css({
                            cursor: a.options.cursor
                        });
                    }
                }), a._hasTracking = !0);
                p(this, "afterDrawTracker");
            };
            b.prototype.remove = function () {
                var a = this, b = a.chart;
                b.hasRendered && b.series.forEach(function (b) {
                    b.type === a.type && (b.isDirty = !0);
                });
                e.prototype.remove.apply(a, arguments);
            };
            b.defaultOptions = s(e.defaultOptions, {
                borderRadius: 0,
                centerInCategory: !1,
                groupPadding: .2,
                marker: null,
                pointPadding: .1,
                minPointLength: 0,
                cropThreshold: 50,
                pointRange: null,
                states: {
                    hover: {
                        halo: !1,
                        brightness: .1
                    },
                    select: {
                        color: "#cccccc",
                        borderColor: "#000000"
                    }
                },
                dataLabels: {
                    align: void 0,
                    verticalAlign: void 0,
                    y: void 0
                },
                startFromThreshold: !0,
                stickyTracking: !1,
                tooltip: {
                    distance: 6
                },
                threshold: 0,
                borderColor: "#ffffff"
            });
            return b;
        }(e);
        o(g.prototype, {
            cropShoulder: 0,
            directTouch: !0,
            drawLegendSymbol: d.drawRectangle,
            getSymbol: a,
            negStacks: !0,
            trackerGroups: ["group", "dataLabelsGroup"]
        });
        f.registerSeriesType("column", g);
        return g;
    });
    b(c, "Core/Series/DataLabel.js", [c["Core/Animation/AnimationUtilities.js"], c["Core/FormatUtilities.js"], c["Core/Utilities.js"]], function (a, b, c) {
        var d = a.getDeferredAnimation, e = b.format, f = c.defined, g = c.extend, h = c.fireEvent, i = c.isArray, j = c.merge, k = c.objectEach, l = c.pick, m = c.splat, n;
        !function (a) {
            function b(a, b, c, d, e) {
                var f = this, h = this.chart, i = this.isCartesian && h.inverted, j = this.enabledDataSorting, k = l(a.dlBox && a.dlBox.centerX, a.plotX, -9999), m = l(a.plotY, -9999), n = b.getBBox(), o = c.rotation, p = c.align, q = h.isInsidePlot(k, Math.round(m), {
                    inverted: i,
                    paneCoordinates: !0,
                    series: f
                }), r = function (c) {
                    j && f.xAxis && !s && f.setDataLabelStartPos(a, b, e, q, c);
                }, s = "justify" === l(c.overflow, j ? "none" : "justify"), t = this.visible && !1 !== a.visible && (a.series.forceDL || j && !s || q || l(c.inside, !!this.options.stacking) && d && h.isInsidePlot(k, i ? d.x + 1 : d.y + d.height - 1, {
                    inverted: i,
                    paneCoordinates: !0,
                    series: f
                }));
                if (t) {
                    var u = h.renderer.fontMetrics(h.styledMode ? void 0 : c.style.fontSize, b).b;
                    d = g({
                        x: i ? this.yAxis.len - m : k,
                        y: Math.round(i ? this.xAxis.len - k : m),
                        width: 0,
                        height: 0
                    }, d);
                    g(c, {
                        width: n.width,
                        height: n.height
                    });
                    o ? (s = !1, k = h.renderer.rotCorr(u, o), k = {
                        x: d.x + (c.x || 0) + d.width / 2 + k.x,
                        y: d.y + (c.y || 0) + {
                            top: 0,
                            middle: .5,
                            bottom: 1
                        }[c.verticalAlign] * d.height
                    }, r(k), b[e ? "attr" : "animate"](k).attr({
                        align: p
                    }), r = (o + 720) % 360, r = 180 < r && 360 > r, "left" === p ? k.y -= r ? n.height : 0 : "center" === p ? (k.x -= n.width / 2,
                        k.y -= n.height / 2) : "right" === p && (k.x -= n.width, k.y -= r ? 0 : n.height),
                        b.placed = !0, b.alignAttr = k) : (r(d), b.align(c, void 0, d), k = b.alignAttr);
                    s && 0 <= d.height ? this.justifyDataLabel(b, c, k, n, d, e) : l(c.crop, !0) && (t = h.isInsidePlot(k.x, k.y, {
                        paneCoordinates: !0,
                        series: f
                    }) && h.isInsidePlot(k.x + n.width, k.y + n.height, {
                        paneCoordinates: !0,
                        series: f
                    }));
                    if (c.shape && !o) b[e ? "attr" : "animate"]({
                        anchorX: i ? h.plotWidth - a.plotY : a.plotX,
                        anchorY: i ? h.plotHeight - a.plotX : a.plotY
                    });
                }
                e && j && (b.placed = !1);
                t || j && !s || (b.hide(!0), b.placed = !1);
            }
            function c(a, b) {
                var c = b.filter;
                return c ? (b = c.operator, a = a[c.property], c = c.value, ">" === b && a > c || "<" === b && a < c || ">=" === b && a >= c || "<=" === b && a <= c || "==" === b && a == c || "===" === b && a === c ? !0 : !1) : !0;
            }
            function n() {
                var a = this, b = a.chart, g = a.options, j = a.points, n = a.hasRendered || 0, o = b.renderer, q = g.dataLabels, r, s = q.animation;
                s = q.defer ? d(b, s, a) : {
                    defer: 0,
                    duration: 0
                };
                q = p(p(b.options.plotOptions && b.options.plotOptions.series && b.options.plotOptions.series.dataLabels, b.options.plotOptions && b.options.plotOptions[a.type] && b.options.plotOptions[a.type].dataLabels), q);
                h(this, "drawDataLabels");
                if (i(q) || q.enabled || a._hasPointLabels) {
                    var t = a.plotGroup("dataLabelsGroup", "data-labels", n ? "inherit" : "hidden", q.zIndex || 6);
                    t.attr({
                        opacity: +n
                    });
                    !n && (n = a.dataLabelsGroup) && (a.visible && t.show(!0), n[g.animation ? "animate" : "attr"]({
                        opacity: 1
                    }, s));
                    j.forEach(function (d) {
                        r = m(p(q, d.dlOptions || d.options && d.options.dataLabels));
                        r.forEach(function (h, i) {
                            var j = h.enabled && (!d.isNull || d.dataLabelOnNull) && c(d, h), m = d.connectors ? d.connectors[i] : d.connector, n = d.dataLabels ? d.dataLabels[i] : d.dataLabel, p = !n, q = l(h.distance, d.labelDistance);
                            if (j) {
                                var r = d.getLabelConfig();
                                var s = l(h[d.formatPrefix + "Format"], h.format);
                                r = f(s) ? e(s, r, b) : (h[d.formatPrefix + "Formatter"] || h.formatter).call(r, h);
                                s = h.style;
                                var u = h.rotation;
                                b.styledMode || (s.color = l(h.color, s.color, a.color, "#000000"), "contrast" === s.color ? (d.contrastColor = o.getContrast(d.color || a.color),
                                    s.color = !f(q) && h.inside || 0 > q || g.stacking ? d.contrastColor : "#000000") : delete d.contrastColor,
                                    g.cursor && (s.cursor = g.cursor));
                                var v = {
                                    r: h.borderRadius || 0,
                                    rotation: u,
                                    padding: h.padding,
                                    zIndex: 1
                                };
                                b.styledMode || (v.fill = h.backgroundColor, v.stroke = h.borderColor, v["stroke-width"] = h.borderWidth);
                                k(v, function (a, b) {
                                    "undefined" === typeof a && delete v[b];
                                });
                            }
                            !n || j && f(r) && !!n.div === !!h.useHTML && (n.rotation && h.rotation || n.rotation === h.rotation) || (p = !0,
                                d.dataLabel = n = d.dataLabel && d.dataLabel.destroy(), d.dataLabels && (1 === d.dataLabels.length ? delete d.dataLabels : delete d.dataLabels[i]),
                                i || delete d.dataLabel, m && (d.connector = d.connector.destroy(), d.connectors && (1 === d.connectors.length ? delete d.connectors : delete d.connectors[i])));
                            j && f(r) && (n ? v.text = r : (d.dataLabels = d.dataLabels || [], n = d.dataLabels[i] = u ? o.text(r, 0, -9999, h.useHTML).addClass("highcharts-data-label") : o.label(r, 0, -9999, h.shape, null, null, h.useHTML, null, "data-label"),
                                i || (d.dataLabel = n), n.addClass(" highcharts-data-label-color-" + d.colorIndex + " " + (h.className || "") + (h.useHTML ? " highcharts-tracker" : ""))),
                                n.options = h, n.attr(v), b.styledMode || n.css(s).shadow(h.shadow), n.added || n.add(t),
                                h.textPath && !h.useHTML && (n.setTextPath(d.getDataLabelPath && d.getDataLabelPath(n) || d.graphic, h.textPath),
                                    d.dataLabelPath && !h.textPath.enabled && (d.dataLabelPath = d.dataLabelPath.destroy())),
                                a.alignDataLabel(d, n, h, null, p));
                        });
                    });
                }
                h(this, "afterDrawDataLabels");
            }
            function o(a, b, c, d, e, f) {
                var g = this.chart, h = b.align, i = b.verticalAlign, j = a.box ? 0 : a.padding || 0, k = b.x;
                k = void 0 === k ? 0 : k;
                var l = b.y;
                l = void 0 === l ? 0 : l;
                var m = (c.x || 0) + j;
                if (0 > m) {
                    "right" === h && 0 <= k ? (b.align = "left", b.inside = !0) : k -= m;
                    var n = !0;
                }
                m = (c.x || 0) + d.width - j;
                m > g.plotWidth && ("left" === h && 0 >= k ? (b.align = "right", b.inside = !0) : k += g.plotWidth - m,
                    n = !0);
                m = c.y + j;
                0 > m && ("bottom" === i && 0 <= l ? (b.verticalAlign = "top", b.inside = !0) : l -= m,
                    n = !0);
                m = (c.y || 0) + d.height - j;
                m > g.plotHeight && ("top" === i && 0 >= l ? (b.verticalAlign = "bottom", b.inside = !0) : l += g.plotHeight - m,
                    n = !0);
                n && (b.x = k, b.y = l, a.placed = !f, a.align(b, void 0, e));
                return n;
            }
            function p(a, b) {
                var c = [], d;
                if (i(a) && !i(b)) c = a.map(function (a) {
                    return j(a, b);
                }); else if (i(b) && !i(a)) c = b.map(function (b) {
                    return j(a, b);
                }); else if (i(a) || i(b)) for (d = Math.max(a.length, b.length); d--;) c[d] = j(a[d], b[d]); else c = j(a, b);
                return c;
            }
            function q(a, b, c, d, e) {
                var f = this.chart, g = f.inverted, h = this.xAxis, i = h.reversed, j = g ? b.height / 2 : b.width / 2;
                a = (a = a.pointWidth) ? a / 2 : 0;
                b.startXPos = g ? e.x : i ? -j - a : h.width - j + a;
                b.startYPos = g ? i ? this.yAxis.height - j + a : -j - a : e.y;
                d ? "hidden" === b.visibility && (b.show(), b.attr({
                    opacity: 0
                }).animate({
                    opacity: 1
                })) : b.attr({
                    opacity: 1
                }).animate({
                    opacity: 0
                }, void 0, b.hide);
                f.hasRendered && (c && b.attr({
                    x: b.startXPos,
                    y: b.startYPos
                }), b.placed = !0);
            }
            var r = [];
            a.compose = function (a) {
                if (-1 === r.indexOf(a)) {
                    var c = a.prototype;
                    r.push(a);
                    c.alignDataLabel = b;
                    c.drawDataLabels = n;
                    c.justifyDataLabel = o;
                    c.setDataLabelStartPos = q;
                }
            };
        }(n || (n = {}));
        return n;
    });
    b(c, "Series/Column/ColumnDataLabel.js", [c["Core/Series/DataLabel.js"], c["Core/Series/SeriesRegistry.js"], c["Core/Utilities.js"]], function (a, b, c) {
        var d = b.series, e = c.merge, f = c.pick, g;
        !function (b) {
            function c(a, b, c, g, h) {
                var i = this.chart.inverted, j = a.series, k = (j.xAxis ? j.xAxis.len : this.chart.plotSizeX) || 0;
                j = (j.yAxis ? j.yAxis.len : this.chart.plotSizeY) || 0;
                var l = a.dlBox || a.shapeArgs, m = f(a.below, a.plotY > f(this.translatedThreshold, j)), n = f(c.inside, !!this.options.stacking);
                l && (g = e(l), 0 > g.y && (g.height += g.y, g.y = 0), l = g.y + g.height - j, 0 < l && l < g.height && (g.height -= l),
                    i && (g = {
                        x: j - g.y - g.height,
                        y: k - g.x - g.width,
                        width: g.height,
                        height: g.width
                    }), n || (i ? (g.x += m ? 0 : g.width, g.width = 0) : (g.y += m ? g.height : 0,
                        g.height = 0)));
                c.align = f(c.align, !i || n ? "center" : m ? "right" : "left");
                c.verticalAlign = f(c.verticalAlign, i || n ? "middle" : m ? "top" : "bottom");
                d.prototype.alignDataLabel.call(this, a, b, c, g, h);
                c.inside && a.contrastColor && b.css({
                    color: a.contrastColor
                });
            }
            var g = [];
            b.compose = function (b) {
                a.compose(d);
                -1 === g.indexOf(b) && (g.push(b), b.prototype.alignDataLabel = c);
            };
        }(g || (g = {}));
        return g;
    });
    b(c, "Series/Bar/BarSeries.js", [c["Series/Column/ColumnSeries.js"], c["Core/Series/SeriesRegistry.js"], c["Core/Utilities.js"]], function (a, b, c) {
        var d = this && this.__extends || function () {
            var a = function (b, c) {
                a = Object.setPrototypeOf || {
                    __proto__: []
                } instanceof Array && function (a, b) {
                    a.__proto__ = b;
                } || function (a, b) {
                    for (var c in b) b.hasOwnProperty(c) && (a[c] = b[c]);
                };
                return a(b, c);
            };
            return function (b, c) {
                function d() {
                    this.constructor = b;
                }
                a(b, c);
                b.prototype = null === c ? Object.create(c) : (d.prototype = c.prototype, new d());
            };
        }(), e = c.extend, f = c.merge;
        c = function (b) {
            function c() {
                var a = null !== b && b.apply(this, arguments) || this;
                a.data = void 0;
                a.options = void 0;
                a.points = void 0;
                return a;
            }
            d(c, b);
            c.defaultOptions = f(a.defaultOptions, {});
            return c;
        }(a);
        e(c.prototype, {
            inverted: !0
        });
        b.registerSeriesType("bar", c);
        return c;
    });
    b(c, "Series/Scatter/ScatterSeries.js", [c["Series/Column/ColumnSeries.js"], c["Series/Line/LineSeries.js"], c["Core/Series/SeriesRegistry.js"], c["Core/Utilities.js"]], function (a, b, c, d) {
        var e = this && this.__extends || function () {
            var a = function (b, c) {
                a = Object.setPrototypeOf || {
                    __proto__: []
                } instanceof Array && function (a, b) {
                    a.__proto__ = b;
                } || function (a, b) {
                    for (var c in b) b.hasOwnProperty(c) && (a[c] = b[c]);
                };
                return a(b, c);
            };
            return function (b, c) {
                function d() {
                    this.constructor = b;
                }
                a(b, c);
                b.prototype = null === c ? Object.create(c) : (d.prototype = c.prototype, new d());
            };
        }(), f = d.addEvent, g = d.extend, h = d.merge;
        d = function (a) {
            function c() {
                var b = null !== a && a.apply(this, arguments) || this;
                b.data = void 0;
                b.options = void 0;
                b.points = void 0;
                return b;
            }
            e(c, a);
            c.prototype.applyJitter = function () {
                var a = this, b = this.options.jitter, c = this.points.length;
                b && this.points.forEach(function (d, e) {
                    ["x", "y"].forEach(function (f, g) {
                        var h = "plot" + f.toUpperCase();
                        if (b[f] && !d.isNull) {
                            var i = a[f + "Axis"];
                            var j = b[f] * i.transA;
                            if (i && !i.isLog) {
                                var k = Math.max(0, d[h] - j);
                                i = Math.min(i.len, d[h] + j);
                                g = 1e4 * Math.sin(e + g * c);
                                d[h] = k + (i - k) * (g - Math.floor(g));
                                "x" === f && (d.clientX = d.plotX);
                            }
                        }
                    });
                });
            };
            c.prototype.drawGraph = function () {
                this.options.lineWidth ? a.prototype.drawGraph.call(this) : this.graph && (this.graph = this.graph.destroy());
            };
            c.defaultOptions = h(b.defaultOptions, {
                lineWidth: 0,
                findNearestPointBy: "xy",
                jitter: {
                    x: 0,
                    y: 0
                },
                marker: {
                    enabled: !0
                },
                tooltip: {
                    headerFormat: '<span style="color:{point.color}">●</span> <span style="font-size: 10px"> {series.name}</span><br/>',
                    pointFormat: "x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>"
                }
            });
            return c;
        }(b);
        g(d.prototype, {
            drawTracker: a.prototype.drawTracker,
            sorted: !1,
            requireSorting: !1,
            noSharedTooltip: !0,
            trackerGroups: ["group", "markerGroup", "dataLabelsGroup"],
            takeOrdinalPosition: !1
        });
        f(d, "afterTranslate", function () {
            this.applyJitter();
        });
        c.registerSeriesType("scatter", d);
        return d;
    });
    b(c, "Series/CenteredUtilities.js", [c["Core/Globals.js"], c["Core/Series/Series.js"], c["Core/Utilities.js"]], function (a, b, c) {
        var d = a.deg2rad, e = c.isNumber, f = c.pick, g = c.relativeLength, h;
        !function (a) {
            a.getCenter = function () {
                var a = this.options, c = this.chart, d = 2 * (a.slicedOffset || 0), e = c.plotWidth - 2 * d, h = c.plotHeight - 2 * d, i = a.center, j = Math.min(e, h), k = a.size, l = a.innerSize || 0;
                "string" === typeof k && (k = parseFloat(k));
                "string" === typeof l && (l = parseFloat(l));
                a = [f(i[0], "50%"), f(i[1], "50%"), f(k && 0 > k ? void 0 : a.size, "100%"), f(l && 0 > l ? void 0 : a.innerSize || 0, "0%")];
                !c.angular || this instanceof b || (a[3] = 0);
                for (i = 0; 4 > i; ++i) k = a[i], c = 2 > i || 2 === i && /%$/.test(k), a[i] = g(k, [e, h, j, a[2]][i]) + (c ? d : 0);
                a[3] > a[2] && (a[3] = a[2]);
                return a;
            };
            a.getStartAndEndRadians = function (a, b) {
                a = e(a) ? a : 0;
                b = e(b) && b > a && 360 > b - a ? b : a + 360;
                return {
                    start: d * (a + -90),
                    end: d * (b + -90)
                };
            };
        }(h || (h = {}));
        return h;
    });
    b(c, "Series/Pie/PiePoint.js", [c["Core/Animation/AnimationUtilities.js"], c["Core/Series/Point.js"], c["Core/Utilities.js"]], function (a, b, c) {
        var d = this && this.__extends || function () {
            var a = function (b, c) {
                a = Object.setPrototypeOf || {
                    __proto__: []
                } instanceof Array && function (a, b) {
                    a.__proto__ = b;
                } || function (a, b) {
                    for (var c in b) b.hasOwnProperty(c) && (a[c] = b[c]);
                };
                return a(b, c);
            };
            return function (b, c) {
                function d() {
                    this.constructor = b;
                }
                a(b, c);
                b.prototype = null === c ? Object.create(c) : (d.prototype = c.prototype, new d());
            };
        }(), e = a.setAnimation, f = c.addEvent, g = c.defined;
        a = c.extend;
        var h = c.isNumber, i = c.pick, j = c.relativeLength;
        b = function (a) {
            function b() {
                var b = null !== a && a.apply(this, arguments) || this;
                b.labelDistance = void 0;
                b.options = void 0;
                b.series = void 0;
                return b;
            }
            d(b, a);
            b.prototype.getConnectorPath = function () {
                var a = this.labelPosition, b = this.series.options.dataLabels, c = this.connectorShapes, d = b.connectorShape;
                c[d] && (d = c[d]);
                return d.call(this, {
                    x: a.final.x,
                    y: a.final.y,
                    alignment: a.alignment
                }, a.connectorPosition, b);
            };
            b.prototype.getTranslate = function () {
                return this.sliced ? this.slicedTranslation : {
                    translateX: 0,
                    translateY: 0
                };
            };
            b.prototype.haloPath = function (a) {
                var b = this.shapeArgs;
                return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(b.x, b.y, b.r + a, b.r + a, {
                    innerR: b.r - 1,
                    start: b.start,
                    end: b.end
                });
            };
            b.prototype.init = function () {
                var b = this;
                a.prototype.init.apply(this, arguments);
                this.name = i(this.name, "Slice");
                var c = function (a) {
                    b.slice("select" === a.type);
                };
                f(this, "select", c);
                f(this, "unselect", c);
                return this;
            };
            b.prototype.isValid = function () {
                return h(this.y) && 0 <= this.y;
            };
            b.prototype.setVisible = function (a, b) {
                var c = this, d = this.series, e = d.chart, f = d.options.ignoreHiddenPoint;
                b = i(b, f);
                a !== this.visible && (this.visible = this.options.visible = a = "undefined" === typeof a ? !this.visible : a,
                    d.options.data[d.data.indexOf(this)] = this.options, ["graphic", "dataLabel", "connector", "shadowGroup"].forEach(function (b) {
                        if (c[b]) c[b][a ? "show" : "hide"](a);
                    }), this.legendItem && e.legend.colorizeItem(this, a), a || "hover" !== this.state || this.setState(""),
                    f && (d.isDirty = !0), b && e.redraw());
            };
            b.prototype.slice = function (a, b, c) {
                var d = this.series;
                e(c, d.chart);
                i(b, !0);
                this.sliced = this.options.sliced = g(a) ? a : !this.sliced;
                d.options.data[d.data.indexOf(this)] = this.options;
                this.graphic && this.graphic.animate(this.getTranslate());
                this.shadowGroup && this.shadowGroup.animate(this.getTranslate());
            };
            return b;
        }(b);
        a(b.prototype, {
            connectorShapes: {
                fixedOffset: function (a, b, c) {
                    var d = b.breakAt;
                    b = b.touchingSliceAt;
                    return [["M", a.x, a.y], c.softConnector ? ["C", a.x + ("left" === a.alignment ? -5 : 5), a.y, 2 * d.x - b.x, 2 * d.y - b.y, d.x, d.y] : ["L", d.x, d.y], ["L", b.x, b.y]];
                },
                straight: function (a, b) {
                    b = b.touchingSliceAt;
                    return [["M", a.x, a.y], ["L", b.x, b.y]];
                },
                crookedLine: function (a, b, c) {
                    b = b.touchingSliceAt;
                    var d = this.series, e = d.center[0], f = d.chart.plotWidth, g = d.chart.plotLeft;
                    d = a.alignment;
                    var h = this.shapeArgs.r;
                    c = j(c.crookDistance, 1);
                    f = "left" === d ? e + h + (f + g - e - h) * (1 - c) : g + (e - h) * c;
                    c = ["L", f, a.y];
                    e = !0;
                    if ("left" === d ? f > a.x || f < b.x : f < a.x || f > b.x) e = !1;
                    a = [["M", a.x, a.y]];
                    e && a.push(c);
                    a.push(["L", b.x, b.y]);
                    return a;
                }
            }
        });
        return b;
    });
    b(c, "Series/Pie/PieSeries.js", [c["Series/CenteredUtilities.js"], c["Series/Column/ColumnSeries.js"], c["Core/Globals.js"], c["Core/Legend/LegendSymbol.js"], c["Series/Pie/PiePoint.js"], c["Core/Series/Series.js"], c["Core/Series/SeriesRegistry.js"], c["Core/Renderer/SVG/Symbols.js"], c["Core/Utilities.js"]], function (a, b, c, d, e, f, g, h, i) {
        var j = this && this.__extends || function () {
            var a = function (b, c) {
                a = Object.setPrototypeOf || {
                    __proto__: []
                } instanceof Array && function (a, b) {
                    a.__proto__ = b;
                } || function (a, b) {
                    for (var c in b) b.hasOwnProperty(c) && (a[c] = b[c]);
                };
                return a(b, c);
            };
            return function (b, c) {
                function d() {
                    this.constructor = b;
                }
                a(b, c);
                b.prototype = null === c ? Object.create(c) : (d.prototype = c.prototype, new d());
            };
        }(), k = a.getStartAndEndRadians;
        c = c.noop;
        var l = i.clamp, m = i.extend, n = i.fireEvent, o = i.merge, p = i.pick, q = i.relativeLength;
        i = function (a) {
            function b() {
                var b = null !== a && a.apply(this, arguments) || this;
                b.center = void 0;
                b.data = void 0;
                b.maxLabelDistance = void 0;
                b.options = void 0;
                b.points = void 0;
                return b;
            }
            j(b, a);
            b.prototype.animate = function (a) {
                var b = this, c = b.points, d = b.startAngleRad;
                a || c.forEach(function (a) {
                    var c = a.graphic, e = a.shapeArgs;
                    c && e && (c.attr({
                        r: p(a.startR, b.center && b.center[3] / 2),
                        start: d,
                        end: d
                    }), c.animate({
                        r: e.r,
                        start: e.start,
                        end: e.end
                    }, b.options.animation));
                });
            };
            b.prototype.drawEmpty = function () {
                var a = this.startAngleRad, b = this.endAngleRad, c = this.options;
                if (0 === this.total && this.center) {
                    var d = this.center[0];
                    var e = this.center[1];
                    this.graph || (this.graph = this.chart.renderer.arc(d, e, this.center[1] / 2, 0, a, b).addClass("highcharts-empty-series").add(this.group));
                    this.graph.attr({
                        d: h.arc(d, e, this.center[2] / 2, 0, {
                            start: a,
                            end: b,
                            innerR: this.center[3] / 2
                        })
                    });
                    this.chart.styledMode || this.graph.attr({
                        "stroke-width": c.borderWidth,
                        fill: c.fillColor || "none",
                        stroke: c.color || "#cccccc"
                    });
                } else this.graph && (this.graph = this.graph.destroy());
            };
            b.prototype.drawPoints = function () {
                var a = this.chart.renderer;
                this.points.forEach(function (b) {
                    b.graphic && b.hasNewShapeType() && (b.graphic = b.graphic.destroy());
                    b.graphic || (b.graphic = a[b.shapeType](b.shapeArgs).add(b.series.group), b.delayedRendering = !0);
                });
            };
            b.prototype.generatePoints = function () {
                a.prototype.generatePoints.call(this);
                this.updateTotals();
            };
            b.prototype.getX = function (a, b, c) {
                var d = this.center, e = this.radii ? this.radii[c.index] || 0 : d[2] / 2;
                a = Math.asin(l((a - d[1]) / (e + c.labelDistance), -1, 1));
                return d[0] + (b ? -1 : 1) * Math.cos(a) * (e + c.labelDistance) + (0 < c.labelDistance ? (b ? -1 : 1) * this.options.dataLabels.padding : 0);
            };
            b.prototype.hasData = function () {
                return !!this.processedXData.length;
            };
            b.prototype.redrawPoints = function () {
                var a = this, b = a.chart, c = b.renderer, d = a.options.shadow, e, f, g, h;
                this.drawEmpty();
                !d || a.shadowGroup || b.styledMode || (a.shadowGroup = c.g("shadow").attr({
                    zIndex: -1
                }).add(a.group));
                a.points.forEach(function (i) {
                    var j = {};
                    f = i.graphic;
                    if (!i.isNull && f) {
                        var k = void 0;
                        h = i.shapeArgs;
                        e = i.getTranslate();
                        b.styledMode || (k = i.shadowGroup, d && !k && (k = i.shadowGroup = c.g("shadow").add(a.shadowGroup)),
                            k && k.attr(e), g = a.pointAttribs(i, i.selected && "select"));
                        i.delayedRendering ? (f.setRadialReference(a.center).attr(h).attr(e), b.styledMode || f.attr(g).attr({
                            "stroke-linejoin": "round"
                        }).shadow(d, k), i.delayedRendering = !1) : (f.setRadialReference(a.center), b.styledMode || o(!0, j, g),
                            o(!0, j, h, e), f.animate(j));
                        f.attr({
                            visibility: i.visible ? "inherit" : "hidden"
                        });
                        f.addClass(i.getClassName(), !0);
                    } else f && (i.graphic = f.destroy());
                });
            };
            b.prototype.sortByAngle = function (a, b) {
                a.sort(function (a, c) {
                    return "undefined" !== typeof a.angle && (c.angle - a.angle) * b;
                });
            };
            b.prototype.translate = function (a) {
                this.generatePoints();
                var b = this.options, c = b.slicedOffset, d = c + (b.borderWidth || 0), e = k(b.startAngle, b.endAngle), f = this.startAngleRad = e.start;
                e = (this.endAngleRad = e.end) - f;
                var g = this.points, h = b.dataLabels.distance;
                b = b.ignoreHiddenPoint;
                var i = g.length, j, l = 0;
                a || (this.center = a = this.getCenter());
                for (j = 0; j < i; j++) {
                    var m = g[j];
                    var o = f + l * e;
                    !m.isValid() || b && !m.visible || (l += m.percentage / 100);
                    var r = f + l * e;
                    var s = {
                        x: a[0],
                        y: a[1],
                        r: a[2] / 2,
                        innerR: a[3] / 2,
                        start: Math.round(1e3 * o) / 1e3,
                        end: Math.round(1e3 * r) / 1e3
                    };
                    m.shapeType = "arc";
                    m.shapeArgs = s;
                    m.labelDistance = p(m.options.dataLabels && m.options.dataLabels.distance, h);
                    m.labelDistance = q(m.labelDistance, s.r);
                    this.maxLabelDistance = Math.max(this.maxLabelDistance || 0, m.labelDistance);
                    r = (r + o) / 2;
                    r > 1.5 * Math.PI ? r -= 2 * Math.PI : r < -Math.PI / 2 && (r += 2 * Math.PI);
                    m.slicedTranslation = {
                        translateX: Math.round(Math.cos(r) * c),
                        translateY: Math.round(Math.sin(r) * c)
                    };
                    s = Math.cos(r) * a[2] / 2;
                    var t = Math.sin(r) * a[2] / 2;
                    m.tooltipPos = [a[0] + .7 * s, a[1] + .7 * t];
                    m.half = r < -Math.PI / 2 || r > Math.PI / 2 ? 1 : 0;
                    m.angle = r;
                    o = Math.min(d, m.labelDistance / 5);
                    m.labelPosition = {
                        natural: {
                            x: a[0] + s + Math.cos(r) * m.labelDistance,
                            y: a[1] + t + Math.sin(r) * m.labelDistance
                        },
                        "final": {},
                        alignment: 0 > m.labelDistance ? "center" : m.half ? "right" : "left",
                        connectorPosition: {
                            breakAt: {
                                x: a[0] + s + Math.cos(r) * o,
                                y: a[1] + t + Math.sin(r) * o
                            },
                            touchingSliceAt: {
                                x: a[0] + s,
                                y: a[1] + t
                            }
                        }
                    };
                }
                n(this, "afterTranslate");
            };
            b.prototype.updateTotals = function () {
                var a = this.points, b = a.length, c = this.options.ignoreHiddenPoint, d, e = 0;
                for (d = 0; d < b; d++) {
                    var f = a[d];
                    !f.isValid() || c && !f.visible || (e += f.y);
                }
                this.total = e;
                for (d = 0; d < b; d++) f = a[d], f.percentage = 0 < e && (f.visible || !c) ? f.y / e * 100 : 0,
                    f.total = e;
            };
            b.defaultOptions = o(f.defaultOptions, {
                center: [null, null],
                clip: !1,
                colorByPoint: !0,
                dataLabels: {
                    allowOverlap: !0,
                    connectorPadding: 5,
                    connectorShape: "fixedOffset",
                    crookDistance: "70%",
                    distance: 30,
                    enabled: !0,
                    formatter: function () {
                        return this.point.isNull ? void 0 : this.point.name;
                    },
                    softConnector: !0,
                    x: 0
                },
                fillColor: void 0,
                ignoreHiddenPoint: !0,
                inactiveOtherPoints: !0,
                legendType: "point",
                marker: null,
                size: null,
                showInLegend: !1,
                slicedOffset: 10,
                stickyTracking: !1,
                tooltip: {
                    followPointer: !0
                },
                borderColor: "#ffffff",
                borderWidth: 1,
                lineWidth: void 0,
                states: {
                    hover: {
                        brightness: .1
                    }
                }
            });
            return b;
        }(f);
        m(i.prototype, {
            axisTypes: [],
            directTouch: !0,
            drawGraph: void 0,
            drawLegendSymbol: d.drawRectangle,
            drawTracker: b.prototype.drawTracker,
            getCenter: a.getCenter,
            getSymbol: c,
            isCartesian: !1,
            noSharedTooltip: !0,
            pointAttribs: b.prototype.pointAttribs,
            pointClass: e,
            requireSorting: !1,
            searchPoint: c,
            trackerGroups: ["group", "dataLabelsGroup"]
        });
        g.registerSeriesType("pie", i);
        return i;
    });
    b(c, "Series/Pie/PieDataLabel.js", [c["Core/Series/DataLabel.js"], c["Core/Globals.js"], c["Core/Renderer/RendererUtilities.js"], c["Core/Series/SeriesRegistry.js"], c["Core/Utilities.js"]], function (a, b, c, d, e) {
        var f = b.noop, g = c.distribute, h = d.series, i = e.arrayMax, j = e.clamp, k = e.defined, l = e.merge, m = e.pick, n = e.relativeLength, o;
        !function (b) {
            function c() {
                var a = this, b = a.data, c = a.chart, d = a.options.dataLabels || {}, e = d.connectorPadding, f = c.plotWidth, j = c.plotHeight, n = c.plotLeft, o = Math.round(c.chartWidth / 3), p = a.center, q = p[2] / 2, r = p[1], s = [[], []], t = [0, 0, 0, 0], u = a.dataLabelPositioners, v, w, x, y, z, A, B, C, D, E, F, G;
                a.visible && (d.enabled || a._hasPointLabels) && (b.forEach(function (a) {
                    a.dataLabel && a.visible && a.dataLabel.shortened && (a.dataLabel.attr({
                        width: "auto"
                    }).css({
                        width: "auto",
                        textOverflow: "clip"
                    }), a.dataLabel.shortened = !1);
                }), h.prototype.drawDataLabels.apply(a), b.forEach(function (a) {
                    a.dataLabel && (a.visible ? (s[a.half].push(a), a.dataLabel._pos = null, !k(d.style.width) && !k(a.options.dataLabels && a.options.dataLabels.style && a.options.dataLabels.style.width) && a.dataLabel.getBBox().width > o && (a.dataLabel.css({
                        width: Math.round(.7 * o) + "px"
                    }), a.dataLabel.shortened = !0)) : (a.dataLabel = a.dataLabel.destroy(), a.dataLabels && 1 === a.dataLabels.length && delete a.dataLabels));
                }), s.forEach(function (b, h) {
                    var i = b.length, l = [], o;
                    if (i) {
                        a.sortByAngle(b, h - .5);
                        if (0 < a.maxLabelDistance) {
                            var s = Math.max(0, r - q - a.maxLabelDistance);
                            var w = Math.min(r + q + a.maxLabelDistance, c.plotHeight);
                            b.forEach(function (a) {
                                0 < a.labelDistance && a.dataLabel && (a.top = Math.max(0, r - q - a.labelDistance),
                                    a.bottom = Math.min(r + q + a.labelDistance, c.plotHeight), o = a.dataLabel.getBBox().height || 21,
                                    a.distributeBox = {
                                        target: a.labelPosition.natural.y - a.top + o / 2,
                                        size: o,
                                        rank: a.y
                                    }, l.push(a.distributeBox));
                            });
                            s = w + o - s;
                            g(l, s, s / 5);
                        }
                        for (F = 0; F < i; F++) {
                            v = b[F];
                            A = v.labelPosition;
                            y = v.dataLabel;
                            E = !1 === v.visible ? "hidden" : "inherit";
                            D = s = A.natural.y;
                            l && k(v.distributeBox) && ("undefined" === typeof v.distributeBox.pos ? E = "hidden" : (B = v.distributeBox.size,
                                D = u.radialDistributionY(v)));
                            delete v.positionIndex;
                            if (d.justify) C = u.justify(v, q, p); else switch (d.alignTo) {
                                case "connectors":
                                    C = u.alignToConnectors(b, h, f, n);
                                    break;

                                case "plotEdges":
                                    C = u.alignToPlotEdges(y, h, f, n);
                                    break;

                                default:
                                    C = u.radialDistributionX(a, v, D, s);
                            }
                            y._attr = {
                                visibility: E,
                                align: A.alignment
                            };
                            G = v.options.dataLabels || {};
                            y._pos = {
                                x: C + m(G.x, d.x) + ({
                                    left: e,
                                    right: -e
                                }[A.alignment] || 0),
                                y: D + m(G.y, d.y) - 10
                            };
                            A.final.x = C;
                            A.final.y = D;
                            m(d.crop, !0) && (z = y.getBBox().width, s = null, C - z < e && 1 === h ? (s = Math.round(z - C + e),
                                t[3] = Math.max(s, t[3])) : C + z > f - e && 0 === h && (s = Math.round(C + z - f + e),
                                    t[1] = Math.max(s, t[1])), 0 > D - B / 2 ? t[0] = Math.max(Math.round(-D + B / 2), t[0]) : D + B / 2 > j && (t[2] = Math.max(Math.round(D + B / 2 - j), t[2])),
                                y.sideOverflow = s);
                        }
                    }
                }), 0 === i(t) || this.verifyDataLabelOverflow(t)) && (this.placeDataLabels(), this.points.forEach(function (b) {
                    G = l(d, b.options.dataLabels);
                    if (w = m(G.connectorWidth, 1)) {
                        var e;
                        x = b.connector;
                        if ((y = b.dataLabel) && y._pos && b.visible && 0 < b.labelDistance) {
                            E = y._attr.visibility;
                            if (e = !x) b.connector = x = c.renderer.path().addClass("highcharts-data-label-connector  highcharts-color-" + b.colorIndex + (b.className ? " " + b.className : "")).add(a.dataLabelsGroup),
                                c.styledMode || x.attr({
                                    "stroke-width": w,
                                    stroke: G.connectorColor || b.color || "#666666"
                                });
                            x[e ? "attr" : "animate"]({
                                d: b.getConnectorPath()
                            });
                            x.attr("visibility", E);
                        } else x && (b.connector = x.destroy());
                    }
                }));
            }
            function d() {
                this.points.forEach(function (a) {
                    var b = a.dataLabel, c;
                    b && a.visible && ((c = b._pos) ? (b.sideOverflow && (b._attr.width = Math.max(b.getBBox().width - b.sideOverflow, 0),
                        b.css({
                            width: b._attr.width + "px",
                            textOverflow: (this.options.dataLabels.style || {}).textOverflow || "ellipsis"
                        }), b.shortened = !0), b.attr(b._attr), b[b.moved ? "animate" : "attr"](c), b.moved = !0) : b && b.attr({
                            y: -9999
                        }));
                    delete a.distributeBox;
                }, this);
            }
            function e(a) {
                var b = this.center, c = this.options, d = c.center, e = c.minSize || 80, f = null !== c.size;
                if (!f) {
                    if (null !== d[0]) var g = Math.max(b[2] - Math.max(a[1], a[3]), e); else g = Math.max(b[2] - a[1] - a[3], e),
                        b[0] += (a[3] - a[1]) / 2;
                    null !== d[1] ? g = j(g, e, b[2] - Math.max(a[0], a[2])) : (g = j(g, e, b[2] - a[0] - a[2]),
                        b[1] += (a[0] - a[2]) / 2);
                    g < b[2] ? (b[2] = g, b[3] = Math.min(n(c.innerSize || 0, g), g), this.translate(b),
                        this.drawDataLabels && this.drawDataLabels()) : f = !0;
                }
                return f;
            }
            var o = [], p = {
                radialDistributionY: function (a) {
                    return a.top + a.distributeBox.pos;
                },
                radialDistributionX: function (a, b, c, d) {
                    return a.getX(c < b.top + 2 || c > b.bottom - 2 ? d : c, b.half, b);
                },
                justify: function (a, b, c) {
                    return c[0] + (a.half ? -1 : 1) * (b + a.labelDistance);
                },
                alignToPlotEdges: function (a, b, c, d) {
                    a = a.getBBox().width;
                    return b ? a + d : c - a - d;
                },
                alignToConnectors: function (a, b, c, d) {
                    var e = 0, f;
                    a.forEach(function (a) {
                        f = a.dataLabel.getBBox().width;
                        f > e && (e = f);
                    });
                    return b ? e + d : c - e - d;
                }
            };
            b.compose = function (b) {
                a.compose(h);
                -1 === o.indexOf(b) && (o.push(b), b = b.prototype, b.dataLabelPositioners = p,
                    b.alignDataLabel = f, b.drawDataLabels = c, b.placeDataLabels = d, b.verifyDataLabelOverflow = e);
            };
        }(o || (o = {}));
        return o;
    });
    b(c, "Extensions/OverlappingDataLabels.js", [c["Core/Chart/Chart.js"], c["Core/Utilities.js"]], function (a, b) {
        function c(a, b) {
            var c = !1;
            if (a) {
                var d = a.newOpacity;
                a.oldOpacity !== d && (a.alignAttr && a.placed ? (a[d ? "removeClass" : "addClass"]("highcharts-data-label-hidden"),
                    c = !0, a.alignAttr.opacity = d, a[a.isOld ? "animate" : "attr"](a.alignAttr, null, function () {
                        b.styledMode || a.css({
                            pointerEvents: d ? "auto" : "none"
                        });
                    }), e(b, "afterHideOverlappingLabel")) : a.attr({
                        opacity: d
                    }));
                a.isOld = !0;
            }
            return c;
        }
        var d = b.addEvent, e = b.fireEvent, f = b.isArray, g = b.isNumber, h = b.objectEach, i = b.pick;
        d(a, "render", function () {
            var a = this, b = [];
            (this.labelCollectors || []).forEach(function (a) {
                b = b.concat(a());
            });
            (this.yAxis || []).forEach(function (a) {
                a.stacking && a.options.stackLabels && !a.options.stackLabels.allowOverlap && h(a.stacking.stacks, function (a) {
                    h(a, function (a) {
                        a.label && "hidden" !== a.label.visibility && b.push(a.label);
                    });
                });
            });
            (this.series || []).forEach(function (d) {
                var e = d.options.dataLabels;
                d.visible && (!1 !== e.enabled || d._hasPointLabels) && (e = function (d) {
                    return d.forEach(function (d) {
                        d.visible && (f(d.dataLabels) ? d.dataLabels : d.dataLabel ? [d.dataLabel] : []).forEach(function (e) {
                            var f = e.options;
                            e.labelrank = i(f.labelrank, d.labelrank, d.shapeArgs && d.shapeArgs.height);
                            f.allowOverlap ? (e.oldOpacity = e.opacity, e.newOpacity = 1, c(e, a)) : b.push(e);
                        });
                    });
                }, e(d.nodes || []), e(d.points));
            });
            this.hideOverlappingLabels(b);
        });
        a.prototype.hideOverlappingLabels = function (a) {
            var b = this, d = a.length, f = b.renderer, h, i, j, k = !1;
            var l = function (a) {
                var b, c = a.box ? 0 : a.padding || 0, d = b = 0, e;
                if (a && (!a.alignAttr || a.placed)) {
                    var h = a.alignAttr || {
                        x: a.attr("x"),
                        y: a.attr("y")
                    };
                    var i = a.parentGroup;
                    a.width || (b = a.getBBox(), a.width = b.width, a.height = b.height, b = f.fontMetrics(null, a.element).h);
                    var j = a.width - 2 * c;
                    (e = {
                        left: "0",
                        center: "0.5",
                        right: "1"
                    }[a.alignValue]) ? d = +e * j : g(a.x) && Math.round(a.x) !== a.translateX && (d = a.x - a.translateX);
                    return {
                        x: h.x + (i.translateX || 0) + c - (d || 0),
                        y: h.y + (i.translateY || 0) + c - b,
                        width: a.width - 2 * c,
                        height: a.height - 2 * c
                    };
                }
            };
            for (i = 0; i < d; i++) if (h = a[i]) h.oldOpacity = h.opacity, h.newOpacity = 1,
                h.absoluteBox = l(h);
            a.sort(function (a, b) {
                return (b.labelrank || 0) - (a.labelrank || 0);
            });
            for (i = 0; i < d; i++) {
                var m = (l = a[i]) && l.absoluteBox;
                for (h = i + 1; h < d; ++h) {
                    var n = (j = a[h]) && j.absoluteBox;
                    !m || !n || l === j || 0 === l.newOpacity || 0 === j.newOpacity || n.x >= m.x + m.width || n.x + n.width <= m.x || n.y >= m.y + m.height || n.y + n.height <= m.y || ((l.labelrank < j.labelrank ? l : j).newOpacity = 0);
                }
            }
            a.forEach(function (a) {
                c(a, b) && (k = !0);
            });
            k && e(b, "afterHideAllOverlappingLabels");
        };
    });
    b(c, "Core/Responsive.js", [c["Core/Utilities.js"]], function (a) {
        var b = a.extend, c = a.find, d = a.isArray, e = a.isObject, f = a.merge, g = a.objectEach, h = a.pick, i = a.splat, j = a.uniqueKey, k;
        !function (a) {
            var k = [];
            a.compose = function (a) {
                -1 === k.indexOf(a) && (k.push(a), b(a.prototype, l.prototype));
                return a;
            };
            var l = function () {
                function a() { }
                a.prototype.currentOptions = function (a) {
                    function b(a, f, h, j) {
                        var k;
                        g(a, function (a, g) {
                            if (!j && -1 < c.collectionsWithUpdate.indexOf(g) && f[g]) for (a = i(a), h[g] = [],
                                k = 0; k < Math.max(a.length, f[g].length); k++) f[g][k] && (void 0 === a[k] ? h[g][k] = f[g][k] : (h[g][k] = {},
                                    b(a[k], f[g][k], h[g][k], j + 1))); else e(a) ? (h[g] = d(a) ? [] : {}, b(a, f[g] || {}, h[g], j + 1)) : h[g] = "undefined" === typeof f[g] ? null : f[g];
                        });
                    }
                    var c = this, f = {};
                    b(a, this.options, f, 0);
                    return f;
                };
                a.prototype.matchResponsiveRule = function (a, b) {
                    var c = a.condition;
                    (c.callback || function () {
                        return this.chartWidth <= h(c.maxWidth, Number.MAX_VALUE) && this.chartHeight <= h(c.maxHeight, Number.MAX_VALUE) && this.chartWidth >= h(c.minWidth, 0) && this.chartHeight >= h(c.minHeight, 0);
                    }).call(this) && b.push(a._id);
                };
                a.prototype.setResponsive = function (a, b) {
                    var d = this, e = this.options.responsive, g = this.currentResponsive, h = [];
                    !b && e && e.rules && e.rules.forEach(function (a) {
                        "undefined" === typeof a._id && (a._id = j());
                        d.matchResponsiveRule(a, h);
                    }, this);
                    b = f.apply(void 0, h.map(function (a) {
                        return c((e || {}).rules || [], function (b) {
                            return b._id === a;
                        });
                    }).map(function (a) {
                        return a && a.chartOptions;
                    }));
                    b.isResponsiveOptions = !0;
                    h = h.toString() || void 0;
                    h !== (g && g.ruleIds) && (g && this.update(g.undoOptions, a, !0), h ? (g = this.currentOptions(b),
                        g.isResponsiveOptions = !0, this.currentResponsive = {
                            ruleIds: h,
                            mergedOptions: b,
                            undoOptions: g
                        }, this.update(b, a, !0)) : this.currentResponsive = void 0);
                };
                return a;
            }();
        }(k || (k = {}));
        return k;
    });
    b(c, "masters/highcharts.src.js", [c["Core/Globals.js"], c["Core/Utilities.js"], c["Core/DefaultOptions.js"], c["Core/Animation/Fx.js"], c["Core/Animation/AnimationUtilities.js"], c["Core/Renderer/HTML/AST.js"], c["Core/FormatUtilities.js"], c["Core/Renderer/RendererUtilities.js"], c["Core/Renderer/SVG/SVGElement.js"], c["Core/Renderer/SVG/SVGRenderer.js"], c["Core/Renderer/HTML/HTMLElement.js"], c["Core/Renderer/HTML/HTMLRenderer.js"], c["Core/Axis/Axis.js"], c["Core/Axis/DateTimeAxis.js"], c["Core/Axis/LogarithmicAxis.js"], c["Core/Axis/PlotLineOrBand/PlotLineOrBand.js"], c["Core/Axis/Tick.js"], c["Core/Tooltip.js"], c["Core/Series/Point.js"], c["Core/Pointer.js"], c["Core/MSPointer.js"], c["Core/Legend/Legend.js"], c["Core/Chart/Chart.js"], c["Core/Series/Series.js"], c["Core/Series/SeriesRegistry.js"], c["Series/Column/ColumnSeries.js"], c["Series/Column/ColumnDataLabel.js"], c["Series/Pie/PieSeries.js"], c["Series/Pie/PieDataLabel.js"], c["Core/Series/DataLabel.js"], c["Core/Responsive.js"], c["Core/Color/Color.js"], c["Core/Time.js"]], function (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, A, B, C, D, E, F, G) {
        a.animate = e.animate;
        a.animObject = e.animObject;
        a.getDeferredAnimation = e.getDeferredAnimation;
        a.setAnimation = e.setAnimation;
        a.stop = e.stop;
        a.timers = d.timers;
        a.AST = f;
        a.Axis = m;
        a.Chart = w;
        a.chart = w.chart;
        a.Fx = d;
        a.Legend = v;
        a.PlotLineOrBand = p;
        a.Point = s;
        a.Pointer = u.isRequired() ? u : t;
        a.Series = x;
        a.SVGElement = i;
        a.SVGRenderer = j;
        a.Tick = q;
        a.Time = G;
        a.Tooltip = r;
        a.Color = F;
        a.color = F.parse;
        l.compose(j);
        k.compose(i);
        a.defaultOptions = c.defaultOptions;
        a.getOptions = c.getOptions;
        a.time = c.defaultTime;
        a.setOptions = c.setOptions;
        a.dateFormat = g.dateFormat;
        a.format = g.format;
        a.numberFormat = g.numberFormat;
        a.addEvent = b.addEvent;
        a.arrayMax = b.arrayMax;
        a.arrayMin = b.arrayMin;
        a.attr = b.attr;
        a.clearTimeout = b.clearTimeout;
        a.correctFloat = b.correctFloat;
        a.createElement = b.createElement;
        a.css = b.css;
        a.defined = b.defined;
        a.destroyObjectProperties = b.destroyObjectProperties;
        a.discardElement = b.discardElement;
        a.distribute = h.distribute;
        a.erase = b.erase;
        a.error = b.error;
        a.extend = b.extend;
        a.extendClass = b.extendClass;
        a.find = b.find;
        a.fireEvent = b.fireEvent;
        a.getMagnitude = b.getMagnitude;
        a.getStyle = b.getStyle;
        a.inArray = b.inArray;
        a.isArray = b.isArray;
        a.isClass = b.isClass;
        a.isDOMElement = b.isDOMElement;
        a.isFunction = b.isFunction;
        a.isNumber = b.isNumber;
        a.isObject = b.isObject;
        a.isString = b.isString;
        a.keys = b.keys;
        a.merge = b.merge;
        a.normalizeTickInterval = b.normalizeTickInterval;
        a.objectEach = b.objectEach;
        a.offset = b.offset;
        a.pad = b.pad;
        a.pick = b.pick;
        a.pInt = b.pInt;
        a.relativeLength = b.relativeLength;
        a.removeEvent = b.removeEvent;
        a.seriesType = y.seriesType;
        a.splat = b.splat;
        a.stableSort = b.stableSort;
        a.syncTimeout = b.syncTimeout;
        a.timeUnits = b.timeUnits;
        a.uniqueKey = b.uniqueKey;
        a.useSerialIds = b.useSerialIds;
        a.wrap = b.wrap;
        A.compose(z);
        D.compose(x);
        n.compose(m);
        o.compose(m);
        C.compose(B);
        p.compose(m);
        E.compose(w);
        return a;
    });
    c["masters/highcharts.src.js"]._modules = c;
    return c["masters/highcharts.src.js"];
});